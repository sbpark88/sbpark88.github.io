---
layout: post
title: SQLD License
subtitle: SQL Developer License
categories: spring
tags: [sqld, slqp, data modeling, erd, 3 level schema, entity, identifier, normalization, denormalization, distributed]
---

### 1. SQLD 자격증이란? 👩‍💻

#### 1. 시험 정보

한국데이터산업징흥원 [K data](https://www.dataq.or.kr/www/main.do) 에서 주관하는 SQL 자격검정이다.

- SQLP : Structured Query Language Professional
- SQLD : Structured Query Language Developer

해당 자격증은 2가지 등급이 존재하며 SQLP보다는 한 단계 낮은 자격증이다.

- 시험시간 : 90분
- 문항수 : 50 (데이터 모델링의 이해 10 + SQL 기본 및 활용 40)
- 배점 : 각 문항당 2점씩 100점 만점
- 합격 기준 : 평균 60, 과목별 40% 이상 취득
- 총 50문항 중 30문항을 맞아야한다.
- 과락을 피하려면 모델링 4문항 SQL 20문항을 넘겨야한다.

SQLP 는 난이도가 꽤 높다고 알려져있다. 하지만 SQLD 는 난이도가 낮은편이다. 퇴근 후, 그리고 주말을 이용해 약 10일 
공부하고 합격했다. 따라서 얇은 책을 선택했고, 그 책은 'SQL 개발자'(임호진 저, 영진닷컴) 이었으나 잘못된 설명도 간간히 보이고, 
오타도 많기로 유명한 책이었다. 😭😭

아무튼 그래도 합격 하는데 문제는 없었으나 공부를 위해서라면 다른 책을 사는게 좋을 것 같으니 판단은 알아서 하시길... 참고로 이 글은 
전반적인 이론에 대한 설명이 아닌 SQLD 시험을 위한 키워드 노트와 같은 글로, 이미 공부를 한 사람에게는 키워드 암기를 위한 용도로, 
시험 공부를 위한 사람에게는 대략적인 학습 내용과 범위를 파악하는 용도로 사용되리라 생각된다.

#### 2. 개발자에게 SQL 이란?

우선 Middleware 에 대해 알아보자.

- Client PC - Database : 직접 연결, 2계층 클라이언트/서버 로 구성된다. -> ODBC
- Client PC - Middleware - Database : 대부분의 환경 구성으로 Middleware가 하는 일은 Client와 Server 사이에서
  Transaction 을 관리한다.

![Python Middleware](/assets/images/posts/2023-02-12-SQLD/python-middleware.png)

[사진 출처](https://github.com/sumedhe/python-middleware)

그리고 이 Middleware 는 RPC(Remote Procedure Call), MOM(Message Oriented Middleware), 
TP-Monitor(Transaction Processing Monitor), ORB(Object Request Broker), 
WAS(Web Application Server) 와 같은 것들이 존재한다.

그리고 이 WAS 를 구성하는게 개발자고, ORM 을 사용할 수도 있지만 MyBatis 같은 SQL 을 것을 이용해 SQL 명령을 직접 
내리기도 한다. 그리고 ORM 을 쓰는 것 역시 기본적으로 SQL 에 대한 이해가 있어야 정확하고 효율적인 코드 구현이 가능하기 
때문에 개발자에게도 SQL 을 이해하는 것은 중요하다.

#### 3. Oracle DB Settings

Database 마다 문법도 조금씩 다르고, 설정 하는 것 역시 다르다. 그 중 SQLD 는 Oracle 을 기본으로 한다. 

Oracle 의 설정은 설치된 디렉토리의 `~/network/admin/` 안에 있다.

- tnsnames.ora : `DB 접속 정보`를 설정.  e.g. 프로토콜, 서버 주소, 포트 번호는 물론 인스턴스 등
- listener.ora : `DB와 Client 사이의 네트워크`를 설정.
- sqlnet.ora : `DB 접속 인증 방식`을 설정.  i.e. 어떤 `인증 방식`을 선택할 것인지...

---

### 2. 데이터 모델링의 이해 👩‍💻

#### 1. Data modeling

__1 ) Data modeling 의 특징__

> 특-단추명
> - 단순화(Simplification) : 누구나 `쉽게 이애할 수 있도록 표현`한다.
> - 추상화(Abstraction) : `현실세계를 간략하게 표현`한다.
> - 명확성(Clarity) : `명확하게` 의미가 `해석`되어야 하고, `한 가지 의미`를 가져야 한다.

<br>

__2 ) Data modeling 의 단계__

> 단-개논물

> 1. 개념적 모델링(Conceptual Data Modeling) : `고객 설명용`
> - 업무적 관점, 전사적 관점 (O), 기술적 용어 (X)
> - 추상화 수준이 가장 높음.
> - Entity, Attribute, 개념적 ERD(Entity Relationship Diagram)을 작성.

> 2. 논리적 모델링(Physical Modeling) : `설계자용`
> - 개념적 모델링 => 논리적 모델링 변환.
> - Identifiers(식별자), Relation(관계), Attribute 을 표현.
> - `정규화`를 통해 재사용성을 높임.

> 3. 물리적 모델링(Physical Modeling) : `개발자용` or `DBA용`
> - 실제 `Database`를 구축.
> - Table, Index, Stored Procedure, Function, View 등을 생성.
> - `성능, 보안, 가용성`을 고려.

<br>

__3 ) Data modeling 의 3요소__

> 띵어리
> - Things
> - Attributes
> - Relationships


<br>

__4 ) Data modeling 의 관점__

- Data : `What` -> 구조 분석, `정적` 분석.
- Process : `How` -> 시나리오 분석, `도메인` 분석, `동적` 분석.
- Data & Process : `Interaction` -> 데이터와 프로세스의 관계. `CRUD` 분석.

#### 2. ERD(Entity Relationship Diagram)

ERD 는 1976년 Peter Chen 이 만든 표기법으로 오늘날 데이터 모델링의 표준으로 사용되고있다.

![ERD](/assets/images/posts/2023-02-12-SQLD/erd_workbench.gif)

![ERD Relationship](/assets/images/posts/2023-02-12-SQLD/erd-relationship.PNG)

__1 ) ERD 작성 절차__

> (Entity) 도배관설 (관계) 관서참여 필수 : Entity 도배와 관로포설은 관련부서 참여가 필수다.
> 
> 1. Entity `도출`, 그리기 : 사각형 그리기.
> 2. Entity `배치` : Entity 위치 설정(중요도 높으면 왼쪽 상단에...).
> 3. Entity `관계` `설정` : Entity 선 긋기.
> 4. `관계`명 `서술` : 선 위에 설명 달기(관계 규정).
> 5. 관계 `참여도` : 1:1, 1:N 등을 표현(선 위에 사람 모양).
> 6. 관계 `필수` 여부 : 반드시 존재해야 하는 것(선 위에 막대기).

<br>

__2 ) ERD 작성시 고려 사항__

> - ERD 는 `쉽고` 복잡하지 않아야 한다.
> - 독립성 : `데이터 중복`을 `제거`해 `정규화`

#### 3. 3-Level Schema

ANSI 표준으로 독립성을 확보하기 위한 방법으로 3 개의 레벨로 나눈다.

> 외개내 : 외계인은 우리 내부에 있다.
> 
> | Schema               | Characteristics               |
> |----------------------|-------------------------------|
> | `외부`(External) 스키마   | `사용자`, `앱` 관점                 |
> | `개념`(Conceptual) 스키마 | `설계자` 관점(전체 DB/테이블 표현)        |
> | `내부`(Internal) 스키마   | `개발자` 관점(물리적/레코드, 필드, 인덱스 표현) |

![3-Level Schema](/assets/images/posts/2023-02-12-SQLD/3-level-schema.png){: width="800"}

| 독립성         | Characteristics              |
|-------------|------------------------------|
| `논`리적 `독`립성 | `개념` 스키마 변경 -> `외부` 스키마 영향 X |
| `물`리적 `독`립성 | `내부` 스키마 변경 -> `개념` 스키마 영향 X |


#### 4. Entity

__1 ) Entity (=테이블, 릴레이션) 특징__

> 식인집속관업 : 식인을 하는 집 속에 갔더니 관이 업청나게 많았다.
> 
> | 특징          | 설명                                  |
> |-------------|-------------------------------------|
> | `식`별자       | 유일한 식별자(PK) (ID, 계좌번호...)           |
> | `인`스턴스 `집`합 | `레코드 2개 이상` 존재 (고객 정보는 2명 이상)       |
> | `속`성        | 엔터티는 속성이 반드시 필요 (ID, PW, 이름, 주소...) |
> | `관`계        | 다른 엔터티와 1개 이상 관계 필요 (고객은 계좌를 개설)    |
> | `업`무        | 업무에서 관리되어야 하는 집합 (고객, 계좌...)        |

<br>

__2 ) Entity 유무형__

> 유개사 : 유개사 지물실
> 
> | 엔터티      | 설명                          |
> |----------|-----------------------------|
> | `유형` 엔터티 | `지속`적 사용, 물리적 형태 O (고객, 사원) |
> | `개념` 엔터티 | `물리적 형태 X` ( 거래소 종목, 보험 상품) |
> | `사건` 엔터티 | 비즈니스 프로세스 `실행` (주문, 계약)     |

<br>

__3 ) Entity 발생 시점__

> 기중행 : 기중행 키엔독
> 
> | 엔터티    | 설명                               |
> |--------|----------------------------------|
> | `기본` 엔터티 | `키 엔터티`, 다른 엔터티 영향 X `독립적` (고객, 상품)  |
> | `중심` 엔터티 | 기본 엔터티로부터 발생 행위 엔터티를 생성 (주문, 계약) |
> | `행위` 엔터티 | 2개 이상의 엔터티로터 발생 (주문 이력)          |

<br>

__4 ) Entity 3가지 공통점__

> 명저띵비프
> - 개념, 사건, 사람, 장소 등과 같이 `명사`.
> - `저장`이 필요한 어떤 것(`Things`).
> - `비즈니스 프로세스`에서 관리되어야 하는 정보.

#### 5. Kind of Relationship

__1 ) 관계 종류__

> 존행 : Entity 간 관계는 존나 행복하다
> 
> | 관계      | 설명                                                                 |
> |---------|--------------------------------------------------------------------|
> | `존재` 관계 | Entity 사이의 `상태` <br>(고객은 관리점에 소속된다 ⇒ 고객 Entity와 관리점 Entity는 존재 관계) |
> | `행위` 관계 | Entity 사이의 `행위` <br>(고객이 계좌를 개설한다 ⇒ 고객 Entity와 계좌 Entity는 행위 관계)   |

<br>

__2 ) 관계 차수(Cardinality)__

![ERD Relationship](/assets/images/posts/2023-02-12-SQLD/erd-relationship.PNG)

| 관계            | 설명                                                                                                                                               |
|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `1:1` 관계      | `완전 1:1` 관계 ⇒ `1:1` Entity 관계 `반드시 존재` <br>`선택적 1:1` 관계 ⇒ `1:1` or `1:0` Entity 관계 필수 아님                                                         |
| `1:N` 관계      | `고객`은 여러 개의 `계좌`를 가질 수 있다. (1:N)                                                                                                                 |
| `M:N` 관계      | `학생`은 여러 `과목`을 수강할 수 있다. (1:N) <br>`과목`은 여러 명의 `학생`이 수강한다. (1:M) <br>⇒ `RDB`에서 `M:N join`은 `카테시안 곱`이 발생하므로 `수강이라는 Entity를 추가`해 `1:N`, `N:1`로 해소. |
| `필수적` 관계 `O`  | 반드시 하나가 있어야 한다. (고객이 있어야 계좌를 만들 수 있다.)                                                                                                           |
| `선택적` 관계  `⎹` | 없을 수도 있다. (고객은 있지만 계좌는 없을 수 있다.)                                                                                                                 |

<br>

__3 ) 식별 관계(Identification Relationship)__

- `실선`
- `PK`가 다른 개체의 `FK`이면서 `PK`

<br>

__4 ) 비식별 관계(Non-Identification Relationship)__

- `점선`
- `PK`가 다른 개체의 `FK`지만 PK가 아닌 일반 컬럼

<br>

__5 ) 강한 개체(Strong Entity)__

- 다른 엔터티에 의존하지 않고 `독립적으로 존재`
- 다른 엔터티와 관계를 가질 때 다른 엔터티에 `기본키를 공유`
- `식별 관계`
- `강한 개체의 기본키 값이 변경`되면 `식별 관계`(기본키를 공유받은) 엔터티의 값도 `변경`
- `고객` 개체에 해당

<br>

__6 ) 약한 개체(Week Entity)__

- 개체의 존재가 다른 개체의 존재에 달려있다
- `계좌` 개체에 해당

#### 6. Attribute

__1 ) Attribute (=컬럼, 속성) 특징__

- 인스턴스(레코드) 구성 요소
- 더이상 분해 X
- 하나의 값만 가짐

<br>

__2 ) Attribute 분해__

> 단복다 : 단 맛 나는 복어다
> 
> | 속성      | 설명                    |
> |---------|-----------------------|
> | `단일` 속성 | ID, 이름 등 분해 불가        |
> | `복합` 속성 | 주소 = 도, 시, 구, 동으로 분해  |
> | `다중` 속성 | 엔터티로 분해되는 것. (상품 리스트) |

<br>

__3 ) Attribute 생성 특성__

> 기설파 : 기설파 비프 데모 다속
> 
> | 속성      | 설명                                    |
> |---------|---------------------------------------|
> | `기본` 속성 | `비`즈니스 `프`로세스에서 도출 (ID, 이름, 계좌번호)     |
> | `설계` 속성 | `데`이터 `모`델링 과정에서 발생, 유일한 값 부여 (상품 코드) |
> | `파생` 속성 | `다른 속성`으로부터 생성 (합계, 평균)               |

<br>

__4 ) Attribute 구성 방식에 따른 분류__

> 기외일
> - 기본키 속성
> - 외래키 속성
> - 일반 속성

<br>

__5 ) 도메인(Domain)__

속성이 가질 수 있는 값의 범위 : 성별 (여, 남, 기타)

#### 7. Entity Identifier

__1 ) 주식별자(PK)__

> 최대유불
> 
> | 주식별자의 속성 | 설명                 |
> |----------|--------------------|
> | `최소`성    | 최소성을 만족하는 키        |
> | `대표`성    | 엔터티를 대표            |
> | `유일`성    | 엔터티의 인스턴스를 유일하게 식별 |
> | `불변`성    | 자주 변경되지 않아야 한다     |

<br>

__키의 종류__

> 후기대슈 : 영화 관람 후기좀 대슈
> 
> | 키의 종류                          | 설명                     |
> |--------------------------------|------------------------|
> | `후보키`(`Candidate` key)         | `유일성`, `최소성` 만족        |
> | `기본키`(`Primary` key) (주식별자)    | 후보키 중 `대표`, `Not null` |
> | `대체키`(`Alternate` key) (보조식별자) | 후보키 중 기본키를 제외한 나머지     |
> | `슈퍼키`(`Super` key)             | `유일성` 만족               |

`후보키(기본키 + 대체키)`는 `유일성`, `최소성`을 만족  
`슈퍼키`는 `유일성`만 만족한다.

<br>

__2 ) 외래키(Foreign key)__

`참조 무결성(Referential Integrity)`을 위해 사용

<br>

__3 ) 특성에 따른 식별자의 구분__

- `대표성`

| 식별자   | 설명  |
|-------|-----|
| 주식별자  | PK  |
| 보조식별자 | 대체키 |

- `생성 여부` : 내부 외부 식별자화

| 식별자      | 설명                                |
|----------|-----------------------------------|
| `내부` 식별자 | 엔터티 내부에서 스스로 생성                   |
| `외부` 식별자 | 다른 엔터티와 관계로 인해 생성 (계좌 엔터티의 회원 ID) |

- `속성의 수` : 단일 복합 식별자

| 식별자      | 설명                                    |
|----------|---------------------------------------|
| `단일` 식별자 | 하나의 속성                                |
| `복합` 식별자 | 두 개 이상의 속성 (여러 컬럼을 동시에 unique, pk 설정) |

- `대체 여부` : 본질 인조 식별자

| 식별자      | 설명                                        |
|----------|-------------------------------------------|
| `본질` 식별자 | 비즈니스 프로세스에서 생성(주민번호, 회원 ID)               |
| `인조` 식별자 | 인위로 생성(`sequence number`, auto increment) |

---

### 3. 데이터 모델링 - 정규화/반정규화 👩‍💻

#### 1. Normalization

__1 ) 정규화__

- `일관성`
- 데이터 `중복 최소`화
- 데이터 `유연성 최대`화
- `모델 독립성 확보`

직원과 부서를 하나의 테이블에 넣으면 부서를 추가하기 위해 사원 컬럼을 임의의 값으로 채워 넣는 `Anomaly(이상현상)`가 발생한다.  
=> 정규화로 해결

<br>

__2 ) 정규화 절차__

> 123B45 기분이 대기다조
>
> | 정규화   | 설명                                       |
> |-------|------------------------------------------|
> | 제1정규화 | `기본키 설정`                                 |
> | 제2정규화 | `부분 함수 종속성 제거` : `기본키가 2개 이상의 속성일 경우 분해` |
> | 제3정규화 | `이행 함수 종속성 제거` : 기본키를 제외한 컬럼의 종속성을 제거    |
> | BCNF  | `대체키`가 `기본키`를 종속시키면 분해                   |
> | 제4정규화 | `다중값 종속성 제거` : 여러 컬럼들이 하나의 컬럼에 종속할 경우 분해 |
> | 제5정규화 | `조인 종속성 분해` : 조인에 의해 종속성 발생시 분해          |

이 중 `123 정규화`, `BCNF` 는 `함수적 종속성(Functional Dependency)`을 근거로 한다.

> - 정규화 장점 : 데이터 중복 제거, 모델 유연성 최대
> - 정규화 단점 : Join 으로 인한 성능 저하 => Index, Optimizer, 반정규화(중복 허용)으로 해소한다.

#### 2. De-Normalization

__1 ) 반정규화__

- 성능 향상을 위해 `데이터 중복 허용`(`Join 을 줄임`, `무결성을 깨뜨릴 위험`이 존재)
- SELECT 속도가 향상(모델 유연성이 낮아짐)

> 반정규화를 수행하는 경우
> 
> - `정규화`로 수행 속도가 `느려짐`
> - `다량의 범위`를 `자주` 처리
> - `특정 범위` 데이터만 `자주` 처리
> - `요약/집게` 정보를 `자주` 요구

| 속도 향상 기법    | 설명                                                                       |
|-------------|--------------------------------------------------------------------------|
| 계산된 컬럼 추가   | 배치 프로그램으로 미리 계산하고 그 결과를 특정 컬럼에 추가                                        |
| 수직 파티셔닝     | 컬럼을 분할해 2개 이상의 테이블로 나눈다                                                  |
| 수평 파티셔닝(샤딩) | 값을 기준으로 테이블을 분할                                                          |
| 테이블 병합      | 1:1 관계의 테이블 병합, 1:N 관계의 테이블 병합(이 경우 데이터 중복 발생), Super type & Sub type 병합 |

> 실제로 빅데이터를 이용해 BI(Business Intelligence)를 하고자 하는 경우 ETL(Extract, Transform, Load)을 통해  
> 분산된 데이터를 모아 `Data Warehouse`를 구축하는 일을 하게 된다. 즉, 데이터를 꺼내기 쉽고, 빠르게 꺼낼 수 있도록 
> 반정규화를 처리하는 것이다.

<br>

__2 ) 반정규화 절차__

> 대조검 다반
> 
> | 절차               | 설명                                              |
> |------------------|-------------------------------------------------|
> | `대상` `조사` 및 `검토` | 반정규화 대상을 조사                                     |
> | `다른 방법` 검토       | `클러스터링`, `뷰`, `인덱스 튜닝`, `응용 프로그램`, `파티셔닝` 등을 검토 |
> | `반정규화` 수행        |                                                 |

`Clustering` : 인덱스 정보를 저장할 때 물리적으로 정렬해서 저장하는 것을 클러스터링 인덱스라 한다.

<br>

__3 ) 반정규화 기법__

- `Partitioning` : 논리적으로는 하나의 테이블이지만 여러 테이블에 분산되어 기록

| 파티션 종류              | 설명                  | 예시                       |
|---------------------|---------------------|--------------------------|
| Range Partition     | 범위를 기준으로 파티션        | 0 ~ 10, 11 ~ 20, 21 ~ 30 |
| List Partition      | 특정한 값을 기준으로 파티션     | VVIP, VIP, NORMAL        |
| Hash Partition      | 해시 함수를 적용해 파티션      | DBMS가 알아서 분류             |
| Composite Partition | 범위 & 해시 함수를 적용해 파티션 |                          |

> - 엑세스 범위가 줄어 SELECT 성능 향상
> - 데이터 분할로 I/O 성능 향상
> - 파티션 독립적 백업 및 복구 가능

<br>

- `Partition Index`

| 파티션 인덱스 종류         | 설명                   |
|--------------------|----------------------|
| Global Index       | 여러 파티션에서 하나의 인덱스를 사용 |
| Local Index        | 파티션 별로 각자의 인덱스를 사용   |
| Prefixed Index     | 파티션 키 = 인덱스 키        |
| Non Prefixed Index | 파티션 키 ≠ 인덱스 키        |

> 오라클은 Global Non-Prefixed 를 지원하지 않는다.

<br>

- `Super type`, `Sub type`

> - Super type : 고객 엔터티
> - Sub type : 개인 고객 엔터티, 기업 고객 엔터티

- `Super type` ↔ `Sub type` 변환

| 변환 방법                         | 설명                                   |
|-------------------------------|--------------------------------------|
| OneToOne type (1:1 type)      | 슈퍼 타입, 서브 타입 개별 테이블로, 조인 발생, 관리 어렵   |
| Plus type (super + sub type)  | 슈퍼 타입, 서브 타입 테이블로, 조인 발생, 관리 어렵      |
| Single type (All in One type) | 하나의 테이블로, 조인 성능 좋고 관리 편함. 입출력 성능 나쁨. |

#### 3. Distributed Database

__1 ) 분산 데이터베이스__

- 중앙 집중형 데이터베이스 : 한 대의 물리적 시스템.
- 분산 데이터베이스 : 물리적으로 떨어짐. 네트워크로 연결.

<br>

__2 ) 분산 데이터베이스의 투명성__

`알 필요 없다`, `몰라도 된다`, `문제 없다` 로 치환하면 맞아 떨어진다.

> 분위지 중장병 투명성
> 
> | 투명성 종류 | 설명 |
> | --- | --- |
> | `분할` 투명성 | 고객은 `분할` 저장을 `알 필요 없다` |
> | `위치` 투명성 | `저장 장소` 명시할 `필요 없다` |
> | `지역` 사상 투명성 | `지역` 시스템과 `무관한 이름`을 사용한다 |
> | `중복` 투명성 | 데이터베이스 객체가 여러 시스템에 `중복`되어도 고객의 데이터 `일관성은 유지` |
> | `장애` 투명성 | `통신망 이상` 발생, 데이터 `무결성 보장` |
> | `병행` 투명성 | 여러 앱 `동시 트랜잭션` 수행, 결과 `문제 없다` |

<br>

__3 ) 분산 데이터베이스 설계__

- `상향식` : `지역` 스키마 -> `전역` 스키마
- `하향식` : `전역` 스키마 -> `지역` 스키마

<br>

__4 ) 장단점__

- 장점 : 신가빠확
        `신뢰성`, `가용성`, 병렬 처리 `빠른` 응답, 용량 `확장`
- 단점 : 관보무설
        `관리` 통제 어려움, `보안` 관리 어려움, `무결성` 관리 어려움, `설계`가 복잡

---

### 1.  👩‍💻

---

### 1.  👩‍💻

---

### 1.  👩‍💻

---

### 1.  👩‍💻

---

### 1.  👩‍💻

---


### 1.  👩‍💻

---

### 1.  👩‍💻

---

### 1.  👩‍💻

---


<br><br>

---
Reference

1. 임호진. SQL 개발자. 영진닷컴, 2021.
2. "ERD Editor." Egovframe. Apr. 04, 2015, [ERD Editor](https://www.egovframe.go.kr/wiki/doku.php?id=egovframework:dev:imp:editor:erd_editor).
3. "ERD." 해시넷. Jun. 02, 2022, [ERD](http://wiki.hash.kr/index.php/ERD#cite_note-ERD04-3).

