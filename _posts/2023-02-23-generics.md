---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics 👩‍💻

#### 1. Generics

`Generic code`는 정의한 요구사항에 맞는 모든 타입에서 동작할 수 있는 유연하고 재사용 가능한 함수와 타입을 작성할 수 있다.

*Generic* 은 Swift 의 강력한 특징 중 하나로 대부분의 `Swift stardard library`는 *Generic code* 로 작성되었다. 
예를 들어 Swift 의 *Array* 와 *Dictionary* Types 는 `Generic Collections`다. Array 를 이용해 우리는 
Int 를 저장할 수도 있고, String 을 저장할 수도 있고, Swift 에서 생성될 수 있는 모든 Type 을 저장할 수 있다.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

위 `swap(_:_:)` 함수는 `(Int, Int) -> Void` Type 의 `Standard Function`으로 `Nongeneric Function`으로 
두 값을 바꾸는 일을 수행한다.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

이 함수는 오직 `Int`일 때만 동작한다. 만약, `Double` 또는 `String`일 때 동일한 동작이 필요하다면 우리는 다음과 같이 함수를 추가해야한다.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3개의 함수는 모두 동일한 로직을 수행한다. 오직 다른 것은 `Type` 뿐이다. 만약 또 다른 Types 에 대해 값을 바꾸는 로직이 필요하다면, 
Types 의 수만큼 함수를 게속 만들어야한다. 😱😱😱

---

### 2. Generic Functions 👩‍💻

#### 1. Generic Functions

*Generic Functions* 를 사용하면 위 문제를 `모든 타입에서 동작(work with any type)`할 수 있도록 해 문제를 해결할 수 있다.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* 를 이용해 `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types 를 갖는 3개의 `swap(_:_:)` 함수를 하나로 만들었다. 만약, 다른 Types 의 버전이 또 존재했다면, 이 *Generic Function* 은 
수없이 많은 함수의 *Overloading* 을 처리했을 것이다.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* 와 *Nongeneric Function* 를 비교해보자.

- swap<T> : Swift 에게 이 `swap` 함수 정의에서 `T`가 `Placeholder Type`이라고 알린다. 이 `<T>`가 바로 다음에 설명하게 될 
            [Type Parameters](#h-3-type-parameters-t) 다.
- (_ a: inout T, _ b: inout T) : 함수의 Parameters 가 `T`라는 `Placeholder Type`으로 정의된다.

이 `T`라는 Type 은 Swift 내에 존재하지 않는다. 이것은 미리 정의되지 않은 함수가 호출될 때 `Type Inference`에 의해 Type 이 
정의됨을 의미한다.

따라서 *Generic Function* `swap(_:_:)`은 위에서 정의한 Int, Double, String 3가지 타입에 대해 모두 동작한다.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> 위에서 정의한 Generic Function `swap(_:_:)`은 사실 `Swift stardard library`에 이미 built-in 된 함수로 
> 별도의 구현 없이 바로 사용할 수 있다.

#### 3. Type Parameters `<T>`

위 `swap(_:_:)`에서 *Placeholder Type* `T`는 `Type Parameters`의 한가지 예시를 보여준다. *Type Parameters* 는 함수의 
이름 뒤에 위치하며 `<T>`와 같이 *angle brackets* `< >`로 감싸 정의한다.

*Type Parameters* 를 정의하면, 함수의 정의에서 *Parameters* 에 이것을 *Placeholder Type* 으로 사용할 수 있게 한다. 
바로 `(_ a: inout T, _ b: inout T)` 부분이다. `Type Parameter <T> 를 정의`했기 때문에 함수 정의에서 *Parameters* 
`a`, `b`에 `Type Parameter T 를 Placeholder Type 으로 사용`할 수 있는 것이다.

#### 4. Naming Type Parameters

위에서는 Type Parameters 의 이름으로 `T`를 사용했지만 이것은 반드시 `T`를 쓰도록 정해진 것은 아니다. 다만 의도를 내치비기 위해 보통 
다음과 같이 정의한다.

- 구분되는 관계가 있는 경우 : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`와 같이 
                        이름을 통해 관계를 유추할 수 있도록 사용한다.
- 별다른 관계가 없는 경우 : 정해진 규칙은 없지만 전통적으로 `T`, `U`, `V`와 같은 단일 대문자를 사용하는 것이 일반적이다.

> **Type Parameters** 를 정의할 때는 이것이 `Placeholder Type 으로 사용`된다는 것을 나타내기 위해 `Upper Camel Case`를 
> 사용한다. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types 👩‍💻

#### 1. Generic types

Swift 의 *Array* 와 *Dictionary* Types 는 `Generic Collections`라고 설명했다. 이렇듯 Swift 는 `Generic Functions` 
외에도 `Generic Types`를 정의할 수 있으며, *Array*, *Dictionary* 와 유사하게 모든 타입에서 동작할 수 있는 *Custom Classes, 
Structures, Enumerations* 다.

<br>

`Stack` 은 `Pushing`과 `Popping`을 통해 동작하며 `LIFO` 로 동작한다. 이 *Stack* 을 이용해 *Generic Types* 를 설명한다. 

> Stack 개념은  **Navigation Hierarchy** 에서 **View Controllers** 를 모델링 하는 `UINavigationController` Class 에 
> 의해 사용된다. **UINavigationController** Class 에서 Navigation Stack 에 **View Controller** 를 추가하거나 제거하기 
> 위해 `pushViewController(_:animated:)` 메서드와 `popViewControllerAnimated(_:)` 메서드를 호출하며, 이것은 Stack 구조로 
> `LIFO` 접근 방식을 사용한다.

![Stack 1](/assets/images/posts/2023-02-23-generics/stackPushPop~dark@2x.png){: width="800"}

이것을 코드로 표현해보면 다음과 같다.

```swift
struct Stack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack) // IntStack(items: [3, 2, 5])

intStack.push(8)
print(intStack) // IntStack(items: [3, 2, 5, 8])

intStack.pop()
print(intStack) // IntStack(items: [3, 2, 5])
```

<br>

만약 String 을 저장하는 *Stack* 을 만들려면 또 다른 Stack 을 추가해야한다. 게다가 *Overloading* 이 되는 메서드와 달리 매번 
생성하는 Stack Structure 의 이름도 다르게 해줘야한다.

우리는 이 문제를 `Generic Types 를 이용해 해결`할 수 있다.

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack)             // Stack<Int>(items: [3, 2, 5])

intStack.push(8)
print(intStack)             // Stack<Int>(items: [3, 2, 5, 8])

intStack.pop()
print(intStack)             // Stack<Int>(items: [3, 2, 5])
```

<br>
위 Stack 을 이번엔 String 을 저장하는데 사용해보자.

![Stack 2](/assets/images/posts/2023-02-23-generics/stackPushedFourStrings~dark@2x.png){: width="800"}

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

![Stack 3](/assets/images/posts/2023-02-23-generics/stackPoppedOneString~dark@2x.png){: width="480"}

```swift
print(stringStack.pop())    // cuatro
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres"])
```

#### 2 Extending a Generic Type

*Generic Type* 을 확장할 때는 다른 Types 를 확장할 때와 마찬가지로 정의할 때 *Type* 을 정의하지 않는다. 따라서 `Extension`은 
별도의 정의 없이 `Original Type Parameters`를 그대로 사용한다.

위 Stack 을 확장해 *Element* 를 제거하지 않고 가장 마지막 *Element* 를 반환하는 *Read-Only Computed Properties* 를 
추가해보자.

```swift
extension Stack {
    var topItem: Element? {
        items.last
    }
}
```

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])

if let topItem = stringStack.topItem {
    print(topItem)          // cuatro
}
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

---

### 4. Type Constraints 👩‍💻

#### 1. Type Constraints

위에서 정의한 [`swap(_:_:)`](#h-1-generic-functions) 함수와 [Stack](#h-1-generic-types) 은 모든 타입에서 동작한다. 
하지만 때로는 Generic 으로 사용할 수 있는 Types 에 `type constraints`를 강제하는 것이 유용할 수 있다. *Type constraints* 는 
`Type Parameters 가 특정 Class 를 상속하거나 Protocol 을 준수해야함`을 지정한다.

예를 들어 *Dictionary* Type 은 `Key 의 Type 은 Hashable 을 준수`하는 것으로 제한한다. 그래야만 특정 키에 값이 이미 포함되어 있는지 확인 
후 삽입할지 대체할지 판단할 수 있기 때문이다(Swift 의 모든 기본 타입 *String, Int, Double, Bool* 은 모두 *Hashable* 을 준수한다).

따라서 사용자는 사용자 정의 Generic Types 를 정의할 때 *constraints* 를 제공하는 것은 *Generic Programming* 을 더욱 강력하게 한다. 
예를 들어 Hashable 과 같은 추상적 개념을 사용하는 것은 구체적인 유형이 아닌 개념적 특성에서 Type 의 특성을 강화한다.

#### 2. Type Constraints Syntax

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

위 함수는 2개의 `Type Parameters`를 갖는다. `T 는 SomeClass 의 Subclass`이어야하고, `U 는 SomeProtocol 을 준수`해야한다는 
*constraints* 를 추가한다.

#### 3. Type Constraints in Action

__1 ) Nongeneric Function__

다음은 찾아야 할 `String`과 찾아야 하는 대상 `[String]`을 받는 `findIndex(ofString:in:)`이라는 *Nongeneric Function* 이다.

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]

if let dogIndex = findIndex(ofString: "dog", in: strings) {
    print("The index of dog is \(dogIndex).")
} else {
    print("The dog is not in the array.")
}

if let bearIndex = findIndex(ofString: "bear", in: strings) {
    print("The index of bear is \(bearIndex).")
} else {
    print("The bear is not in the array.")
}
```

```console
The index of dog is 1.
The bear is not in the array.
```

<br>

__2 ) Generic Function__

이제 이 함수를 *Generic Function* 으로 바꿔보자.

![Generic Function Define Error](/assets/images/posts/2023-02-23-generics/generic-function-define-error.png){: width="800"}

예상과 달리 *compile-error* 가 발생한다. `==` operator 를 사용하기 위해서는 [Equatable](l#h-1-synthesized-implementation-of-equatable) 
을 만족해야 하기 때문이다.

따라서 우리는 ***Type Parameter `<T>`에 Equatable Protocol 을 준수(confirm)하는 것으로 `constraints`를 추가***해 
문제를 해결할 수 있다.

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
if let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) {
    print("The index of 9.3 is \(doubleIndex).")
} else {
    print("The 9.3 is not in the array.")
}

if let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"]) {
    print("The index of Andrea is \(stringIndex).")
} else {
    print("Andrea is not in the array.")
}
```

```console
The 9.3 is not in the array.
The index of Andrea is 2.
```

---

### 5. Associated Types 👩‍💻

#### 1. Associated Types

#### 2. Associated Types in Action

#### 3. Extending an Existing Type to Specify an Associated Type

#### 4. Adding Constraints to an Associated Type

#### 5. Using a Protocol in Its Associated Type’s Constraints

---

### 6. Generic Where Clauses 👩‍💻

#### 1. Generic Where Clauses

#### 2. Extensions with a Generic Where Clause

#### 3. Contextual Where Clauses

#### 4. Associated Types with a Generic Where Clause

#### 5. Generic Subscripts



<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics)
