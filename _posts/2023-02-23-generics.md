---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics 👩‍💻

#### 1. Generics

`Generic code`는 정의한 요구사항에 맞는 모든 타입에서 동작할 수 있는 유연하고 재사용 가능한 함수와 타입을 작성할 수 있다.

*Generic* 은 Swift 의 강력한 특징 중 하나로 대부분의 `Swift stardard library`는 *Generic code* 로 작성되었다. 
예를 들어 Swift 의 *Array* 와 *Dictionary* Types 는 `Generic Collections`다. Array 를 이용해 우리는 
Int 를 저장할 수도 있고, String 을 저장할 수도 있고, Swift 에서 생성될 수 있는 모든 Type 을 저장할 수 있다.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

위 `swap(_:_:)` 함수는 `(Int, Int) -> Void` Type 의 `Standard Function`으로 `Nongeneric Function`으로 
두 값을 바꾸는 일을 수행한다.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

이 함수는 오직 `Int`일 때만 동작한다. 만약, `Double` 또는 `String`일 때 동일한 동작이 필요하다면 우리는 다음과 같이 함수를 추가해야한다.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3개의 함수는 모두 동일한 로직을 수행한다. 오직 다른 것은 `Type` 뿐이다. 만약 또 다른 Types 에 대해 값을 바꾸는 로직이 필요하다면, 
Types 의 수만큼 함수를 게속 만들어야한다. 😱😱😱

---

### 2. Generic Functions 👩‍💻

#### 1. Generic Functions

*Generic Functions* 를 사용하면 위 문제를 `모든 타입에서 동작(work with any type)`할 수 있도록 해 문제를 해결할 수 있다.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* 를 이용해 `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types 를 갖는 3개의 `swap(_:_:)` 함수를 하나로 만들었다. 만약, 다른 Types 의 버전이 또 존재했다면, 이 *Generic Function* 은 
수없이 많은 함수의 *Overloading* 을 처리했을 것이다.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* 와 *Nongeneric Function* 를 비교해보자.

- swap<T> : Swift 에게 이 `swap` 함수 정의에서 `T`가 `Placeholder Type`이라고 알린다. 이 `<T>`가 바로 다음에 설명하게 될 
            [Type Parameters](#h-3-type-parameters-t) 다.
- (_ a: inout T, _ b: inout T) : 함수의 Parameters 가 `T`라는 `Placeholder Type`으로 정의된다.

이 `T`라는 Type 은 Swift 내에 존재하지 않는다. 이것은 미리 정의되지 않은 함수가 호출될 때 `Type Inference`에 의해 Type 이 
정의됨을 의미한다.

따라서 *Generic Function* `swap(_:_:)`은 위에서 정의한 Int, Double, String 3가지 타입에 대해 모두 동작한다.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> 위에서 정의한 Generic Function `swap(_:_:)`은 사실 `Swift stardard library`에 이미 built-in 된 함수로 
> 별도의 구현 없이 바로 사용할 수 있다.

#### 3. Type Parameters `<T>`

위 `swap(_:_:)`에서 *Placeholder Type* `T`는 `Type Parameters`의 한가지 예시를 보여준다. *Type Parameters* 는 함수의 
이름 뒤에 위치하며 `<T>`와 같이 *angle brackets* `< >`로 감싸 정의한다.

*Type Parameters* 를 정의하면, 함수의 정의에서 *Parameters* 에 이것을 *Placeholder Type* 으로 사용할 수 있게 한다. 
바로 `(_ a: inout T, _ b: inout T)` 부분이다. `Type Parameter <T> 를 정의`했기 때문에 함수 정의에서 *Parameters* 
`a`, `b`에 `Type Parameter T 를 Placeholder Type 으로 사용`할 수 있는 것이다.

#### 4. Naming Type Parameters

위에서는 Type Parameters 의 이름으로 `T`를 사용했지만 이것은 반드시 `T`를 쓰도록 정해진 것은 아니다. 다만 의도를 내치비기 위해 보통 
다음과 같이 정의한다.

- 구분되는 관계가 있는 경우 : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`와 같이 
                        이름을 통해 관계를 유추할 수 있도록 사용한다.
- 별다른 관계가 없는 경우 : 정해진 규칙은 없지만 전통적으로 `T`, `U`, `V`와 같은 단일 대문자를 사용하는 것이 일반적이다.

> **Type Parameters** 를 정의할 때는 이것이 `Placeholder Type 으로 사용`된다는 것을 나타내기 위해 `Upper Camel Case`를 
> 사용한다. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types 👩‍💻

#### 1. Generic types

#### 2 Extending a Generic Type

---

### 3. Type Constraints 👩‍💻

#### 1. Type Constraints

#### 2. Type Constraints Syntax

#### 3. Type Constraints in Action

---

### 4. Associated Types 👩‍💻

#### 1. Associated Types

#### 2. Associated Types in Action

#### 3. Extending an Existing Type to Specify an Associated Type

#### 4. Adding Constraints to an Associated Type

#### 5. Using a Protocol in Its Associated Type’s Constraints

---

### 5. Generic Where Clauses 👩‍💻

#### 1. Generic Where Clauses

#### 2. Extensions with a Generic Where Clause

#### 3. Contextual Where Clauses

#### 4. Associated Types with a Generic Where Clause

#### 5. Generic Subscripts



<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics)
