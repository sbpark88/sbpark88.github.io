---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics ğŸ‘©â€ğŸ’»

#### 1. Generics

`Generic code`ëŠ” ì •ì˜í•œ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” ìœ ì—°í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ì™€ íƒ€ì…ì„ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

*Generic* ì€ Swift ì˜ ê°•ë ¥í•œ íŠ¹ì§• ì¤‘ í•˜ë‚˜ë¡œ ëŒ€ë¶€ë¶„ì˜ `Swift stardard library`ëŠ” *Generic code* ë¡œ ì‘ì„±ë˜ì—ˆë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë‹¤. Array ë¥¼ ì´ìš©í•´ ìš°ë¦¬ëŠ” 
Int ë¥¼ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , String ì„ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , Swift ì—ì„œ ìƒì„±ë  ìˆ˜ ìˆëŠ” ëª¨ë“  Type ì„ ì €ì¥í•  ìˆ˜ ìˆë‹¤.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

ìœ„ `swap(_:_:)` í•¨ìˆ˜ëŠ” `(Int, Int) -> Void` Type ì˜ `Standard Function`ìœ¼ë¡œ `Nongeneric Function`ìœ¼ë¡œ 
ë‘ ê°’ì„ ë°”ê¾¸ëŠ” ì¼ì„ ìˆ˜í–‰í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

ì´ í•¨ìˆ˜ëŠ” ì˜¤ì§ `Int`ì¼ ë•Œë§Œ ë™ì‘í•œë‹¤. ë§Œì•½, `Double` ë˜ëŠ” `String`ì¼ ë•Œ ë™ì¼í•œ ë™ì‘ì´ í•„ìš”í•˜ë‹¤ë©´ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•´ì•¼í•œë‹¤.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3ê°œì˜ í•¨ìˆ˜ëŠ” ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ ìˆ˜í–‰í•œë‹¤. ì˜¤ì§ ë‹¤ë¥¸ ê²ƒì€ `Type` ë¿ì´ë‹¤. ë§Œì•½ ë˜ ë‹¤ë¥¸ Types ì— ëŒ€í•´ ê°’ì„ ë°”ê¾¸ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë‹¤ë©´, 
Types ì˜ ìˆ˜ë§Œí¼ í•¨ìˆ˜ë¥¼ ê²Œì† ë§Œë“¤ì–´ì•¼í•œë‹¤. ğŸ˜±ğŸ˜±ğŸ˜±

---

### 2. Generic Functions ğŸ‘©â€ğŸ’»

#### 1. Generic Functions

*Generic Functions* ë¥¼ ì‚¬ìš©í•˜ë©´ ìœ„ ë¬¸ì œë¥¼ `ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘(work with any type)`í•  ìˆ˜ ìˆë„ë¡ í•´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* ë¥¼ ì´ìš©í•´ `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types ë¥¼ ê°–ëŠ” 3ê°œì˜ `swap(_:_:)` í•¨ìˆ˜ë¥¼ í•˜ë‚˜ë¡œ ë§Œë“¤ì—ˆë‹¤. ë§Œì•½, ë‹¤ë¥¸ Types ì˜ ë²„ì „ì´ ë˜ ì¡´ì¬í–ˆë‹¤ë©´, ì´ *Generic Function* ì€ 
ìˆ˜ì—†ì´ ë§ì€ í•¨ìˆ˜ì˜ *Overloading* ì„ ì²˜ë¦¬í–ˆì„ ê²ƒì´ë‹¤.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* ì™€ *Nongeneric Function* ë¥¼ ë¹„êµí•´ë³´ì.

- swap<T> : Swift ì—ê²Œ ì´ `swap` í•¨ìˆ˜ ì •ì˜ì—ì„œ `T`ê°€ `Placeholder Type`ì´ë¼ê³  ì•Œë¦°ë‹¤. ì´ `<T>`ê°€ ë°”ë¡œ ë‹¤ìŒì— ì„¤ëª…í•˜ê²Œ ë  
            [Type Parameters](#h-3-type-parameters-t) ë‹¤.
- (_ a: inout T, _ b: inout T) : í•¨ìˆ˜ì˜ Parameters ê°€ `T`ë¼ëŠ” `Placeholder Type`ìœ¼ë¡œ ì •ì˜ëœë‹¤.

ì´ `T`ë¼ëŠ” Type ì€ Swift ë‚´ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ê²ƒì€ ë¯¸ë¦¬ ì •ì˜ë˜ì§€ ì•Šì€ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ `Type Inference`ì— ì˜í•´ Type ì´ 
ì •ì˜ë¨ì„ ì˜ë¯¸í•œë‹¤.

ë”°ë¼ì„œ *Generic Function* `swap(_:_:)`ì€ ìœ„ì—ì„œ ì •ì˜í•œ Int, Double, String 3ê°€ì§€ íƒ€ì…ì— ëŒ€í•´ ëª¨ë‘ ë™ì‘í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> ìœ„ì—ì„œ ì •ì˜í•œ Generic Function `swap(_:_:)`ì€ ì‚¬ì‹¤ `Swift stardard library`ì— ì´ë¯¸ built-in ëœ í•¨ìˆ˜ë¡œ 
> ë³„ë„ì˜ êµ¬í˜„ ì—†ì´ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

#### 3. Type Parameters `<T>`

ìœ„ `swap(_:_:)`ì—ì„œ *Placeholder Type* `T`ëŠ” `Type Parameters`ì˜ í•œê°€ì§€ ì˜ˆì‹œë¥¼ ë³´ì—¬ì¤€ë‹¤. *Type Parameters* ëŠ” í•¨ìˆ˜ì˜ 
ì´ë¦„ ë’¤ì— ìœ„ì¹˜í•˜ë©° `<T>`ì™€ ê°™ì´ *angle brackets* `< >`ë¡œ ê°ì‹¸ ì •ì˜í•œë‹¤.

*Type Parameters* ë¥¼ ì •ì˜í•˜ë©´, í•¨ìˆ˜ì˜ ì •ì˜ì—ì„œ *Parameters* ì— ì´ê²ƒì„ *Placeholder Type* ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤. 
ë°”ë¡œ `(_ a: inout T, _ b: inout T)` ë¶€ë¶„ì´ë‹¤. `Type Parameter <T> ë¥¼ ì •ì˜`í–ˆê¸° ë•Œë¬¸ì— í•¨ìˆ˜ ì •ì˜ì—ì„œ *Parameters* 
`a`, `b`ì— `Type Parameter T ë¥¼ Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`í•  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.

#### 4. Naming Type Parameters

ìœ„ì—ì„œëŠ” Type Parameters ì˜ ì´ë¦„ìœ¼ë¡œ `T`ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì´ê²ƒì€ ë°˜ë“œì‹œ `T`ë¥¼ ì“°ë„ë¡ ì •í•´ì§„ ê²ƒì€ ì•„ë‹ˆë‹¤. ë‹¤ë§Œ ì˜ë„ë¥¼ ë‚´ì¹˜ë¹„ê¸° ìœ„í•´ ë³´í†µ 
ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.

- êµ¬ë¶„ë˜ëŠ” ê´€ê³„ê°€ ìˆëŠ” ê²½ìš° : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`ì™€ ê°™ì´ 
                        ì´ë¦„ì„ í†µí•´ ê´€ê³„ë¥¼ ìœ ì¶”í•  ìˆ˜ ìˆë„ë¡ ì‚¬ìš©í•œë‹¤.
- ë³„ë‹¤ë¥¸ ê´€ê³„ê°€ ì—†ëŠ” ê²½ìš° : ì •í•´ì§„ ê·œì¹™ì€ ì—†ì§€ë§Œ ì „í†µì ìœ¼ë¡œ `T`, `U`, `V`ì™€ ê°™ì€ ë‹¨ì¼ ëŒ€ë¬¸ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.

> **Type Parameters** ë¥¼ ì •ì˜í•  ë•ŒëŠ” ì´ê²ƒì´ `Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`ëœë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ `Upper Camel Case`ë¥¼ 
> ì‚¬ìš©í•œë‹¤. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types ğŸ‘©â€ğŸ’»

#### 1. Generic types

Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë¼ê³  ì„¤ëª…í–ˆë‹¤. ì´ë ‡ë“¯ Swift ëŠ” `Generic Functions` 
ì™¸ì—ë„ `Generic Types`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°, *Array*, *Dictionary* ì™€ ìœ ì‚¬í•˜ê²Œ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” *Custom Classes, 
Structures, Enumerations* ë‹¤.

<br>

`Stack` ì€ `Pushing`ê³¼ `Popping`ì„ í†µí•´ ë™ì‘í•˜ë©° `LIFO` ë¡œ ë™ì‘í•œë‹¤. ì´ *Stack* ì„ ì´ìš©í•´ *Generic Types* ë¥¼ ì„¤ëª…í•œë‹¤. 

> Stack ê°œë…ì€  **Navigation Hierarchy** ì—ì„œ **View Controllers** ë¥¼ ëª¨ë¸ë§ í•˜ëŠ” `UINavigationController` Class ì— 
> ì˜í•´ ì‚¬ìš©ëœë‹¤. **UINavigationController** Class ì—ì„œ Navigation Stack ì— **View Controller** ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•˜ê¸° 
> ìœ„í•´ `pushViewController(_:animated:)` ë©”ì„œë“œì™€ `popViewControllerAnimated(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©°, ì´ê²ƒì€ Stack êµ¬ì¡°ë¡œ 
> `LIFO` ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤.

![Stack 1](/assets/images/posts/2023-02-23-generics/stackPushPop~dark@2x.png){: width="800"}

ì´ê²ƒì„ ì½”ë“œë¡œ í‘œí˜„í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
struct Stack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack) // IntStack(items: [3, 2, 5])

intStack.push(8)
print(intStack) // IntStack(items: [3, 2, 5, 8])

intStack.pop()
print(intStack) // IntStack(items: [3, 2, 5])
```

<br>

ë§Œì•½ String ì„ ì €ì¥í•˜ëŠ” *Stack* ì„ ë§Œë“¤ë ¤ë©´ ë˜ ë‹¤ë¥¸ Stack ì„ ì¶”ê°€í•´ì•¼í•œë‹¤. ê²Œë‹¤ê°€ *Overloading* ì´ ë˜ëŠ” ë©”ì„œë“œì™€ ë‹¬ë¦¬ ë§¤ë²ˆ 
ìƒì„±í•˜ëŠ” Stack Structure ì˜ ì´ë¦„ë„ ë‹¤ë¥´ê²Œ í•´ì¤˜ì•¼í•œë‹¤.

ìš°ë¦¬ëŠ” ì´ ë¬¸ì œë¥¼ `Generic Types ë¥¼ ì´ìš©í•´ í•´ê²°`í•  ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack)             // Stack<Int>(items: [3, 2, 5])

intStack.push(8)
print(intStack)             // Stack<Int>(items: [3, 2, 5, 8])

intStack.pop()
print(intStack)             // Stack<Int>(items: [3, 2, 5])
```

<br>
ìœ„ Stack ì„ ì´ë²ˆì—” String ì„ ì €ì¥í•˜ëŠ”ë° ì‚¬ìš©í•´ë³´ì.

![Stack 2](/assets/images/posts/2023-02-23-generics/stackPushedFourStrings~dark@2x.png){: width="800"}

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

![Stack 3](/assets/images/posts/2023-02-23-generics/stackPoppedOneString~dark@2x.png){: width="480"}

```swift
print(stringStack.pop())    // cuatro
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres"])
```

#### 2 Extending a Generic Type

*Generic Type* ì„ í™•ì¥í•  ë•ŒëŠ” ë‹¤ë¥¸ Types ë¥¼ í™•ì¥í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì •ì˜í•  ë•Œ *Type* ì„ ì •ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ `Extension`ì€ 
ë³„ë„ì˜ ì •ì˜ ì—†ì´ `Original Type Parameters`ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•œë‹¤.

ìœ„ Stack ì„ í™•ì¥í•´ *Element* ë¥¼ ì œê±°í•˜ì§€ ì•Šê³  ê°€ì¥ ë§ˆì§€ë§‰ *Element* ë¥¼ ë°˜í™˜í•˜ëŠ” *Read-Only Computed Properties* ë¥¼ 
ì¶”ê°€í•´ë³´ì.

```swift
extension Stack {
    var topItem: Element? {
        items.last
    }
}
```

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])

if let topItem = stringStack.topItem {
    print(topItem)          // cuatro
}
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

---

### 4. Type Constraints ğŸ‘©â€ğŸ’»

#### 1. Type Constraints

ìœ„ì—ì„œ ì •ì˜í•œ [`swap(_:_:)`](#h-1-generic-functions) í•¨ìˆ˜ì™€ [Stack](#h-1-generic-types) ì€ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•œë‹¤. 
í•˜ì§€ë§Œ ë•Œë¡œëŠ” Generic ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Types ì— `type constraints`ë¥¼ ê°•ì œí•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ìˆ˜ ìˆë‹¤. *Type constraints* ëŠ” 
`Type Parameters ê°€ íŠ¹ì • Class ë¥¼ ìƒì†í•˜ê±°ë‚˜ Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•¨`ì„ ì§€ì •í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ *Dictionary* Type ì€ `Key ì˜ Type ì€ Hashable ì„ ì¤€ìˆ˜`í•˜ëŠ” ê²ƒìœ¼ë¡œ ì œí•œí•œë‹¤. ê·¸ë˜ì•¼ë§Œ íŠ¹ì • í‚¤ì— ê°’ì´ ì´ë¯¸ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ 
í›„ ì‚½ì…í• ì§€ ëŒ€ì²´í• ì§€ íŒë‹¨í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤(Swift ì˜ ëª¨ë“  ê¸°ë³¸ íƒ€ì… *String, Int, Double, Bool* ì€ ëª¨ë‘ *Hashable* ì„ ì¤€ìˆ˜í•œë‹¤).

ë”°ë¼ì„œ ì‚¬ìš©ìëŠ” ì‚¬ìš©ì ì •ì˜ Generic Types ë¥¼ ì •ì˜í•  ë•Œ *constraints* ë¥¼ ì œê³µí•˜ëŠ” ê²ƒì€ *Generic Programming* ì„ ë”ìš± ê°•ë ¥í•˜ê²Œ í•œë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Hashable ê³¼ ê°™ì€ ì¶”ìƒì  ê°œë…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ êµ¬ì²´ì ì¸ ìœ í˜•ì´ ì•„ë‹Œ ê°œë…ì  íŠ¹ì„±ì—ì„œ Type ì˜ íŠ¹ì„±ì„ ê°•í™”í•œë‹¤.

#### 2. Type Constraints Syntax

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

ìœ„ í•¨ìˆ˜ëŠ” 2ê°œì˜ `Type Parameters`ë¥¼ ê°–ëŠ”ë‹¤. `T ëŠ” SomeClass ì˜ Subclass`ì´ì–´ì•¼í•˜ê³ , `U ëŠ” SomeProtocol ì„ ì¤€ìˆ˜`í•´ì•¼í•œë‹¤ëŠ” 
*constraints* ë¥¼ ì¶”ê°€í•œë‹¤.

#### 3. Type Constraints in Action

__1 ) Nongeneric Function__

ë‹¤ìŒì€ ì°¾ì•„ì•¼ í•  `String`ê³¼ ì°¾ì•„ì•¼ í•˜ëŠ” ëŒ€ìƒ `[String]`ì„ ë°›ëŠ” `findIndex(ofString:in:)`ì´ë¼ëŠ” *Nongeneric Function* ì´ë‹¤.

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]

if let dogIndex = findIndex(ofString: "dog", in: strings) {
    print("The index of dog is \(dogIndex).")
} else {
    print("The dog is not in the array.")
}

if let bearIndex = findIndex(ofString: "bear", in: strings) {
    print("The index of bear is \(bearIndex).")
} else {
    print("The bear is not in the array.")
}
```

```console
The index of dog is 1.
The bear is not in the array.
```

<br>

__2 ) Generic Function__

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ *Generic Function* ìœ¼ë¡œ ë°”ê¿”ë³´ì.

![Generic Function Define Error](/assets/images/posts/2023-02-23-generics/generic-function-define-error.png){: width="800"}

ì˜ˆìƒê³¼ ë‹¬ë¦¬ *compile-error* ê°€ ë°œìƒí•œë‹¤. `==` operator ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” [Equatable](l#h-1-synthesized-implementation-of-equatable) 
ì„ ë§Œì¡±í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ***Type Parameter `<T>`ì— Equatable Protocol ì„ ì¤€ìˆ˜(confirm)í•˜ëŠ” ê²ƒìœ¼ë¡œ `constraints`ë¥¼ ì¶”ê°€***í•´ 
ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
if let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) {
    print("The index of 9.3 is \(doubleIndex).")
} else {
    print("The 9.3 is not in the array.")
}

if let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"]) {
    print("The index of Andrea is \(stringIndex).")
} else {
    print("Andrea is not in the array.")
}
```

```console
The 9.3 is not in the array.
The index of Andrea is 2.
```

---

### 5. Associated Types ğŸ‘©â€ğŸ’»

#### 1. Associated Types

#### 2. Associated Types in Action

#### 3. Extending an Existing Type to Specify an Associated Type

#### 4. Adding Constraints to an Associated Type

#### 5. Using a Protocol in Its Associated Typeâ€™s Constraints

---

### 6. Generic Where Clauses ğŸ‘©â€ğŸ’»

#### 1. Generic Where Clauses

#### 2. Extensions with a Generic Where Clause

#### 3. Contextual Where Clauses

#### 4. Associated Types with a Generic Where Clause

#### 5. Generic Subscripts



<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics)
