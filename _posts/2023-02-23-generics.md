---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics ğŸ‘©â€ğŸ’»

#### 1. Generics

`Generic code`ëŠ” ì •ì˜í•œ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” ìœ ì—°í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ì™€ íƒ€ì…ì„ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

*Generic* ì€ Swift ì˜ ê°•ë ¥í•œ íŠ¹ì§• ì¤‘ í•˜ë‚˜ë¡œ ëŒ€ë¶€ë¶„ì˜ `Swift stardard library`ëŠ” *Generic code* ë¡œ ì‘ì„±ë˜ì—ˆë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë‹¤. Array ë¥¼ ì´ìš©í•´ ìš°ë¦¬ëŠ” 
Int ë¥¼ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , String ì„ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , Swift ì—ì„œ ìƒì„±ë  ìˆ˜ ìˆëŠ” ëª¨ë“  Type ì„ ì €ì¥í•  ìˆ˜ ìˆë‹¤.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

ìœ„ `swap(_:_:)` í•¨ìˆ˜ëŠ” `(Int, Int) -> Void` Type ì˜ `Standard Function`ìœ¼ë¡œ `Nongeneric Function`ìœ¼ë¡œ 
ë‘ ê°’ì„ ë°”ê¾¸ëŠ” ì¼ì„ ìˆ˜í–‰í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

ì´ í•¨ìˆ˜ëŠ” ì˜¤ì§ `Int`ì¼ ë•Œë§Œ ë™ì‘í•œë‹¤. ë§Œì•½, `Double` ë˜ëŠ” `String`ì¼ ë•Œ ë™ì¼í•œ ë™ì‘ì´ í•„ìš”í•˜ë‹¤ë©´ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•´ì•¼í•œë‹¤.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3ê°œì˜ í•¨ìˆ˜ëŠ” ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ ìˆ˜í–‰í•œë‹¤. ì˜¤ì§ ë‹¤ë¥¸ ê²ƒì€ `Type` ë¿ì´ë‹¤. ë§Œì•½ ë˜ ë‹¤ë¥¸ Types ì— ëŒ€í•´ ê°’ì„ ë°”ê¾¸ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë‹¤ë©´, 
Types ì˜ ìˆ˜ë§Œí¼ í•¨ìˆ˜ë¥¼ ê²Œì† ë§Œë“¤ì–´ì•¼í•œë‹¤. ğŸ˜±ğŸ˜±ğŸ˜±

---

### 2. Generic Functions ğŸ‘©â€ğŸ’»

#### 1. Generic Functions

*Generic Functions* ë¥¼ ì‚¬ìš©í•˜ë©´ ìœ„ ë¬¸ì œë¥¼ `ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘(work with any type)`í•  ìˆ˜ ìˆë„ë¡ í•´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* ë¥¼ ì´ìš©í•´ `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types ë¥¼ ê°–ëŠ” 3ê°œì˜ `swap(_:_:)` í•¨ìˆ˜ë¥¼ í•˜ë‚˜ë¡œ ë§Œë“¤ì—ˆë‹¤. ë§Œì•½, ë‹¤ë¥¸ Types ì˜ ë²„ì „ì´ ë˜ ì¡´ì¬í–ˆë‹¤ë©´, ì´ *Generic Function* ì€ 
ìˆ˜ì—†ì´ ë§ì€ í•¨ìˆ˜ì˜ *Overloading* ì„ ì²˜ë¦¬í–ˆì„ ê²ƒì´ë‹¤.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* ì™€ *Nongeneric Function* ë¥¼ ë¹„êµí•´ë³´ì.

- swap<T> : Swift ì—ê²Œ ì´ `swap` í•¨ìˆ˜ ì •ì˜ì—ì„œ `T`ê°€ `Placeholder Type`ì´ë¼ê³  ì•Œë¦°ë‹¤. ì´ `<T>`ê°€ ë°”ë¡œ ë‹¤ìŒì— ì„¤ëª…í•˜ê²Œ ë  
            [Type Parameters](#h-3-type-parameters-t) ë‹¤.
- (_ a: inout T, _ b: inout T) : í•¨ìˆ˜ì˜ Parameters ê°€ `T`ë¼ëŠ” `Placeholder Type`ìœ¼ë¡œ ì •ì˜ëœë‹¤.

ì´ `T`ë¼ëŠ” Type ì€ Swift ë‚´ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ê²ƒì€ ë¯¸ë¦¬ ì •ì˜ë˜ì§€ ì•Šì€ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ `Type Inference`ì— ì˜í•´ Type ì´ 
ì •ì˜ë¨ì„ ì˜ë¯¸í•œë‹¤.

ë”°ë¼ì„œ *Generic Function* `swap(_:_:)`ì€ ìœ„ì—ì„œ ì •ì˜í•œ Int, Double, String 3ê°€ì§€ íƒ€ì…ì— ëŒ€í•´ ëª¨ë‘ ë™ì‘í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> ìœ„ì—ì„œ ì •ì˜í•œ Generic Function `swap(_:_:)`ì€ ì‚¬ì‹¤ `Swift stardard library`ì— ì´ë¯¸ built-in ëœ í•¨ìˆ˜ë¡œ 
> ë³„ë„ì˜ êµ¬í˜„ ì—†ì´ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

#### 3. Type Parameters `<T>`

ìœ„ `swap(_:_:)`ì—ì„œ *Placeholder Type* `T`ëŠ” `Type Parameters`ì˜ í•œê°€ì§€ ì˜ˆì‹œë¥¼ ë³´ì—¬ì¤€ë‹¤. *Type Parameters* ëŠ” í•¨ìˆ˜ì˜ 
ì´ë¦„ ë’¤ì— ìœ„ì¹˜í•˜ë©° `<T>`ì™€ ê°™ì´ *angle brackets* `< >`ë¡œ ê°ì‹¸ ì •ì˜í•œë‹¤.

*Type Parameters* ë¥¼ ì •ì˜í•˜ë©´, í•¨ìˆ˜ì˜ ì •ì˜ì—ì„œ *Parameters* ì— ì´ê²ƒì„ *Placeholder Type* ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤. 
ë°”ë¡œ `(_ a: inout T, _ b: inout T)` ë¶€ë¶„ì´ë‹¤. `Type Parameter <T> ë¥¼ ì •ì˜`í–ˆê¸° ë•Œë¬¸ì— í•¨ìˆ˜ ì •ì˜ì—ì„œ *Parameters* 
`a`, `b`ì— `Type Parameter T ë¥¼ Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`í•  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.

#### 4. Naming Type Parameters

ìœ„ì—ì„œëŠ” Type Parameters ì˜ ì´ë¦„ìœ¼ë¡œ `T`ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì´ê²ƒì€ ë°˜ë“œì‹œ `T`ë¥¼ ì“°ë„ë¡ ì •í•´ì§„ ê²ƒì€ ì•„ë‹ˆë‹¤. ë‹¤ë§Œ ì˜ë„ë¥¼ ë‚´ì¹˜ë¹„ê¸° ìœ„í•´ ë³´í†µ 
ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.

- êµ¬ë¶„ë˜ëŠ” ê´€ê³„ê°€ ìˆëŠ” ê²½ìš° : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`ì™€ ê°™ì´ 
                        ì´ë¦„ì„ í†µí•´ ê´€ê³„ë¥¼ ìœ ì¶”í•  ìˆ˜ ìˆë„ë¡ ì‚¬ìš©í•œë‹¤.
- ë³„ë‹¤ë¥¸ ê´€ê³„ê°€ ì—†ëŠ” ê²½ìš° : ì •í•´ì§„ ê·œì¹™ì€ ì—†ì§€ë§Œ ì „í†µì ìœ¼ë¡œ `T`, `U`, `V`ì™€ ê°™ì€ ë‹¨ì¼ ëŒ€ë¬¸ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.

> **Type Parameters** ë¥¼ ì •ì˜í•  ë•ŒëŠ” ì´ê²ƒì´ `Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`ëœë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ `Upper Camel Case`ë¥¼ 
> ì‚¬ìš©í•œë‹¤. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types ğŸ‘©â€ğŸ’»

#### 1. Generic types

Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë¼ê³  ì„¤ëª…í–ˆë‹¤. ì´ë ‡ë“¯ Swift ëŠ” `Generic Functions` 
ì™¸ì—ë„ `Generic Types`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°, *Array*, *Dictionary* ì™€ ìœ ì‚¬í•˜ê²Œ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” *Custom Classes, 
Structures, Enumerations* ë‹¤.

<br>

`Stack` ì€ `Pushing`ê³¼ `Popping`ì„ í†µí•´ ë™ì‘í•˜ë©° `LIFO` ë¡œ ë™ì‘í•œë‹¤. ì´ *Stack* ì„ ì´ìš©í•´ *Generic Types* ë¥¼ ì„¤ëª…í•œë‹¤. 

> Stack ê°œë…ì€  **Navigation Hierarchy** ì—ì„œ **View Controllers** ë¥¼ ëª¨ë¸ë§ í•˜ëŠ” `UINavigationController` class ì— 
> ì˜í•´ ì‚¬ìš©ëœë‹¤. **UINavigationController** Class ì—ì„œ Navigation Stack ì— **View Controller** ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•˜ê¸° 
> ìœ„í•´ `pushViewController(_:animated:)` ë©”ì„œë“œì™€ `popViewControllerAnimated(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©°, ì´ê²ƒì€ Stack êµ¬ì¡°ë¡œ 
> `LIFO` ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤.

![Stack 1](/assets/images/posts/2023-02-23-generics/stackPushPop~dark@2x.png){: width="800"}

ì´ê²ƒì„ ì½”ë“œë¡œ í‘œí˜„í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

```swift
var intStack = IntStack(items: [3, 2, 5])
print(intStack) // IntStack(items: [3, 2, 5])

intStack.push(8)
print(intStack) // IntStack(items: [3, 2, 5, 8])

intStack.pop()
print(intStack) // IntStack(items: [3, 2, 5])
```

<br>

ë§Œì•½ String ì„ ì €ì¥í•˜ëŠ” *Stack* ì„ ë§Œë“¤ë ¤ë©´ ë˜ ë‹¤ë¥¸ Stack ì„ ì¶”ê°€í•´ì•¼í•œë‹¤. ê²Œë‹¤ê°€ *Overloading* ì´ ë˜ëŠ” ë©”ì„œë“œì™€ ë‹¬ë¦¬ ë§¤ë²ˆ 
ìƒì„±í•˜ëŠ” Stack Structure ì˜ ì´ë¦„ë„ ë‹¤ë¥´ê²Œ í•´ì¤˜ì•¼í•œë‹¤.

```swift
struct StringStack {
    var items: [String] = []
    mutating func push(_ item: String) {
        items.append(item)
    }
    mutating func pop() -> String {
        items.removeLast()
    }
}
```

ìš°ë¦¬ëŠ” ì´ ë¬¸ì œë¥¼ `Generic Types ë¥¼ ì´ìš©í•´ í•´ê²°`í•  ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack)             // Stack<Int>(items: [3, 2, 5])

intStack.push(8)
print(intStack)             // Stack<Int>(items: [3, 2, 5, 8])

intStack.pop()
print(intStack)             // Stack<Int>(items: [3, 2, 5])
```

<br>
ìœ„ Stack ì„ ì´ë²ˆì—” String ì„ ì €ì¥í•˜ëŠ”ë° ì‚¬ìš©í•´ë³´ì.

![Stack 2](/assets/images/posts/2023-02-23-generics/stackPushedFourStrings~dark@2x.png){: width="800"}

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

![Stack 3](/assets/images/posts/2023-02-23-generics/stackPoppedOneString~dark@2x.png){: width="480"}

```swift
print(stringStack.pop())    // cuatro
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres"])
```

#### 2. Extending a Generic Type

*Generic Type* ì„ í™•ì¥í•  ë•ŒëŠ” ë‹¤ë¥¸ Types ë¥¼ í™•ì¥í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì •ì˜í•  ë•Œ *Type* ì„ ì •ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ `Extension`ì€ 
ë³„ë„ì˜ ì •ì˜ ì—†ì´ `Original Type Parameters`ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•œë‹¤.

ìœ„ Stack ì„ í™•ì¥í•´ *Element* ë¥¼ ì œê±°í•˜ì§€ ì•Šê³  ê°€ì¥ ë§ˆì§€ë§‰ *Element* ë¥¼ ë°˜í™˜í•˜ëŠ” *Read-Only Computed Properties* ë¥¼ 
ì¶”ê°€í•´ë³´ì.

```swift
extension Stack {
    var topItem: Element? {
        items.last
    }
}
```

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])

if let topItem = stringStack.topItem {
    print(topItem)          // cuatro
}
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

---

### 4. Type Constraints ğŸ‘©â€ğŸ’»

#### 1. Type Constraints

ìœ„ì—ì„œ ì •ì˜í•œ [`swap(_:_:)`](#h-1-generic-functions) í•¨ìˆ˜ì™€ [Stack](#h-1-generic-types) ì€ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•œë‹¤. 
í•˜ì§€ë§Œ ë•Œë¡œëŠ” Generic ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Types ì— `type constraints`ë¥¼ ê°•ì œí•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ìˆ˜ ìˆë‹¤. *Type constraints* ëŠ” 
`Type Parameters ê°€ íŠ¹ì • Class ë¥¼ ìƒì†í•˜ê±°ë‚˜ Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•¨`ì„ ì§€ì •í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ *Dictionary* Type ì€ `Key ì˜ Type ì€ Hashable ì„ ì¤€ìˆ˜`í•˜ëŠ” ê²ƒìœ¼ë¡œ ì œí•œí•œë‹¤. ê·¸ë˜ì•¼ë§Œ íŠ¹ì • í‚¤ì— ê°’ì´ ì´ë¯¸ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ 
í›„ ì‚½ì…í• ì§€ ëŒ€ì²´í• ì§€ íŒë‹¨í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤(Swift ì˜ ëª¨ë“  ê¸°ë³¸ íƒ€ì… *String, Int, Double, Bool* ì€ ëª¨ë‘ *Hashable* ì„ ì¤€ìˆ˜í•œë‹¤).

ë”°ë¼ì„œ ì‚¬ìš©ìëŠ” ì‚¬ìš©ì ì •ì˜ Generic Types ë¥¼ ì •ì˜í•  ë•Œ *constraints* ë¥¼ ì œê³µí•˜ëŠ” ê²ƒì€ *Generic Programming* ì„ ë”ìš± ê°•ë ¥í•˜ê²Œ í•œë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Hashable ê³¼ ê°™ì€ ì¶”ìƒì  ê°œë…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ êµ¬ì²´ì ì¸ ìœ í˜•ì´ ì•„ë‹Œ ê°œë…ì  íŠ¹ì„±ì—ì„œ Type ì˜ íŠ¹ì„±ì„ ê°•í™”í•œë‹¤.

#### 2. Type Constraint Syntax

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

ìœ„ í•¨ìˆ˜ëŠ” 2ê°œì˜ `Type Parameters`ë¥¼ ê°–ëŠ”ë‹¤. `T ëŠ” SomeClass ì˜ Subclass`ì´ì–´ì•¼í•˜ê³ , `U ëŠ” SomeProtocol ì„ ì¤€ìˆ˜`í•´ì•¼í•œë‹¤ëŠ” 
*constraints* ë¥¼ ì¶”ê°€í•œë‹¤.

#### 3. Type Constraints in Action

__1 ) Nongeneric Function__

ë‹¤ìŒì€ ì°¾ì•„ì•¼ í•  `String`ê³¼ ì°¾ì•„ì•¼ í•˜ëŠ” ëŒ€ìƒ `[String]`ì„ ë°›ëŠ” `findIndex(ofString:in:)`ì´ë¼ëŠ” *Nongeneric Function* ì´ë‹¤.

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]

if let dogIndex = findIndex(ofString: "dog", in: strings) {
    print("The index of dog is \(dogIndex).")
} else {
    print("The dog is not in the array.")
}

if let bearIndex = findIndex(ofString: "bear", in: strings) {
    print("The index of bear is \(bearIndex).")
} else {
    print("The bear is not in the array.")
}
```

```console
The index of dog is 1.
The bear is not in the array.
```

<br>

__2 ) Generic Function__

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ *Generic Function* ìœ¼ë¡œ ë°”ê¿”ë³´ì.

![Generic Function Define Error](/assets/images/posts/2023-02-23-generics/generic-function-define-error.png){: width="800"}

ì˜ˆìƒê³¼ ë‹¬ë¦¬ *compile-error* ê°€ ë°œìƒí•œë‹¤. `==` operator ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” [Equatable](l#h-1-synthesized-implementation-of-equatable) 
ì„ ì¤€ìˆ˜í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ***Type Parameter `<T>`ì— Equatable Protocol ì„ ì¤€ìˆ˜(confirm)í•˜ëŠ” ê²ƒìœ¼ë¡œ `constraints`ë¥¼ ì¶”ê°€***í•´ 
ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
if let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) {
    print("The index of 9.3 is \(doubleIndex).")
} else {
    print("The 9.3 is not in the array.")
}

if let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"]) {
    print("The index of Andrea is \(stringIndex).")
} else {
    print("Andrea is not in the array.")
}
```

```console
The 9.3 is not in the array.
The index of Andrea is 2.
```

---

### 5. Associated Types ğŸ‘©â€ğŸ’»

#### 1. Associated Types

Protocol ì„ ì •ì˜í•  ë•Œ ë•Œë¡œëŠ” `Associated Type`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ë•Œê°€ ìˆë‹¤. *Associated Type* ì€ `Protocol ì—ì„œ 
ì‚¬ìš©ë  Type ì˜ ì´ë¦„ì„ ì œê³µ`í•œë‹¤. ë°˜ë©´ `ì‹¤ì œ Type ì€ Protocol ì´ ì±„íƒë  ë•Œ ì •í•´ì§„ë‹¤`ëŠ” ì ì—ì„œ [Type Parameter] ë¥¼ ì´ìš©í•´ 
Generic Types ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ë‹¤.

> Generic Types ëŠ” Functions ë‚˜ Classes, Structures, Enumerations ì—ì„œ Types ì— ëŒ€í•œ íŒë‹¨ì„ ë³´ë¥˜í•˜ë„ë¡ í•´ 
> Type Inference ê°€ ì²˜ë¦¬í•˜ë„ë¡ ë¯¸ë£¨ì—ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ Associated Types ëŠ” Protocols ë¥¼ ì •ì˜í•  ë•Œ Types ì— ëŒ€í•œ íŒë‹¨ì„ 
> ë³´ë¥˜í•˜ë„ë¡ í•œë‹¤.
> 
> ë§Œì•½, Generic Types ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `n`ê°œì˜ Types ì— ëŒ€í•œ Structures ë¥¼ ìœ„í•´ 
> `n ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ Structures ë¥¼ ì •ì˜`í•´ì•„í•œë‹¤.  
> ë§ˆì°¬ê°€ì§€ë¡œ, Associated Types ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ã„·ë©´ `n`ê°œì˜ Types ì— ëŒ€í•œ Protocols ë¥¼ ìœ„í•´ 
> `n ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ Protocols ë¥¼ ì •ì˜`í•´ì•¼í•œë‹¤.  
> ì¦‰, 3ê°€ì§€ Types ë¥¼ ì •ì˜í•˜ê³ ì í•  ê²½ìš° `n + n`ê°œê°€ í•„ìš”í•˜ë¯€ë¡œ `6ê°œì˜ ì •ì˜ì™€ 3ë²ˆì˜ Protocols ì±„íƒê³¼ ì¤€ìˆ˜`ê°€ í•„ìš”í•˜ë‹¤.
> 
> Generic Types ì™€ Associated Types ëŠ” ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê³  ì½”ë“œë¥¼ ìœ ì—°í•˜ê²Œ ë§Œë“ ë‹¤.

#### 2. Associated Type Syntax

```swift
protocol SomeProtocol {
    associatedtype Item
    // protocol body goes here
}
```

ìœ„ì—ì„œ `Item`ì€ [Type Parameter] ì˜ `Dictionary<Key, Value>`, `Array<Element>`, `<T>`ì™€ ê°™ì´ 
Protocol ì„ ì •ì˜í•  ë•Œ ì‚¬ìš©í•  *ì´ë¦„ì„ ì œê³µ*í•˜ëŠ” ë°˜ë©´ *Type ì€ ì‹¤ì œ ì±„íƒë  ë•Œ ì •í•´ì§€ë„ë¡ íŒë‹¨ì„ ë¯¸ë£¬ë‹¤*.

> Protocol ì€ í•¨ìˆ˜ì˜ return type ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆì§€ë§Œ, Associated Types ë¥¼ ê°–ê³  ìˆëŠ” Protocol ì€ return type ìœ¼ë¡œ 
> ì‚¬ìš©ë  ìˆ˜ ì—†ë‹¤. ì´ì— ëŒ€í•´ì„œëŠ” ë‹¤ìŒ ì±•í„°ì˜ [Protocol Has an Associated Type Cannot Use as the Return Type][Protocol Has an Associated Type Cannot Use as the Return Type] 
> ì—ì„œ ì„¤ëª…í•œë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ìš°ë¦¬ëŠ” ì ì‹œ í›„ [Using a Protocol in Its Associated Typeâ€™s Constraints](#h-6-using-a-protocol-in-its-associated-types-constraints) 
> ì™€ ê°™ì´ ëª…í™•í•œ Type ì„ ë°˜í™˜í•˜ë„ë¡ í•¨ìˆ˜ì˜ ë¡œì§ì„ ë³€ê²½í•˜ê±°ë‚˜, ì´ê²ƒì´ ë¶ˆê°€ëŠ¥í•  ê²½ìš°, [Opaque Types][Opaque Type Resolve The Problem That Protocol Has an Associated Type] 
> ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

ë”°ë¼ì„œ Associated Types ì—­ì‹œ Generic Types ì™€ ë§ˆì°¬ê°€ì§€ë¡œ

```swift
protocol IntContainer {
    mutating func append(_ item: Int)
    var count: Int { get }
    subscript(i: Int) -> Int { get }
}

protocol StringContainer {
    mutating func append(_ item: String)
    var count: Int { get }
    subscript(i: Int) -> String { get }
}
```

<span id="simpleContainer">ì™€ ê°™ì€ ë¬¸ì œë¥¼ í•´ê²°í•´ <span style="color: red;">í•˜ë‚˜ì˜ ì •ì˜ë¡œ ì¬ì‚¬ìš©</span> í•  ìˆ˜ ìˆê²Œ í•œë‹¤.<span>

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

#### 3. Associated Types in Action

ì´ë²ˆì—ëŠ” ìœ„ì—ì„œ ì •ì˜í•œ [Container](#simpleContainer) Protocol ì„ ì‹¤ì œë¡œ ì±„íƒí•˜ëŠ” ê²ƒì„ ì‚´í´ë³´ì.
<br>

__1 ) Nongeneric IntStack Type adopts and conforms to the Container Protocol__

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

[Generic Types](#h-1-generic-types) ì—ì„œ ì •ì˜í•œ *Nongeneric IntStack Type* ì— 
[Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ê³  ì¤€ìˆ˜í•˜ë„ë¡ ë§Œë“¤ì–´ë³´ì.

```swift
struct IntStack: Container {
    // original IntStack implementation
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Int {
        items[i]
    }
}
```

> `typealias Item = Int`ëŠ” Swift ì˜ Type Inference ì— ì˜í•´ ìœ ì¶” ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ìƒëµ ê°€ëŠ¥í•˜ë‹¤.

<br>

__2 ) Generic Stack Type adopts and conforms to the Container Protocol__

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

ì´ë²ˆì—ëŠ” [Container](#simpleContainer) Protocol ì„ ìœ„ì—ì„œ ì •ì˜í–ˆë˜ Generic Stack ì— ì±„íƒí•´ë³´ì.

```swift
struct Stack<Element>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }

    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
intStack.push(8)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8])

intStack.append(7)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8, 7])

print(intStack.count)   // 5
print(intStack[3])      // 8


var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.append("dos")
stringStack.push("tres")
stringStack.append("cuatro")

print(stringStack)      // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
print(stringStack[1])   // dos
```

ì´ì œ Stack ì€ Int, String ë‘ íƒ€ì… ëª¨ë‘ì—ì„œ Associated Types ë¥¼ ì´ìš©í•œ Container Protocol ê¹Œì§€ ì¤€ìˆ˜í•œë‹¤.

#### 4. Extending an Existing Type to Specify an Associated Type

[Adding Protocol Conformance with an Extension] ì—ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ Protocols ì— ì¤€ìˆ˜ì„±(conformance)ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ 
ê¸°ì¡´ Type ì„ í™•ì¥í•  ìˆ˜ ìˆëŠ”ë° ì´ë•Œ *Associated Types* ê°€ ìˆëŠ” Protocols ë¥¼ í¬í•¨í•œë‹¤.

Swift ì˜ `Array`ëŠ” ì´ë¯¸ `append(_:)` method, `count` property, Int index ë¡œ Element ë¥¼ ì¡°íšŒí•˜ëŠ” `[i]` subscript 
ë¥¼ ì œê³µí•œë‹¤. ì´ê²ƒì€ ìœ„ì—ì„œ [Container](#simpleContainer) protocol ì„ í†µí•´ ì í•©ì„±ì„ ì¶”ê°€í•œ ê²ƒê³¼ ì¼ì¹˜í•œë‹¤. 
ì¦‰, [Declaring Protocol Adoption with an Extension] ì—ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ `Array ì— ì´ë¯¸ ì í•©ì„±ì„ ì¤€ìˆ˜í•˜ëŠ” êµ¬í˜„ì´ ì¡´ì¬í•˜ê¸° 
ë•Œë¬¸ì— Extension ì„ ì´ìš©í•´ Protocols ë¥¼ ì±„íƒí•˜ê³  ë¹„ì›Œë‘ëŠ” ê²ƒ ë§Œìœ¼ë¡œ Array ì— Container Protocol ì í•©ì„±ì„ ì¶”ê°€`í•  ìˆ˜ ìˆë‹¤.

```swift
var numbers = [1, 2, 5, 7, 8, 14]

numbers.append(99)
print(numbers)          // [1, 2, 5, 7, 8, 14, 99]
print(numbers.count)    // 7
print(numbers[2])       // 5
```

Array ëŠ” ì´ë¯¸ [Container](#simpleContainer) Protocol ì˜ êµ¬í˜„ì„ ì œê³µí•˜ê³ ìˆë‹¤.

```swift
if numbers is any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers do not conform the Container protocol.
```

í•˜ì§€ë§Œ [Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— [Container](#simpleContainer) Protocol 
ì„ ì¤€ìˆ˜í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.

<br>

Array ë¥¼ í™•ì¥í•´ [Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ëŠ” ê²ƒ ë§Œìœ¼ë¡œ ì í•©ì„±ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

```swift
extension Array: Container {}

if let _ = numbers as? any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers conforms the Container protocol.
```

#### 5. Adding Constraints to an Associated Type

Protocols ë¥¼ ì±„íƒí•œ Types ì— íŠ¹ì • ìš”êµ¬ì‚¬í•­ì„ ì¤€ìˆ˜í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ *constraints* ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

__Syntax__

```swift
protocol SomeProtocol {
    associatedtype Item: Equatable
    // protocol body goes here
}
```

<br>

ìš°ì„  Swift ì˜ ê¸°ë³¸ Array Type ì˜ ë™ì‘ì„ ì‚´í´ë³´ì.

```swift
var arrayA = [1, 5, 6]
var arrayB = [1, 5, 6]

print(arrayA == arrayB) // true

var arrayC = ["A", "B", "C"]
var arrayD = ["A", "C", "B"]

print(arrayC == arrayD) // false
```

Array Type ì€ *Equatable* ì„ ì¤€ìˆ˜í•˜ê¸° ë•Œë¬¸ì— ìœ„ì™€ ê°™ì€ ë¹„êµê°€ ê°€ëŠ¥í•˜ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì´ Array ë¥¼ ë‹´ì€ Structure ëŠ” ì–´ë–¨ê¹Œ?

```swift
struct Some<Element> {
    var items: [Element] = []
}
```

![Structure Stored Array](/assets/images/posts/2023-02-23-generics/structure-stored-array.png){: width="800"}

Structure ê°€ ì €ì¥í•˜ê³  ìˆëŠ” Array ëŠ” Equatable ì„ ì¤€ìˆ˜í•˜ë”ë¼ë„ Structure ëŠ” ì´ë¥¼ ì¤€ìˆ˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— Equatable ì„ ì¤€ìˆ˜í•˜ë„ë¡ 
í•´ì•¼í•œë‹¤.

![Structure Conform Equatable](/assets/images/posts/2023-02-23-generics/structure-conform-equatable.png){: width="800"}

Structure ì— Equatable ì„ ì¶”ê°€í–ˆë‹¤. ì´ë¡œì¨ Structure ëŠ” Equatable ì„ ì¤€ìˆ˜í•  ìˆ˜ ìˆì–´ì•¼í•˜ì§€ë§Œ, Element ê°€ ì´ë¯¸ Equatable 
ì„ ì¤€ìˆ˜í•˜ëŠ” Int, Double, String ê°™ì€ Swift ì˜ Basic Types ê°€ ì•„ë‹Œ Generic Types ì´ë¯€ë¡œ, ì´ì— ëŒ€í•œ Equatable ì¤€ìˆ˜ 
ë˜í•œ í•„ìš”í•˜ë‹¤.

```swift
struct Some<Element: Equatable>: Equatable {
    var items: [Element] = []

    static func == (lhs: Some<Element>, rhs: Some<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

ì´ë¡œì¨ ìš°ë¦¬ëŠ” ***Generic Types Element ì— Equatable ì„ ì¤€ìˆ˜***í•˜ë„ë¡ í•˜ê³ , 
***Structure ì—­ì‹œ Equatable ì„ ì¤€ìˆ˜***í•˜ë„ë¡ í•¨ìœ¼ë¡œì¨ `==` operator ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

```swift
var structureA = Some(items: [1, 5, 6])
var structureB = Some(items: [1, 5, 6])

print(structureA == structureB) // true

var structureC = Some(items: ["A", "B", "C"])
var structureD = Some(items: ["A", "C", "B"])

print(structureC == structureD) // false
```

<br>

ì´ë²ˆì—ëŠ” ìœ„ì—ì„œ ì •ì˜í•œ Container Protocol

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

ì˜ <span style="color: red;">**Associated Types** ì— *constraints* ë¥¼ ì¶”ê°€</span>í•´ ë‹¤ìŒê³¼ ê°™ì´ ë°”ê¿”ë³´ì.

```swift
protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

ì´ì œ ì´ Protocol ì„ ì¤€ìˆ˜í•˜ë ¤ë©´ ***Item Type ì€ Equatable ì„ ì¤€ìˆ˜***í•´ì•¼í•œë‹¤. Stack ì´ Container Protocol ì„ 
ì¤€ìˆ˜í•˜ë„ë¡ í•´ë³´ì.

```swift
struct Stack<Element: Equatable>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
    
    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

```swift
var someStack = Stack(items: [3, 2, 5])
var anotherStack = Stack(items: [3, 2, 5])

print(someStack == anotherStack)    // true
```

ì´ë¡œì¨ Container Protocol ì˜ Item ì— Equatable constraints ë¥¼ ì¶”ê°€í•´ ì±„íƒí•˜ëŠ” Types ê°€ ì´ë¥¼ ì¤€ìˆ˜í•˜ë„ë¡ êµ¬í˜„ì„ ê°•ì œí•œë‹¤.

<br>

ì°¸ê³ ë¡œ ìœ„ Container ì¤€ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ Protocols ì±„íƒì„ Extensions ë¡œ ë¶„ë¦¬í•´ ì½”ë“œë¥¼ ë” ëª…í™•íˆ êµ¬ë¶„ì§€ì„ ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }

    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

#### 6. Using a Protocol in Its Associated Typeâ€™s Constraints

Protocols ë¥¼ ì •ì˜í•  ë•Œ ìê¸° ìì‹ ì˜ ì¼ë¶€ë¡œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

```swift
protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

`SuffixableContainer` Protocol ì€ ë‚´ë¶€ ì •ì˜ì— ìê¸° ìì‹ ì„ í¬í•¨(`Suffix: SuffixableContainer`)í•˜ê³ ìˆë‹¤. ì´ Protocol 
ì—ì„œ `Suffix`ëŠ” 2ê°œì˜ *constraints* ë¥¼ ê°–ê³  ìˆë‹¤.

1. Suffix ëŠ” `SuffixableContainer` protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
2. Suffix ì˜ `Item` type ì€ `Container's Item` type ê³¼ ë™ì¼í•´ì•¼í•œë‹¤

> ì—¬ê¸°ì„œ ì£¼ì˜í•´ì•¼ í•  ê²ƒì´ `Suffix.Item == Item`ì´ **Item ì˜ ê°’ì´ ê°™ìŒì„ ì˜ë¯¸í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ëŠ” ê²ƒ**ì´ë‹¤. ì´ê²ƒì€ ì–´ë””ê¹Œì§€ë‚˜ 
> `associatedtype`ì„ ì •ì˜í•˜ëŠ” ê²ƒì´ë¯€ë¡œ `Type ì˜ ì¼ì¹˜`ë¥¼ ì˜ë¯¸í•œë‹¤.

Item ì— ëŒ€í•œ *constraints* ëŠ” ì•„ë˜ [Associated Types with a Generic Where Clause](#h-4-associated-types-with-a-generic-where-clause) 
ì—ì„œ ì„¤ëª…í•  *Generic where* clause ë‹¤.

<br>

SuffixableContainer ë¥¼ ì±„íƒí•˜ë„ë¡ Stack ì„ í•œ ë²ˆ ë” í™•ì¥í•´ë³´ì.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> some SuffixableContainer {
        // code
    }
    func last() -> (some SuffixableContainer).Item {
        // code
    }
}
```

> `func suffix(_ size: Int) -> Suffix`ì˜ **return type** ì€ [Opaque Types][Returning an Opaque Type] 
> `some SuffixableContainer`ìœ¼ë¡œì¨, ì´ Protocol ì˜ ì¼ë¶€ì—¬ì•¼í•œë‹¤.  
> `func last() -> Suffix.Item`ì˜ **return type** ì€ [Opaque Types][Returning an Opaque Type] 
> `(some SuffixableContainer).Item`ìœ¼ë¡œì¨, ì´ Protocol ì˜ ì¼ë¶€ì˜ Item ì´ì–´ì•¼í•œë‹¤.
> 
> ê·¸ë¦¬ê³  `Container Protocol ê³¼ ì´ê²ƒì„ ì±„íƒí•œ Stack<Element> ì˜ ê´€ê³„`ë¥¼ ë³´ì.
> 
> `Container Type ì€ ê³§ ì´ê²ƒì„ ì¤€ìˆ˜í•˜ëŠ” Stack<Element>: Container Type ì„ ì˜ë¯¸`í•˜ê³ ,   
> `Item ì€ Element Type ì„ ì˜ë¯¸`í•œë‹¤.
> 
> ë”°ë¼ì„œ `SuffixableContainer ì˜ Type ì€ ê³§ Stack<Element>: Container, SuffixableContainer Type ì„ ì˜ë¯¸`í•˜ê³ ,  
> `Suffix.Item ì€ Element Type ì„ ì˜ë¯¸`í•œë‹¤.

ì´ì œ í™•ì¥ì„ ì´ìš©í•´ Stack ì´ ì´ë¥¼ ì¤€ìˆ˜í•˜ë„ë¡ `Default Implementations`ë¥¼ ì‘ì„±í•´ ì™„ì„±ì‹œì¼œë³´ì.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

ë°˜í™˜í•  Type ì´ ëª…í™•í•˜ë¯€ë¡œ ìë™ ì™„ì„±ëœ [Opaque Types][Returning an Opaque Type] ëŒ€ì‹  ë°˜í™˜ Type ì„ ëª…ì‹œì ìœ¼ë¡œ ë³€ê²½í–ˆë‹¤.

```swift
var someStack = Stack<Int>()
someStack.push(3)
someStack.append(5)
someStack.push(7)
someStack.append(9)

print(someStack.suffix(2))  // Stack<Int>(items: [7, 9])
print(someStack.last())     // 9
```

---

### 6. Generic Where Clauses ğŸ‘©â€ğŸ’»

#### 1. Generic Where Clauses

[Type Constraints](#h-4-type-constraints-) ì—ì„œ Type ì— *constraints* ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ìˆ˜ ìˆìŒì„ ë³´ì•˜ë‹¤.
ë§ˆì°¬ê°€ì§€ë¡œ *Associated Types* ì—­ì‹œ `Generic Where Clauses`ë¥¼ ì •ì˜í•´ *constraints* ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.  
ìœ„ì—ì„œ ì‚´í´ë³¸ ê²ƒì²˜ëŸ¼ `where` keyword ë’¤ì— ì‘ì„±í•˜ë©°, `Associated Types ìì²´ì— ëŒ€í•œ constraints` ë˜ëŠ”
`Types ì™€ Associated Types ì˜ equality ê´€ê³„ì— ëŒ€í•œ constraints`ê°€ ë”°ë¥¸ë‹¤.

*Generic Where Clauses* ëŠ” Type ë˜ëŠ” Function's Body ì˜ curly brace `{ }` ì•ì— ì˜¨ë‹¤.

```swift
func allItemsMatch<C1: Container, C2: Container>(_ containerA: C1, _ containerB: C2) -> Bool
where C1.Item: Equatable, C1.Item == C2.Item
{
    // Check that both containers contain the same number of items.
    if containerA.count != containerB.count {
        return false
    }

    // Check each pair of items to see if they're euivalent.
    for i in 0..<containerA.count {
        if containerA[i] != containerB[i] {
            return false
        }
    }

    // All items match, so return true.
    return true
}
```

> Type Parameters ì— ì •ì˜ëœ ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
> 
> - C1 ì€ Container Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
> - C2 ëŠ” Container Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
> 
> Generic Where Clauses ì— ì •ì˜ëœ ìš”êµ¬ì‚¬í•­ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
> 
> - C1.Item ì€ Equatable Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
> - C1.Item ì€ C2.Item ê³¼ ë™ì¼ Type ì´ì–´ì•¼í•œë‹¤.  
>   (ìœ„ì—ì„œ where clauses ì˜ Suffix.Item ì˜ ê²½ìš°ì™€ ë§ˆì°¬ê°€ì§€ë¡œ, ê°’ì˜ ì¼ì¹˜ê°€ ì•„ë‹Œ Item ì´ë¼ëŠ” Types ì˜ ì¼ì¹˜ë¥¼ ì˜ë¯¸í•œë‹¤)

ì´ëŠ” C1 ê³¼ C2 ëª¨ë‘ Container Protocol ì„ ì¤€ìˆ˜í•˜ê³  ìˆê³ , Items ê°€ Equatable Protocol ì„ ì¤€ìˆ˜í•˜ê³  ë‘ Types ê°€ ê°™ë‹¤ë©´ 
ë™ì‘í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ì¦‰, C1 ê³¼ C2 ê°€ ë™ì¼ Types ì´ì–´ì•¼ í•œë‹¤ëŠ” ì¡°ê±´ì€ ì—†ë‹¤ëŠ” ë§ì´ë‹¤!

ë”°ë¼ì„œ ìœ„ì—ì„œ ì •ì˜í•œ 

```swift
static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
    lhs.items == rhs.items
}
```

ì™€ ë‹¬ë¦¬ `allItemsMatch(_:_:)` ë©”ì„œë“œëŠ” ì„œë¡œ ë‹¤ë¥¸ Types ê°„ì˜ ë¹„êµê°€ ê°€ëŠ¥í•˜ë‹¤.

ìš°ì„  Swift Array ë¥¼ ìš°ë¦¬ê°€ ì •ì˜í•œ `Container` protocol ì„ ì¤€ìˆ˜í•˜ë„ë¡ í™•ì¥í•´ì•¼í•œë‹¤. ê·¸ëŸ°ë° `Array ì˜ Element ëŠ” 
Equatable ì„ ì¤€ìˆ˜í•˜ì§€ ì•ŠëŠ”ë‹¤`. ë”°ë¼ì„œ ë‹¤ìŒ ë‘ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ì •ì˜ë¥¼ í•  ìˆ˜ ìˆë‹¤.

<br>

__1 ) Case 1 - Swift ì˜ Built-in Type ì¸ Array ì˜ Element ë¥¼ Equatable Protocol ì„ ì¤€ìˆ˜í•˜ë„ë¡ ì œí•œ__

ìœ„ì—ì„œ ìš°ë¦¬ê°€ ë§Œë“  Container ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ë°©ë²•ì´ë‹¤.

- Protocols

```swift
protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

- Stack

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }

    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}

extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

Stack ì€ Container Protocol ì˜ Item ì´ Equatable Protocol ì„ ì¤€ìˆ˜í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ ë°˜ë“œì‹œ `==(lhs:rhs:) -> Bool` 
ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼í•œë‹¤.

- Array

```swift
extension Array: Container where Element: Equatable  {}
```

Swift ì˜ Built-in Type Array ì— `Element ê°€ Equatable Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤ëŠ” constraints ê°€ Global ë¡œ 
ì¶”ê°€`ë˜ì—ˆë‹¤.

<br>

__2 ) Case 2 - Swift ì˜ Built-in Type ì¸ Array ì˜ Element ì— constraints ì¶”ê°€ ì—†ì´ ì¤€ìˆ˜í•˜ë„ë¡ Container Protocol ì„ ìˆ˜ì •__

ìœ„ Case 1 ì´ ê°–ëŠ” ë¬¸ì œì ì€ Swift ì˜ Element ì— *constraints* ë¥¼ ì¶”ê°€í•¨ìœ¼ë¡œì¨ ê²°êµ­ `Swift Array ì— ëŒ€í•œ Global 
constraints ê°€ ì¶”ê°€`ëœë‹¤ëŠ” ê²ƒì´ë‹¤. í™•ì¥ì„ ì´ìš©í•´ *Built-in Types ì˜ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì€ ë³„ë¡œ ë¬¸ì œê°€ ë˜ì§€ ì•Šì§€ë§Œ* 
ìœ„ì™€ ê°™ì´ ***ì œì•½ ì¡°ê±´ì„ ì¶”ê°€í•´ì„œ ê¸°ëŠ¥ì„ ì œí•œì‹œí‚¤ëŠ” ê²ƒì€ `ì½”ë“œì˜ ìœ ì—°ì„±ì„ ë–¨ì–´ëœ¨ë¦¬ë©°` ì´ë¥¼ ì˜ˆìƒí•˜ì§€ ëª»í•œ ì•±ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì˜ ì½”ë“œë‚˜ 
ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì—ëŸ¬ê°€ ë°œìƒë˜ëŠ” `side effect` ì˜ ì›ì¸***ì´ ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¢‹ì€ ë°©ë²•ì´ ì•„ë‹ˆë‹¤.

ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ìœ„ì—ì„œ *Container ì˜ Item ì— ì¶”ê°€í–ˆë˜ Equatable Protocol ì œì•½ ì‚¬í•­ì„ ë‹¤ì‹œ ì œê±°*í•˜ê³  Stack ì—ì„œ í•„ìš”í•œ ë©”ì„œë“œë¥¼ 
`Protocol ì— ì˜í•œ ê°•ì œì„± ì—†ì´ êµ¬í˜„`í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì½”ë“œë¥¼ ìœ ì—°í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

- Protocols

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

ì´ì œ ë”ì´ìƒ Container ëŠ” Item ì— Equatable Protocol ì„ ì¤€ìˆ˜í•˜ë„ë¡ ê°•ìš”í•˜ì§€ ì•ŠëŠ”ë‹¤.

- Stack

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}

extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

ì´ì œ Stack ì˜ `==(lhs:rhs:) -> Bool` ë©”ì„œë“œëŠ” ë”ì´ìƒ Protocol ì˜ ìš”êµ¬ì‚¬í•­ì„ ì¤€ìˆ˜í•˜ê¸° ìœ„í•´ êµ¬í˜„ì„ ê°•ìš”ë°›ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ 
ê¸°ëŠ¥ ì œê³µì„ ìœ„í•´ Stack ì´ ìì²´ì ìœ¼ë¡œ ì´ ë©”ì„œë“œë¥¼ ì œê³µí•˜ë„ë¡ êµ¬í˜„í–ˆë‹¤.

- Array

```swift
extension Array: Container {}
```

Array ì— ìš°ë¦¬ê°€ ì •ì˜í•œ Container ë¥¼ ì¤€ìˆ˜í•˜ëŠ” Types ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ê¸°ëŠ¥ì´ ì¶”ê°€ë˜ì—ˆì„ ë¿ 
ê¸°ì¡´ `Built-in Type Array ì— ì–´ë– í•œ constraints ë„ ì¶”ê°€í•˜ì§€ ì•ŠëŠ”ë‹¤`.


<br>

ì´ì œ `==` ë©”ì„œë“œì™€ `allItemsMatch(_:_:)` í•¨ìˆ˜ë¥¼ í…ŒìŠ¤íŠ¸í•´ë³´ì.

```swift
var someStack = Stack(items: [3, 2, 5])
var anotherStack = Stack(items: [3, 2, 5])
var someArray = [3, 2, 5]

print(someStack == anotherStack)            // true
print(someStack == someArray)               // error: Cannot convert value of type 'Stack<Int>' to expected argument type '[Int]'

print(allItemsMatch(someStack, someArray))  // true
```

#### 2. Extensions with a Generic Where Clause

ìœ„ì—ì„œ `extension Array: Container where Element: Equatable  {}`ì™€ ê°™ì´ *Generic Where Clauses* ëŠ” 
*Extensions* ì˜ ì¼ë¶€ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤.

ìœ„ Case 2 ì—ì„œ ì •ì˜í•œ Stack ì´ë‹¤.

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

ìœ„ Stack ì„ *Extension* ì— *Generic Where Clauses* ë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ì½”ë“œì˜ ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

<br>

ì´ì œ ë¶„ë¦¬ëœ ê´€ì‹¬ì‚¬ì— *Element ê°€ Equatable ì„ ì¤€ìˆ˜í•˜ëŠ” ê²ƒì— ëŒ€í•œ ì½”ë“œë§Œ ë”°ë¡œ ì •ì˜*í•´ë³´ì.

```swift
extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }

    func startsWith(_ item: Element) -> Bool {
        guard let startItem = items.first else { return false }
        return startItem == item
    }

    func isTop(_ item: Element) -> Bool {
        guard let topItem = items.last else { return false }
        return topItem == item
    }
}
```

ìœ„ ì½”ë“œëŠ” Stack ì´ Container Protocol ì„ ì±„íƒí•˜ëŠ” ê²ƒê³¼ ë¬´ê´€í•˜ê²Œ ë™ì‘í•œë‹¤. ìœ„ í™•ì¥ì´ ì¶”ê°€í•˜ëŠ” 3ê°œì˜ ë©”ì„œë“œë¥¼ ë³´ë©´ 
`==(lhs:rhs:)`ì™€ ë‹¬ë¦¬ `startsWith(_:)` ë©”ì„œë“œì™€ `isTop(_:)` ë©”ì„œë“œëŠ” Stack ì— ëŒ€í•´ ëª°ë¼ë„ Element ë§Œìœ¼ë¡œ ë™ì‘í•  
ìˆ˜ ìˆë‹¤. ë§Œì•½ ì´ *ë‘ ë©”ì„œë“œë¥¼ Container Protocol ìª½ì—ì„œ ì •ì˜í•˜ë„ë¡ ê´€ì‹¬ì‚¬ë¥¼ ì˜®ê¸°ê³  ì‹¶ë‹¤ë©´* Container Protocol ì˜ Item ì— 
Equatable Protocol ì¤€ìˆ˜ì„±ì„ ì¶”ê°€í•˜ëŠ” ëŒ€ì‹  *Container Protocol ì— Extensions ë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ë¶„ë¦¬*ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

```swift
extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}

extension Container where Item: Equatable {
    func startsWith(_ item: Item) -> Bool {
        count >= 1 && self[0] == item
    }
    
    func isTop(_ item: Item) -> Bool {
        count >= 1 && self[count - 1] == item
    }
}
```

ìœ„ 2ê°œë¥¼ ê°ê° Case 3 ê³¼ Case 4 ì´ë¼ ë¶€ë¥´ë„ë¡ í•˜ì. ì½”ë“œë¥¼ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

__3 ) Case 3__

- Protocols

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

- Stack

```swift
struct Stack<Element> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }

    func startsWith(_ item: Element) -> Bool {
        guard let startItem = items.first else { return false }
        return startItem == item
    }

    func isTop(_ item: Element) -> Bool {
        guard let topItem = items.last else { return false }
        return topItem == item
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}

extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

- Array

```swift
extension Array: Container {}
```

<br>

__4 ) Case 4__

- Protocols

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

extension Container where Item: Equatable {
    func startsWith(_ item: Item) -> Bool {
        count >= 1 && self[0] == item
    }

    func isTop(_ item: Item) -> Bool {
        count >= 1 && self[count - 1] == item
    }
}

protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

`extension Stack where Element: Equatable`ì˜ ì¼ë¶€ë¡œ ì¡´ì¬í•˜ë˜ `startWith(_:)` ë©”ì„œë“œì™€ `isTop(_:)` ë©”ì„œë“œê°€ ì´ì œ 
`extension Container where Item: Equatable`ì˜ ì¼ë¶€ë¡œ ì¡´ì¬í•œë‹¤.

- Stack

```swift
struct Stack<Element> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}

extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}

```

- Array

```swift
extension Array: Container {}
```


<br>

`startsWith(_:)` ë©”ì„œë“œì™€ `isTop(_:)` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ë³´ì.

```swift
var someStack = Stack<Int>()
var anotherStack = Stack(items: [3, 2, 5])

print(someStack.startsWith(3))      // false
print(anotherStack.startsWith(2))   // false
print(anotherStack.startsWith(3))   // true

print(someStack.isTop(5))           // false
print(anotherStack.isTop(4))        // false
print(anotherStack.isTop(5))        // true
```

#### 3. Contextual Where Clauses

ìš°ë¦¬ëŠ” ìœ„ `Case 3`ê³¼ `Case 4`ì—ì„œ *Generic Where Clauses* ë¥¼ ì´ìš©í•´ *constraints* ë¥¼ ì´ìš©í•´ ì¡°ê±´ì— ì¼ì¹˜í•  ê²½ìš°ì—ë§Œ 
ë™ì‘í•˜ëŠ” *Extensions* ë¥¼ ì •ì˜í–ˆë‹¤.

Case 4 ì—ì„œ Container Protocol ì— ì‚¬ìš©í•œ í™•ì¥ì„ ë‹¤ì‹œ í•œ ë²ˆ ë³´ì.

```swift
extension Container where Item: Equatable {
    func startsWith(_ item: Item) -> Bool {
        count >= 1 && self[0] == item
    }

    func isTop(_ item: Item) -> Bool {
        count >= 1 && self[count - 1] == item
    }
}
```

ì´ ì½”ë“œëŠ” `Container Protocol ì„ ì±„íƒí•œ Types ì¤‘ Item ì´ Equatable ì„ ì¤€ìˆ˜í•˜ëŠ” ê²½ìš°ì—ë§Œ ì ìš©ë˜ëŠ” Extension`ì´ë‹¤.

ê·¸ë¦¬ê³  ìš°ë¦¬ëŠ” ì´ëŸ° *constraints* ë¥¼ ì´ìš©í•´ ì¡°ê±´ë¶€ë¡œ ì ìš©í•  ìš”êµ¬ì‚¬í•­ì„ Extensions ì´ ì•„ë‹Œ Context ë‚´ì— ì •ì˜í•  ìˆ˜ë„ ìˆë‹¤. 
ì´ê²ƒì„ `Contextual Where Clauses`ë¼ í•œë‹¤.

<br>

- [Extensions with a Generic Where Clause]

```swift
extension Container where Item == Double {
    func average() -> Double {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
}
```

- [Contextual Where Clauses]

```swift
extension Container {
    func average() -> Double where Item == Int {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
}
```

ìœ„ì—ì„œ Container Protocol ì„ ì¤€ìˆ˜í•˜ëŠ” Types ì¤‘

- Item ì´ Double ì¸ ê²½ìš°, `Extensions with a Generic Where Clause`ë¥¼ ì´ìš©í•´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê³ , 
- Item ì´ Int ì¸ ê²½ìš°, `Contextual Where Clauses`ë¥¼ ì´ìš©í•´ ê¸°ëŠ¥ì„ ì¶”ê°€í•œë‹¤.

ê·¸ë¦¬ê³  ì´ ë‘˜ì€ ê°™ì€ ë™ì‘ì„ ê°–ëŠ”ë‹¤.

```swift
var intStack = Stack(items: [3, 2, 5])
var doubleArray = [3.0, 2.0, 5.0]

print(intStack.average())       // 3.3333333333333335
print(doubleArray.average())    // 3.3333333333333335
```

#### 4. Associated Types with a Generic Where Clause

ìœ„ì—ì„œ ìš°ë¦¬ëŠ” ì´ë¯¸ *SuffixableContainer* Protocol ì„ ì •ì˜í•  ë•Œ *Associated Types ì— Generic Where Clause ë¥¼ 
ì‚¬ìš©*í•œ ì ì´ ìˆë‹¤.  
(i.e. `associatedtype Suffix: SuffixableContainer where Suffix.Item == Item`)

ë‹¤ë§Œ ìœ„ì—ì„œëŠ” ìê¸° ìì‹ ì˜ ì¼ë¶€ë¡œì¨ Associated Type ì„ ì •ì˜í•´ Container Protocol ê³¼ì˜ ì—°ê²°ì„ ìœ„í•´ ì‚¬ìš©í–ˆë‹¤. ì´ë²ˆì—ëŠ”
Associated Type ì— *Generic Where Clauses* ë¥¼ ì ìš©í•˜ëŠ” ì¢€ ë” ì¼ë°˜ì ì¸ ì˜ˆë¥¼ í•˜ë‚˜ ì¶”ê°€í•´ë³´ì.

```swift
var someStack = Stack(items: [9, 2, 5, 7, 3, 4, 2])

for element in someStack {  // error: For-in loop requires 'Stack<Int>' to conform to 'Sequence'
    print(element)
}
```

ì‚¬ìš©ì ì •ì˜ Type ì¸ Stack ì€ Structure ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ê¸° ë•Œë¬¸ì— Iterator ë¥¼ ì¤€ìˆ˜í•˜ì§€ ì•Šì•„ ë°˜ë³µì„ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤. ìš°ë¦¬ê°€ 
ì •ì˜í•œ Stack ì´ ë°˜ë³µì„ í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ë³´ì.

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }

    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
    func makeIterator() -> Iterator
}
```

ìƒˆë¡œ ì¶”ê°€ëœ Associated Type ì¸ *Iterator* ëŠ” `IteratorProtocol ì„ ì¤€ìˆ˜í•˜ë©°, ì´ê²ƒì˜ Element ì˜ Type ì€ Item ì˜ 
Type ê³¼ ë™ì¼`í•´ì•¼í•œë‹¤.

ì´ì œ Container Protocol ì„ ì¤€ìˆ˜í•˜ëŠ” Stack ì€ `makeIterator()`ë¥¼ êµ¬í˜„í•´ ì¤€ìˆ˜í•˜ë„ë¡ í•´ì•¼í•œë‹¤.

```swift
extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
    func makeIterator() -> IndexingIterator<[Element]> {
        items.makeIterator()
    }
}
```

```swift
var iteratorStack = someStack.makeIterator()
print(iteratorStack)

print("")

for element in iteratorStack {
    print(element, terminator: ", ")
}

print("")

while let element = iteratorStack.next() {
    print(element, terminator: ", ")
}
```

```console
IndexingIterator<Array<Int>>(_elements: [9, 2, 5, 7, 3, 4, 2], _position: 0)

9, 2, 5, 7, 3, 4, 2, 
9, 2, 5, 7, 3, 4, 2, 
```

ì´ì œ Stack ì€ `makeIterator()` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ `Container ì˜ Iterator ì— ëŒ€í•œ ì ‘ê·¼ì„ ì œê³µ`í•œë‹¤.

<br>

__Separate Code__

ì´ì œ ìœ„ ì½”ë“œë¥¼ ë‹¤ì‹œ ê´€ì‹¬ì‚¬ë¥¼ ë¶„ë¦¬ì‹œì¼œë³´ë„ë¡ í•˜ì. Container ì—ì„œ Iterable ê´€ë ¨ëœ ì½”ë“œë¥¼ ë¶„ë¦¬í•  ê²ƒì´ë‹¤.

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

protocol IterableContainer: Container where Iterator.Element == Item {
    associatedtype Iterator: IteratorProtocol
    func makeIterator() -> Iterator
}
```

*Container* Protocol ì—ì„œ Iterable ê´€ë ¨ ìš”êµ¬ì‚¬í•­ì„ ë¶„ë¦¬í•´ ë³„ë„ì˜ *IterableContainer* Protocol ë¡œ ë§Œë“¤ê³ ,
[Contextual Where Clauses] ëŒ€ì‹  [Extensions with a Generic Where Clause] ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í–ˆë‹¤.

ë”°ë¼ì„œ Stack ì€ Protocol ê°ê° Protocol ë³„ë¡œ ì±„íƒí•˜ê±°ë‚˜

```swift
extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}

extension Stack: IterableContainer {
    // conformance to the IterableContainer protocol
    func makeIterator() -> IndexingIterator<[Element]> {
        items.makeIterator()
    }
}
```

Stack ì´ ë°˜ë“œì‹œ *IterableContainer* Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•  ê²½ìš° ì´ëŠ” *Container* Protocol ì„ ì¤€ìˆ˜ì„±ì„ í¬í•¨í•˜ë¯€ë¡œ
*IterableContainer* Protocol ì„ ì±„íƒí•  ë•Œ í•œ ë²ˆì— êµ¬í˜„í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•˜ë‹¤.

```swift
extension Stack: IterableContainer {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }

    // conformance to the IterableContainer protocol
    func makeIterator() -> IndexingIterator<[Element]> {
        items.makeIterator()
    }
}
```

ìœ„ì™€ ë§ˆì°¬ê°€ì§€ë¡œ 

```swift
protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

ì—­ì‹œ ë‹¤ìŒê³¼ ê°™ì´ [Extensions with a Generic Where Clause] ë¡œ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.

```swift
protocol SuffixableContainer: Container where Suffix.Item == Item {
    associatedtype Suffix: SuffixableContainer
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

> **IterableContainer** Protocol ì„ ì •ì˜í•œ ê²ƒì²˜ëŸ¼ ë‹¤ì–‘í•œ ìš”êµ¬ì‚¬í•­ì„ Container Protocol ì„ ì¤€ìˆ˜í•˜ëŠ” ë‹¤ì–‘í•œ í•˜ìœ„ 
> Protocols ë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤. ë‹¤ìŒì€ Comparable ì„ ì¤€ìˆ˜í•˜ë„ë¡ í•˜ëŠ” **ComparableContainer** Protocol ì„ ì •ì˜í•˜ê¸° 
> ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì´ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
> 
> ```swift
> protocol ComparableContainer: Container where Item: Comparable { }
> ```

#### 5. Generic Subscripts

*Subscripts* ëŠ” Generic ì¼ ìˆ˜ ìˆê³ , ì´ê²ƒì€ *Generic Where Clauses* ë¥¼ í¬í•¨í•  ìˆ˜ ìˆë‹¤. ê¸°ì¡´ì— *Container* Protocol 
ì˜ ìš”êµ¬ì‚¬í•­ì„ ì¤€ìˆ˜í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ *Stack* ì€ Int Type ì˜ ë‹¨ì¼ index ë¥¼ ë°›ì•„ ë°˜í™˜í•˜ëŠ” ì½”ë“œë¥¼ êµ¬í˜„í–ˆë‹¤.

```swift
var stringStack = Stack(items: ["A", "D", "C", "K", "G", "B", "O", "Q"])
var intStack = Stack(items: [7, 23, 3, 17, 62, 5, 13, 34])

print(stringStack[2])       // C
print(stringStack[5])       // B
print(stringStack[2...5])   // error: Cannot convert value of type 'ClosedRange<Int>' to expected argument type 'Int'

print(intStack[3])          // 17
print(intStack[5])          // 5
print(intStack[3..<6])      // error: Cannot convert value of type 'Range<Int>' to expected argument type 'Int'
```

*Container* Protocol ì˜ ìš”êµ¬ì‚¬í•­ì€ `subscript(i: Int) -> Item { get }`ì´ì—ˆê¸° ë•Œë¬¸ì— *subscript*ëŠ” `Int` Type 
ë§Œ Parameters ë¡œ í—ˆìš©ëœë‹¤. ë”°ë¼ì„œ `[2...5]`ì™€ ê°™ì€ `Sequence`ëŠ” ì‚¬ìš©í•  ìˆ˜ê°€ ì—†ë‹¤.

`Parameters ë¥¼ Int Type ì˜ Sequence ë¡œ ë°›ëŠ” subscript`ë¥¼
[Protocol Extensions - Providing Default Implementations] ë¥¼ ì´ìš©í•´ ì¶”ê°€ì ìœ¼ë¡œ ì œê³µí•´ë³´ì.

```swift
extension Container {
    subscript<Indices: Sequence>(indices: Indices) -> [Item]
    where Indices.Iterator.Element == Int {
        var result: [Item] = []
        for index in indices {
            result.append(self[index])
        }
        return result
    }
}
```

- Generic Parameter `Indices` ëŠ” Standard Library `Sequence` Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
- Parameter ëŠ” `Indices` Type ì˜ *Single Parameter* `indices`ë¥¼ ë°›ëŠ”ë‹¤.
- *Generic Where Clauses* ì— ì˜í•´ `Sequence ì˜ Iterator ì˜ Element`ëŠ” `Int` Type ê³¼ ë™ì¼í•´ì•¼í•œë‹¤.
- Subscripts êµ¬í˜„ì— ì˜í•´ `Sequence ì˜ Iterator ëŠ” indices ë¡œ ì£¼ì–´ì§„ Int Type ì˜ Element ë¥¼ í†µê³¼(traverse)`í•´ì•¼í•œë‹¤.

<br>

ì´ì œ ë‹¨ì¼ index ë° ì—°ì†ëœ indices ëª¨ë‘ì—ì„œ ë™ì‘í•œë‹¤.

```swift
var stringStack = Stack(items: ["A", "D", "C", "K", "G", "B", "O", "Q"])
var intStack = Stack(items: [7, 23, 3, 17, 62, 5, 13, 34])

print(stringStack[2])       // C
print(stringStack[5])       // B
print(stringStack[2...5])   // ["C", "K", "G", "B"]

print(intStack[3])          // 17
print(intStack[5])          // 5
print(intStack[3..<6])      // [17, 62, 5]
```

---

### 7. Summary ğŸ‘©â€ğŸ’»

ì§€ê¸ˆê¹Œì§€ ì§„í–‰í•­ ë¡œì§ì„ í•œ ë²ˆì— ì •ë¦¬í•˜ê³  ë§ˆë¬´ë¦¬í•œë‹¤.

#### 1. Protocols

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

extension Container {
    subscript<Indices: Sequence>(indices: Indices) -> [Item]
    where Indices.Iterator.Element == Int {
        var result: [Item] = []
        for index in indices {
            result.append(self[index])
        }
        return result
    }
}

extension Container where Item: Equatable {
    func startsWith(_ item: Item) -> Bool {
        count >= 1 && self[0] == item
    }
    
    func isTop(_ item: Item) -> Bool {
        count >= 1 && self[count - 1] == item
    }
}

extension Container where Item == Double {
    func average() -> Double {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
}

extension Container {
    func average() -> Double where Item == Int {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
}

protocol IterableContainer: Container where Iterator.Element == Item {
    associatedtype Iterator: IteratorProtocol
    func makeIterator() -> Iterator
}

protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

#### 2. Stack

```swift
struct Stack<Element> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack where Element: Equatable {
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}

extension Stack: IterableContainer {
    // conformance to the IterableContainer protocol
    func makeIterator() -> IndexingIterator<[Element]> {
        items.makeIterator()
    }
}

extension Stack: SuffixableContainer {
    // conformance to the SuffixableContainer protocol
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

#### 3. Array

```swift
extension Array: Container {}
```

#### 4. Functions

```swift
func allItemsMatch<C1: Container, C2: Container>(_ containerA: C1, _ containerB: C2) -> Bool
where C1.Item: Equatable, C1.Item == C2.Item
{
    // Check that both containers contain the same number of items.
    if containerA.count != containerB.count {
        return false
    }

    // Check each pair of items to see if they're euivalent.
    for i in 0..<containerA.count {
        if containerA[i] != containerB[i] {
            return false
        }
    }

    // All items match, so return true.
    return true
}
```


<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics).
2. "IteratorProtocol." Apple Developer Documentation. accessed Feb. 23, 2023, [Apple Developer Documentation - IteratorProtocol](https://developer.apple.com/documentation/swift/iteratorprotocol).


[Type Parameter]:#h-3-type-parameters-t
[Adding Protocol Conformance with an Extension]:/swift/2023/02/20/protocols.html#h-5-adding-protocol-conformance-with-an-extension-
[Declaring Protocol Adoption with an Extension]:/swift/2023/02/20/protocols.html#h-4-declaring-protocol-adoption-with-an-extension
[Extensions with a Generic Where Clause]:#h-2-extensions-with-a-generic-where-clause
[Contextual Where Clauses]:#h-3-contextual-where-clauses
[Protocol Extensions - Providing Default Implementations]:/swift/2023/02/20/protocols.html#h-2-providing-default-implementations
[Returning an Opaque Type]:/swift/2023/02/27/opaque-types.html#h-3-returning-an-opaque-type-
[Protocol Has an Associated Type Cannot Use as the Return Type]:/swift/2023/02/27/opaque-types.html#h-2-protocol-has-an-associated-type-cannot-use-as-the-return-type
[Opaque Type Resolve The Problem That Protocol Has an Associated Type]:/swift/2023/02/27/opaque-types.html#h-3-opaque-type-resolve-the-problem-that-protocol-has-an-associated-type
