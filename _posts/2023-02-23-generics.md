---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics ğŸ‘©â€ğŸ’»

#### 1. Generics

`Generic code`ëŠ” ì •ì˜í•œ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” ìœ ì—°í•˜ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ì™€ íƒ€ì…ì„ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.

*Generic* ì€ Swift ì˜ ê°•ë ¥í•œ íŠ¹ì§• ì¤‘ í•˜ë‚˜ë¡œ ëŒ€ë¶€ë¶„ì˜ `Swift stardard library`ëŠ” *Generic code* ë¡œ ì‘ì„±ë˜ì—ˆë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë‹¤. Array ë¥¼ ì´ìš©í•´ ìš°ë¦¬ëŠ” 
Int ë¥¼ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , String ì„ ì €ì¥í•  ìˆ˜ë„ ìˆê³ , Swift ì—ì„œ ìƒì„±ë  ìˆ˜ ìˆëŠ” ëª¨ë“  Type ì„ ì €ì¥í•  ìˆ˜ ìˆë‹¤.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

ìœ„ `swap(_:_:)` í•¨ìˆ˜ëŠ” `(Int, Int) -> Void` Type ì˜ `Standard Function`ìœ¼ë¡œ `Nongeneric Function`ìœ¼ë¡œ 
ë‘ ê°’ì„ ë°”ê¾¸ëŠ” ì¼ì„ ìˆ˜í–‰í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

ì´ í•¨ìˆ˜ëŠ” ì˜¤ì§ `Int`ì¼ ë•Œë§Œ ë™ì‘í•œë‹¤. ë§Œì•½, `Double` ë˜ëŠ” `String`ì¼ ë•Œ ë™ì¼í•œ ë™ì‘ì´ í•„ìš”í•˜ë‹¤ë©´ ìš°ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•´ì•¼í•œë‹¤.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3ê°œì˜ í•¨ìˆ˜ëŠ” ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ ìˆ˜í–‰í•œë‹¤. ì˜¤ì§ ë‹¤ë¥¸ ê²ƒì€ `Type` ë¿ì´ë‹¤. ë§Œì•½ ë˜ ë‹¤ë¥¸ Types ì— ëŒ€í•´ ê°’ì„ ë°”ê¾¸ëŠ” ë¡œì§ì´ í•„ìš”í•˜ë‹¤ë©´, 
Types ì˜ ìˆ˜ë§Œí¼ í•¨ìˆ˜ë¥¼ ê²Œì† ë§Œë“¤ì–´ì•¼í•œë‹¤. ğŸ˜±ğŸ˜±ğŸ˜±

---

### 2. Generic Functions ğŸ‘©â€ğŸ’»

#### 1. Generic Functions

*Generic Functions* ë¥¼ ì‚¬ìš©í•˜ë©´ ìœ„ ë¬¸ì œë¥¼ `ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘(work with any type)`í•  ìˆ˜ ìˆë„ë¡ í•´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* ë¥¼ ì´ìš©í•´ `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types ë¥¼ ê°–ëŠ” 3ê°œì˜ `swap(_:_:)` í•¨ìˆ˜ë¥¼ í•˜ë‚˜ë¡œ ë§Œë“¤ì—ˆë‹¤. ë§Œì•½, ë‹¤ë¥¸ Types ì˜ ë²„ì „ì´ ë˜ ì¡´ì¬í–ˆë‹¤ë©´, ì´ *Generic Function* ì€ 
ìˆ˜ì—†ì´ ë§ì€ í•¨ìˆ˜ì˜ *Overloading* ì„ ì²˜ë¦¬í–ˆì„ ê²ƒì´ë‹¤.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* ì™€ *Nongeneric Function* ë¥¼ ë¹„êµí•´ë³´ì.

- swap<T> : Swift ì—ê²Œ ì´ `swap` í•¨ìˆ˜ ì •ì˜ì—ì„œ `T`ê°€ `Placeholder Type`ì´ë¼ê³  ì•Œë¦°ë‹¤. ì´ `<T>`ê°€ ë°”ë¡œ ë‹¤ìŒì— ì„¤ëª…í•˜ê²Œ ë  
            [Type Parameters](#h-3-type-parameters-t) ë‹¤.
- (_ a: inout T, _ b: inout T) : í•¨ìˆ˜ì˜ Parameters ê°€ `T`ë¼ëŠ” `Placeholder Type`ìœ¼ë¡œ ì •ì˜ëœë‹¤.

ì´ `T`ë¼ëŠ” Type ì€ Swift ë‚´ì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤. ì´ê²ƒì€ ë¯¸ë¦¬ ì •ì˜ë˜ì§€ ì•Šì€ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ `Type Inference`ì— ì˜í•´ Type ì´ 
ì •ì˜ë¨ì„ ì˜ë¯¸í•œë‹¤.

ë”°ë¼ì„œ *Generic Function* `swap(_:_:)`ì€ ìœ„ì—ì„œ ì •ì˜í•œ Int, Double, String 3ê°€ì§€ íƒ€ì…ì— ëŒ€í•´ ëª¨ë‘ ë™ì‘í•œë‹¤.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> ìœ„ì—ì„œ ì •ì˜í•œ Generic Function `swap(_:_:)`ì€ ì‚¬ì‹¤ `Swift stardard library`ì— ì´ë¯¸ built-in ëœ í•¨ìˆ˜ë¡œ 
> ë³„ë„ì˜ êµ¬í˜„ ì—†ì´ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

#### 3. Type Parameters `<T>`

ìœ„ `swap(_:_:)`ì—ì„œ *Placeholder Type* `T`ëŠ” `Type Parameters`ì˜ í•œê°€ì§€ ì˜ˆì‹œë¥¼ ë³´ì—¬ì¤€ë‹¤. *Type Parameters* ëŠ” í•¨ìˆ˜ì˜ 
ì´ë¦„ ë’¤ì— ìœ„ì¹˜í•˜ë©° `<T>`ì™€ ê°™ì´ *angle brackets* `< >`ë¡œ ê°ì‹¸ ì •ì˜í•œë‹¤.

*Type Parameters* ë¥¼ ì •ì˜í•˜ë©´, í•¨ìˆ˜ì˜ ì •ì˜ì—ì„œ *Parameters* ì— ì´ê²ƒì„ *Placeholder Type* ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤. 
ë°”ë¡œ `(_ a: inout T, _ b: inout T)` ë¶€ë¶„ì´ë‹¤. `Type Parameter <T> ë¥¼ ì •ì˜`í–ˆê¸° ë•Œë¬¸ì— í•¨ìˆ˜ ì •ì˜ì—ì„œ *Parameters* 
`a`, `b`ì— `Type Parameter T ë¥¼ Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`í•  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.

#### 4. Naming Type Parameters

ìœ„ì—ì„œëŠ” Type Parameters ì˜ ì´ë¦„ìœ¼ë¡œ `T`ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì´ê²ƒì€ ë°˜ë“œì‹œ `T`ë¥¼ ì“°ë„ë¡ ì •í•´ì§„ ê²ƒì€ ì•„ë‹ˆë‹¤. ë‹¤ë§Œ ì˜ë„ë¥¼ ë‚´ì¹˜ë¹„ê¸° ìœ„í•´ ë³´í†µ 
ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.

- êµ¬ë¶„ë˜ëŠ” ê´€ê³„ê°€ ìˆëŠ” ê²½ìš° : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`ì™€ ê°™ì´ 
                        ì´ë¦„ì„ í†µí•´ ê´€ê³„ë¥¼ ìœ ì¶”í•  ìˆ˜ ìˆë„ë¡ ì‚¬ìš©í•œë‹¤.
- ë³„ë‹¤ë¥¸ ê´€ê³„ê°€ ì—†ëŠ” ê²½ìš° : ì •í•´ì§„ ê·œì¹™ì€ ì—†ì§€ë§Œ ì „í†µì ìœ¼ë¡œ `T`, `U`, `V`ì™€ ê°™ì€ ë‹¨ì¼ ëŒ€ë¬¸ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.

> **Type Parameters** ë¥¼ ì •ì˜í•  ë•ŒëŠ” ì´ê²ƒì´ `Placeholder Type ìœ¼ë¡œ ì‚¬ìš©`ëœë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ `Upper Camel Case`ë¥¼ 
> ì‚¬ìš©í•œë‹¤. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types ğŸ‘©â€ğŸ’»

#### 1. Generic types

Swift ì˜ *Array* ì™€ *Dictionary* Types ëŠ” `Generic Collections`ë¼ê³  ì„¤ëª…í–ˆë‹¤. ì´ë ‡ë“¯ Swift ëŠ” `Generic Functions` 
ì™¸ì—ë„ `Generic Types`ë¥¼ ì •ì˜í•  ìˆ˜ ìˆìœ¼ë©°, *Array*, *Dictionary* ì™€ ìœ ì‚¬í•˜ê²Œ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆëŠ” *Custom Classes, 
Structures, Enumerations* ë‹¤.

<br>

`Stack` ì€ `Pushing`ê³¼ `Popping`ì„ í†µí•´ ë™ì‘í•˜ë©° `LIFO` ë¡œ ë™ì‘í•œë‹¤. ì´ *Stack* ì„ ì´ìš©í•´ *Generic Types* ë¥¼ ì„¤ëª…í•œë‹¤. 

> Stack ê°œë…ì€  **Navigation Hierarchy** ì—ì„œ **View Controllers** ë¥¼ ëª¨ë¸ë§ í•˜ëŠ” `UINavigationController` class ì— 
> ì˜í•´ ì‚¬ìš©ëœë‹¤. **UINavigationController** Class ì—ì„œ Navigation Stack ì— **View Controller** ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•˜ê¸° 
> ìœ„í•´ `pushViewController(_:animated:)` ë©”ì„œë“œì™€ `popViewControllerAnimated(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©°, ì´ê²ƒì€ Stack êµ¬ì¡°ë¡œ 
> `LIFO` ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤.

![Stack 1](/assets/images/posts/2023-02-23-generics/stackPushPop~dark@2x.png){: width="800"}

ì´ê²ƒì„ ì½”ë“œë¡œ í‘œí˜„í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

```swift
var intStack = IntStack(items: [3, 2, 5])
print(intStack) // IntStack(items: [3, 2, 5])

intStack.push(8)
print(intStack) // IntStack(items: [3, 2, 5, 8])

intStack.pop()
print(intStack) // IntStack(items: [3, 2, 5])
```

<br>

ë§Œì•½ String ì„ ì €ì¥í•˜ëŠ” *Stack* ì„ ë§Œë“¤ë ¤ë©´ ë˜ ë‹¤ë¥¸ Stack ì„ ì¶”ê°€í•´ì•¼í•œë‹¤. ê²Œë‹¤ê°€ *Overloading* ì´ ë˜ëŠ” ë©”ì„œë“œì™€ ë‹¬ë¦¬ ë§¤ë²ˆ 
ìƒì„±í•˜ëŠ” Stack Structure ì˜ ì´ë¦„ë„ ë‹¤ë¥´ê²Œ í•´ì¤˜ì•¼í•œë‹¤.

```swift
struct StringStack {
    var items: [String] = []
    mutating func push(_ item: String) {
        items.append(item)
    }
    mutating func pop() -> String {
        items.removeLast()
    }
}
```

ìš°ë¦¬ëŠ” ì´ ë¬¸ì œë¥¼ `Generic Types ë¥¼ ì´ìš©í•´ í•´ê²°`í•  ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack)             // Stack<Int>(items: [3, 2, 5])

intStack.push(8)
print(intStack)             // Stack<Int>(items: [3, 2, 5, 8])

intStack.pop()
print(intStack)             // Stack<Int>(items: [3, 2, 5])
```

<br>
ìœ„ Stack ì„ ì´ë²ˆì—” String ì„ ì €ì¥í•˜ëŠ”ë° ì‚¬ìš©í•´ë³´ì.

![Stack 2](/assets/images/posts/2023-02-23-generics/stackPushedFourStrings~dark@2x.png){: width="800"}

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

![Stack 3](/assets/images/posts/2023-02-23-generics/stackPoppedOneString~dark@2x.png){: width="480"}

```swift
print(stringStack.pop())    // cuatro
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres"])
```

#### 2. Extending a Generic Type

*Generic Type* ì„ í™•ì¥í•  ë•ŒëŠ” ë‹¤ë¥¸ Types ë¥¼ í™•ì¥í•  ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì •ì˜í•  ë•Œ *Type* ì„ ì •ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤. ë”°ë¼ì„œ `Extension`ì€ 
ë³„ë„ì˜ ì •ì˜ ì—†ì´ `Original Type Parameters`ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•œë‹¤.

ìœ„ Stack ì„ í™•ì¥í•´ *Element* ë¥¼ ì œê±°í•˜ì§€ ì•Šê³  ê°€ì¥ ë§ˆì§€ë§‰ *Element* ë¥¼ ë°˜í™˜í•˜ëŠ” *Read-Only Computed Properties* ë¥¼ 
ì¶”ê°€í•´ë³´ì.

```swift
extension Stack {
    var topItem: Element? {
        items.last
    }
}
```

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])

if let topItem = stringStack.topItem {
    print(topItem)          // cuatro
}
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

---

### 4. Type Constraints ğŸ‘©â€ğŸ’»

#### 1. Type Constraints

ìœ„ì—ì„œ ì •ì˜í•œ [`swap(_:_:)`](#h-1-generic-functions) í•¨ìˆ˜ì™€ [Stack](#h-1-generic-types) ì€ ëª¨ë“  íƒ€ì…ì—ì„œ ë™ì‘í•œë‹¤. 
í•˜ì§€ë§Œ ë•Œë¡œëŠ” Generic ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Types ì— `type constraints`ë¥¼ ê°•ì œí•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ìˆ˜ ìˆë‹¤. *Type constraints* ëŠ” 
`Type Parameters ê°€ íŠ¹ì • Class ë¥¼ ìƒì†í•˜ê±°ë‚˜ Protocol ì„ ì¤€ìˆ˜í•´ì•¼í•¨`ì„ ì§€ì •í•œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ *Dictionary* Type ì€ `Key ì˜ Type ì€ Hashable ì„ ì¤€ìˆ˜`í•˜ëŠ” ê²ƒìœ¼ë¡œ ì œí•œí•œë‹¤. ê·¸ë˜ì•¼ë§Œ íŠ¹ì • í‚¤ì— ê°’ì´ ì´ë¯¸ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ 
í›„ ì‚½ì…í• ì§€ ëŒ€ì²´í• ì§€ íŒë‹¨í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤(Swift ì˜ ëª¨ë“  ê¸°ë³¸ íƒ€ì… *String, Int, Double, Bool* ì€ ëª¨ë‘ *Hashable* ì„ ì¤€ìˆ˜í•œë‹¤).

ë”°ë¼ì„œ ì‚¬ìš©ìëŠ” ì‚¬ìš©ì ì •ì˜ Generic Types ë¥¼ ì •ì˜í•  ë•Œ *constraints* ë¥¼ ì œê³µí•˜ëŠ” ê²ƒì€ *Generic Programming* ì„ ë”ìš± ê°•ë ¥í•˜ê²Œ í•œë‹¤. 
ì˜ˆë¥¼ ë“¤ì–´ Hashable ê³¼ ê°™ì€ ì¶”ìƒì  ê°œë…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ êµ¬ì²´ì ì¸ ìœ í˜•ì´ ì•„ë‹Œ ê°œë…ì  íŠ¹ì„±ì—ì„œ Type ì˜ íŠ¹ì„±ì„ ê°•í™”í•œë‹¤.

#### 2. Type Constraint Syntax

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

ìœ„ í•¨ìˆ˜ëŠ” 2ê°œì˜ `Type Parameters`ë¥¼ ê°–ëŠ”ë‹¤. `T ëŠ” SomeClass ì˜ Subclass`ì´ì–´ì•¼í•˜ê³ , `U ëŠ” SomeProtocol ì„ ì¤€ìˆ˜`í•´ì•¼í•œë‹¤ëŠ” 
*constraints* ë¥¼ ì¶”ê°€í•œë‹¤.

#### 3. Type Constraints in Action

__1 ) Nongeneric Function__

ë‹¤ìŒì€ ì°¾ì•„ì•¼ í•  `String`ê³¼ ì°¾ì•„ì•¼ í•˜ëŠ” ëŒ€ìƒ `[String]`ì„ ë°›ëŠ” `findIndex(ofString:in:)`ì´ë¼ëŠ” *Nongeneric Function* ì´ë‹¤.

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]

if let dogIndex = findIndex(ofString: "dog", in: strings) {
    print("The index of dog is \(dogIndex).")
} else {
    print("The dog is not in the array.")
}

if let bearIndex = findIndex(ofString: "bear", in: strings) {
    print("The index of bear is \(bearIndex).")
} else {
    print("The bear is not in the array.")
}
```

```console
The index of dog is 1.
The bear is not in the array.
```

<br>

__2 ) Generic Function__

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ *Generic Function* ìœ¼ë¡œ ë°”ê¿”ë³´ì.

![Generic Function Define Error](/assets/images/posts/2023-02-23-generics/generic-function-define-error.png){: width="800"}

ì˜ˆìƒê³¼ ë‹¬ë¦¬ *compile-error* ê°€ ë°œìƒí•œë‹¤. `==` operator ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” [Equatable](l#h-1-synthesized-implementation-of-equatable) 
ì„ ë§Œì¡±í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ***Type Parameter `<T>`ì— Equatable Protocol ì„ ì¤€ìˆ˜(confirm)í•˜ëŠ” ê²ƒìœ¼ë¡œ `constraints`ë¥¼ ì¶”ê°€***í•´ 
ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
if let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) {
    print("The index of 9.3 is \(doubleIndex).")
} else {
    print("The 9.3 is not in the array.")
}

if let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"]) {
    print("The index of Andrea is \(stringIndex).")
} else {
    print("Andrea is not in the array.")
}
```

```console
The 9.3 is not in the array.
The index of Andrea is 2.
```

---

### 5. Associated Types ğŸ‘©â€ğŸ’»

#### 1. Associated Types

Protocol ì„ ì •ì˜í•  ë•Œ ë•Œë¡œëŠ” `Associated Type`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ìœ ìš©í•  ë•Œê°€ ìˆë‹¤. *Associated Type* ì€ `Protocol ì—ì„œ 
ì‚¬ìš©ë  Type ì˜ ì´ë¦„ì„ ì œê³µ`í•œë‹¤. ë°˜ë©´ `ì‹¤ì œ Type ì€ Protocol ì´ ì±„íƒë  ë•Œ ì •í•´ì§„ë‹¤`ëŠ” ì ì—ì„œ 
[Type Parameter][Type Parameter] ë¥¼ ì´ìš©í•´ Generic Types ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒê³¼ ìœ ì‚¬í•˜ë‹¤.

> Generic Types ëŠ” Functions ë‚˜ Classes, Structures, Enumerations ì—ì„œ Types ì— ëŒ€í•œ íŒë‹¨ì„ ë³´ë¥˜í•˜ë„ë¡ í•´ 
> Type Inference ê°€ ì²˜ë¦¬í•˜ë„ë¡ ë¯¸ë£¨ì—ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ Associated Types ëŠ” Protocols ë¥¼ ì •ì˜í•  ë•Œ Types ì— ëŒ€í•œ íŒë‹¨ì„ 
> ë³´ë¥˜í•˜ë„ë¡ í•œë‹¤.
> 
> ë§Œì•½, Generic Types ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ `n`ê°œì˜ Types ì— ëŒ€í•œ Structures ë¥¼ ìœ„í•´ 
> `n ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ Structures ë¥¼ ì •ì˜`í•´ì•„í•œë‹¤.  
> ë§ˆì°¬ê°€ì§€ë¡œ, Associated Types ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ã„·ë©´ `n`ê°œì˜ Types ì— ëŒ€í•œ Protocols ë¥¼ ìœ„í•´ 
> `n ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ Protocols ë¥¼ ì •ì˜`í•´ì•¼í•œë‹¤.  
> ì¦‰, 3ê°€ì§€ Types ë¥¼ ì •ì˜í•˜ê³ ì í•  ê²½ìš° `n + n`ê°œê°€ í•„ìš”í•˜ë¯€ë¡œ `6ê°œì˜ ì •ì˜ì™€ 3ë²ˆì˜ Protocols ì±„íƒê³¼ ì¤€ìˆ˜`ê°€ í•„ìš”í•˜ë‹¤.
> 
> Generic Types ì™€ Associated Types ëŠ” ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê³  ì½”ë“œë¥¼ ìœ ì—°í•˜ê²Œ ë§Œë“ ë‹¤.

#### 2. Associated Type Syntax

```swift
protocol SomeProtocol {
    associatedtype Item
    // protocol body goes here
}
```

ìœ„ì—ì„œ `Item`ì€ [Type Parameter][Type Parameter] ì˜ `Dictionary<Key, Value>`, `Array<Element>`, `<T>`ì™€ ê°™ì´ 
Protocol ì„ ì •ì˜í•  ë•Œ ì‚¬ìš©í•  *ì´ë¦„ì„ ì œê³µ*í•˜ëŠ” ë°˜ë©´ *Type ì€ ì‹¤ì œ ì±„íƒë  ë•Œ ì •í•´ì§€ë„ë¡ íŒë‹¨ì„ ë¯¸ë£¬ë‹¤*.

ë”°ë¼ì„œ Associated Types ì—­ì‹œ Generic Types ì™€ ë§ˆì°¬ê°€ì§€ë¡œ

```swift
protocol IntContainer {
    mutating func append(_ item: Int)
    var count: Int { get }
    subscript(i: Int) -> Int { get }
}

protocol StringContainer {
    mutating func append(_ item: String)
    var count: Int { get }
    subscript(i: Int) -> String { get }
}
```

<span id="simpleContainer">ì™€ ê°™ì€ ë¬¸ì œë¥¼ í•´ê²°í•´ <span style="color: red;">í•˜ë‚˜ì˜ ì •ì˜ë¡œ ì¬ì‚¬ìš©</span> í•  ìˆ˜ ìˆê²Œ í•œë‹¤.<span>

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

#### 3. Associated Types in Action

ì´ë²ˆì—ëŠ” ìœ„ì—ì„œ ì •ì˜í•œ [Container](#simpleContainer) Protocol ì„ ì‹¤ì œë¡œ ì±„íƒí•˜ëŠ” ê²ƒì„ ì‚´í´ë³´ì.
<br>

__1 ) Nongeneric IntStack Type adopts and conforms to the Container Protocol__

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

[Generic Types](#h-1-generic-types) ì—ì„œ ì •ì˜í•œ *Nongeneric IntStack Type* ì— 
[Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ê³  ì¤€ìˆ˜í•˜ë„ë¡ ë§Œë“¤ì–´ë³´ì.

```swift
struct IntStack: Container {
    // original IntStack implementation
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Int {
        items[i]
    }
}
```

> `typealias Item = Int`ëŠ” Swift ì˜ Type Inference ì— ì˜í•´ ìœ ì¶” ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ìƒëµ ê°€ëŠ¥í•˜ë‹¤.

<br>

__2 ) Generic Stack Type adopts and conforms to the Container Protocol__

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

ì´ë²ˆì—ëŠ” [Container](#simpleContainer) Protocol ì„ ìœ„ì—ì„œ ì •ì˜í–ˆë˜ Generic Stack ì— ì±„íƒí•´ë³´ì.

```swift
struct Stack<Element>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }

    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
intStack.push(8)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8])

intStack.append(7)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8, 7])

print(intStack.count)   // 5
print(intStack[3])      // 8


var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.append("dos")
stringStack.push("tres")
stringStack.append("cuatro")

print(stringStack)      // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
print(stringStack[1])   // dos
```

ì´ì œ Stack ì€ Int, String ë‘ íƒ€ì… ëª¨ë‘ì—ì„œ Associated Types ë¥¼ ì´ìš©í•œ Container Protocol ê¹Œì§€ ì¤€ìˆ˜í•œë‹¤.

#### 4. Extending an Existing Type to Specify an Associated Type

[Adding Protocol Conformance with an Extension][Adding Protocol Conformance with an Extension] ì—ì„œ ì„¤ëª…í•œ 
ê²ƒì²˜ëŸ¼ Protocols ì— ì¤€ìˆ˜ì„±(conformance)ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ ê¸°ì¡´ Type ì„ í™•ì¥í•  ìˆ˜ ìˆëŠ”ë° ì´ë•Œ *Associated Types* ê°€ ìˆëŠ” 
Protocols ë¥¼ í¬í•¨í•œë‹¤.

Swift ì˜ `Array`ëŠ” ì´ë¯¸ `append(_:)` method, `count` property, Int index ë¡œ Element ë¥¼ ì¡°íšŒí•˜ëŠ” `[i]` subscript 
ë¥¼ ì œê³µí•œë‹¤. ì´ê²ƒì€ ìœ„ì—ì„œ [Container](#simpleContainer) protocol ì„ í†µí•´ ì í•©ì„±ì„ ì¶”ê°€í•œ ê²ƒê³¼ ì¼ì¹˜í•œë‹¤. 
ì¦‰, [Declaring Protocol Adoption with an Extension][Declaring Protocol Adoption with an Extension] ì—ì„œ 
ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ `Array ì— ì´ë¯¸ ì í•©ì„±ì„ ë§Œì¡±í•˜ëŠ” êµ¬í˜„ì´ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— Extension ì„ ì´ìš©í•´ Protocols ë¥¼ ì±„íƒí•˜ê³  ë¹„ì›Œë‘ëŠ” ê²ƒ ë§Œìœ¼ë¡œ 
Array ì— Container Protocol ì í•©ì„±ì„ ì¶”ê°€`í•  ìˆ˜ ìˆë‹¤.

```swift
var numbers = [1, 2, 5, 7, 8, 14]

numbers.append(99)
print(numbers)          // [1, 2, 5, 7, 8, 14, 99]
print(numbers.count)    // 7
print(numbers[2])       // 5
```

Array ëŠ” ì´ë¯¸ [Container](#simpleContainer) Protocol ì˜ êµ¬í˜„ì„ ì œê³µí•˜ê³ ìˆë‹¤.

```swift
if numbers is any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers do not conform the Container protocol.
```

í•˜ì§€ë§Œ [Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— [Container](#simpleContainer) Protocol 
ì„ ì¤€ìˆ˜í•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.

<br>

Array ë¥¼ í™•ì¥í•´ [Container](#simpleContainer) Protocol ì„ ì±„íƒí•˜ëŠ” ê²ƒ ë§Œìœ¼ë¡œ ì í•©ì„±ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

```swift
extension Array: Container {}

if let _ = numbers as? any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers conforms the Container protocol.
```

#### 5. Adding Constraints to an Associated Type

Protocols ë¥¼ ì±„íƒí•œ Types ì— íŠ¹ì • ìš”êµ¬ ì¡°ê±´ì„ ì¤€ìˆ˜í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ *constraints* ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

__Syntax__

```swift
protocol SomeProtocol {
    associatedtype Item: Equatable
    // protocol body goes here
}
```

<br>

ìš°ì„  Swift ì˜ ê¸°ë³¸ Array Type ì˜ ë™ì‘ì„ ì‚´í´ë³´ì.

```swift
var arrayA = [1, 5, 6]
var arrayB = [1, 5, 6]

print(arrayA == arrayB) // true

var arrayC = ["A", "B", "C"]
var arrayD = ["A", "C", "B"]

print(arrayC == arrayD) // false
```

Array Type ì€ *Equatable* ì„ ì¤€ìˆ˜í•˜ê¸° ë•Œë¬¸ì— ìœ„ì™€ ê°™ì€ ë¹„êµê°€ ê°€ëŠ¥í•˜ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì´ Array ë¥¼ ë‹´ì€ Structure ëŠ” ì–´ë–¨ê¹Œ?

```swift
struct Some<Element> {
    var items: [Element] = []
}
```

![Structure Stored Array](/assets/images/posts/2023-02-23-generics/structure-stored-array.png){: width="800"}

Structure ê°€ ì €ì¥í•˜ê³  ìˆëŠ” Array ëŠ” Equatable ì„ ì¤€ìˆ˜í•˜ë”ë¼ë„ Structure ëŠ” ì´ë¥¼ ì¤€ìˆ˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— Equatable ì„ ì¤€ìˆ˜í•˜ë„ë¡ 
í•´ì•¼í•œë‹¤.

![Structure Conform Equatable](/assets/images/posts/2023-02-23-generics/structure-conform-equatable.png){: width="800"}

Structure ì— Equatable ì„ ì¶”ê°€í–ˆë‹¤. ì´ë¡œì¨ Structure ëŠ” Equatable ì„ ì¤€ìˆ˜í•  ìˆ˜ ìˆì–´ì•¼í•˜ì§€ë§Œ, Element ê°€ ì´ë¯¸ Equatable 
ì„ ì¤€ìˆ˜í•˜ëŠ” Int, Double, String ê°™ì€ Swift ì˜ Basic Types ê°€ ì•„ë‹Œ Generic Types ì´ë¯€ë¡œ, ì´ì— ëŒ€í•œ Equatable ì¤€ìˆ˜ 
ë˜í•œ í•„ìš”í•˜ë‹¤.

```swift
struct Some<Element: Equatable>: Equatable {
    var items: [Element] = []

    static func == (lhs: Some<Element>, rhs: Some<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

ì´ë¡œì¨ ìš°ë¦¬ëŠ” ***Generic Types Element ì— Equatable ì„ ì¤€ìˆ˜***í•˜ë„ë¡ í•˜ê³ , 
***Structure ì—­ì‹œ Equatable ì„ ì¤€ìˆ˜***í•˜ë„ë¡ í•¨ìœ¼ë¡œì¨ `==` operator ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

```swift
var structureA = Some(items: [1, 5, 6])
var structureB = Some(items: [1, 5, 6])

print(structureA == structureB) // true

var structureC = Some(items: ["A", "B", "C"])
var structureD = Some(items: ["A", "C", "B"])

print(structureC == structureD) // false
```

<br>

ì´ë²ˆì—ëŠ” ìœ„ì—ì„œ ì •ì˜í•œ Container Protocol

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

ì˜ <span style="color: red;">**Associated Types** ì— *constraints* ë¥¼ ì¶”ê°€</span>í•´ ë‹¤ìŒê³¼ ê°™ì´ ë°”ê¿”ë³´ì.

```swift
protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

ì´ì œ ì´ Protocol ì„ ì¤€ìˆ˜í•˜ë ¤ë©´ ***Item Type ì€ Equatable ì„ ì¤€ìˆ˜***í•´ì•¼í•œë‹¤. Stack ì´ Container Protocol ì„ 
ì¤€ìˆ˜í•˜ë„ë¡ í•´ë³´ì.

```swift
struct Stack<Element: Equatable>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
    
    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

```swift
var someStack = Stack(items: [3, 2, 5])
var anotherStack = Stack(items: [3, 2, 5])

print(someStack == anotherStack)    // true
```

ì´ë¡œì¨ Container Protocol ì˜ Item ì— Equatable constraints ë¥¼ ì¶”ê°€í•´ ì±„íƒí•˜ëŠ” Types ê°€ ì´ë¥¼ ì¤€ìˆ˜í•˜ë„ë¡ êµ¬í˜„ì„ ê°•ì œí•œë‹¤.

<br>

ì°¸ê³ ë¡œ ìœ„ Container ì¤€ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ Protocols ì±„íƒì„ Extensions ë¡œ ë¶„ë¦¬í•´ ì½”ë“œë¥¼ ë” ëª…í™•íˆ êµ¬ë¶„ì§€ì„ ìˆ˜ ìˆë‹¤.

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }

    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

#### 6. Using a Protocol in Its Associated Typeâ€™s Constraints

Protocols ë¥¼ ì •ì˜í•  ë•Œ ìê¸° ìì‹ ì˜ ì¼ë¶€ë¡œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.

```swift
protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

`SuffixableContainer` Protocol ì€ ë‚´ë¶€ ì •ì˜ì— ìê¸° ìì‹ ì„ í¬í•¨(`Suffix: SuffixableContainer`)í•˜ê³ ìˆë‹¤. ì´ Protocol 
ì—ì„œ `Suffix`ëŠ” 2ê°œì˜ *constraints* ë¥¼ ê°–ê³  ìˆë‹¤.

1. Suffix ëŠ” `SuffixableContainer` protocol ì„ ì¤€ìˆ˜í•´ì•¼í•œë‹¤.
2. Suffix ì˜ `Item` type ì€ `Container's Item` type ê³¼ ë™ì¼í•´ì•¼í•œë‹¤

> ì—¬ê¸°ì„œ ì£¼ì˜í•´ì•¼ í•  ê²ƒì´ `Suffix.Item == Item`ì´ **Item ì˜ ê°’ì´ ê°™ìŒì„ ì˜ë¯¸í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ëŠ” ê²ƒ**ì´ë‹¤. ì´ê²ƒì€ ì–´ë””ê¹Œì§€ë‚˜ 
> `associatedtype`ì„ ì •ì˜í•˜ëŠ” ê²ƒì´ë¯€ë¡œ `Type ì˜ ì¼ì¹˜`ë¥¼ ì˜ë¯¸í•œë‹¤.

Item ì— ëŒ€í•œ *constraints* ëŠ” ì•„ë˜ [Associated Types with a Generic Where Clause](#h-4-associated-types-with-a-generic-where-clause) 
ì—ì„œ ì„¤ëª…í•  *Generic where* clause ë‹¤.

<br>

SuffixableContainer ë¥¼ ì±„íƒí•˜ë„ë¡ Stack ì„ í•œ ë²ˆ ë” í™•ì¥í•´ë³´ì.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> some SuffixableContainer {
        // code
    }
    func last() -> (some SuffixableContainer).Item {
        // code
    }
}
```

> `func suffix(_ size: Int) -> Suffix`ì˜ **return type** ì€ `some SuffixableContainer` ì¦‰, ì´ Protocol ì˜ 
> ì¼ë¶€ì—¬ì•¼í•œë‹¤.  
> `func last() -> Suffix.Item`ì˜ **return type** ì€ `(some SuffixableContainer).Item` ì¦‰, ì´ Protocol ì˜ 
> ì¼ë¶€ì˜ Item ì´ì–´ì•¼í•œë‹¤.
> 
> ê·¸ë¦¬ê³  `Container Protocol ê³¼ ì´ê²ƒì„ ì±„íƒí•œ Stack<Element> ì˜ ê´€ê³„`ë¥¼ ë³´ì.
> 
> `Container Type ì€ ê³§ ì´ê²ƒì„ ì¤€ìˆ˜í•˜ëŠ” Stack<Element>: Container Type ì„ ì˜ë¯¸`í•˜ê³ ,   
> `Item ì€ Element Type ì„ ì˜ë¯¸`í•œë‹¤.
> 
> ë”°ë¼ì„œ `SuffixableContainer ì˜ Type ì€ ê³§ Stack<Element>: Container, SuffixableContainer Type ì„ ì˜ë¯¸`í•˜ê³ ,  
> `Suffix.Item ì€ Element Type ì„ ì˜ë¯¸`í•œë‹¤.

ì´ì œ í™•ì¥ì„ ì´ìš©í•´ Stack ì´ ì´ë¥¼ ì¤€ìˆ˜í•˜ë„ë¡ `Default Implementations`ë¥¼ ì‘ì„±í•´ ì™„ì„±ì‹œì¼œë³´ì.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

```swift
var someStack = Stack<Int>()
someStack.push(3)
someStack.append(5)
someStack.push(7)
someStack.append(9)

print(someStack.suffix(2))  // Stack<Int>(items: [7, 9])
print(someStack.last())     // 9
```

---

### 6. Generic Where Clauses ğŸ‘©â€ğŸ’»

#### 1. Generic Where Clauses

#### 2. Extensions with a Generic Where Clause

#### 3. Contextual Where Clauses

#### 4. Associated Types with a Generic Where Clause

#### 5. Generic Subscripts



<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics)

[Type Parameter]:#h-3-type-parameters-t
[Adding Protocol Conformance with an Extension]:/swift/2023/02/20/protocols.html#h-5-adding-protocol-conformance-with-an-extension-
[Declaring Protocol Adoption with an Extension]:/swift/2023/02/20/protocols.html#h-4-declaring-protocol-adoption-with-an-extension
