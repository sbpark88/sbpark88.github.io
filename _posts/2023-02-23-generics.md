---
layout: post
title: Swift Generics
subtitle: Write code that works for multiple types and specify requirements for those types. Make more flexible and stronger! 
categories: swift
tags: [swift docs, generics, generic function, generic type parameter, generic naming type parameter, generic type, generic extension, type constraints, associated type, generic where]
---

### 1. Generics 👩‍💻

#### 1. Generics

`Generic code`는 정의한 요구사항에 맞는 모든 타입에서 동작할 수 있는 유연하고 재사용 가능한 함수와 타입을 작성할 수 있다.

*Generic* 은 Swift 의 강력한 특징 중 하나로 대부분의 `Swift stardard library`는 *Generic code* 로 작성되었다. 
예를 들어 Swift 의 *Array* 와 *Dictionary* Types 는 `Generic Collections`다. Array 를 이용해 우리는 
Int 를 저장할 수도 있고, String 을 저장할 수도 있고, Swift 에서 생성될 수 있는 모든 Type 을 저장할 수 있다.

#### 2. The Problem That Generics Solve

```swift
func swap(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

위 `swap(_:_:)` 함수는 `(Int, Int) -> Void` Type 의 `Standard Function`으로 `Nongeneric Function`으로 
두 값을 바꾸는 일을 수행한다.

```swift
var someInt = 3
var anotherInt = 107

swap(&someInt, &anotherInt)

print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
```

```console
someInt is now 107, and anotherInt is now 3
```

이 함수는 오직 `Int`일 때만 동작한다. 만약, `Double` 또는 `String`일 때 동일한 동작이 필요하다면 우리는 다음과 같이 함수를 추가해야한다.

```swift
func swap(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swap(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

```swift
var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

3개의 함수는 모두 동일한 로직을 수행한다. 오직 다른 것은 `Type` 뿐이다. 만약 또 다른 Types 에 대해 값을 바꾸는 로직이 필요하다면, 
Types 의 수만큼 함수를 게속 만들어야한다. 😱😱😱

---

### 2. Generic Functions 👩‍💻

#### 1. Generic Functions

*Generic Functions* 를 사용하면 위 문제를 `모든 타입에서 동작(work with any type)`할 수 있도록 해 문제를 해결할 수 있다.

```swift
func swap<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

*Generic Functions* 를 이용해 `(Int, Int) -> Void`, `(Double, Double) -> Void`, `(String, String) -> Void` 
Types 를 갖는 3개의 `swap(_:_:)` 함수를 하나로 만들었다. 만약, 다른 Types 의 버전이 또 존재했다면, 이 *Generic Function* 은 
수없이 많은 함수의 *Overloading* 을 처리했을 것이다.

#### 2. Placeholder Type `T`

```swift
func swap(_ a: inout Int, _ b: inout Int)
func swap<T>(_ a: inout T, _ b: inout T)
```

*Generic Function* 와 *Nongeneric Function* 를 비교해보자.

- swap<T> : Swift 에게 이 `swap` 함수 정의에서 `T`가 `Placeholder Type`이라고 알린다. 이 `<T>`가 바로 다음에 설명하게 될 
            [Type Parameters](#h-3-type-parameters-t) 다.
- (_ a: inout T, _ b: inout T) : 함수의 Parameters 가 `T`라는 `Placeholder Type`으로 정의된다.

이 `T`라는 Type 은 Swift 내에 존재하지 않는다. 이것은 미리 정의되지 않은 함수가 호출될 때 `Type Inference`에 의해 Type 이 
정의됨을 의미한다.

따라서 *Generic Function* `swap(_:_:)`은 위에서 정의한 Int, Double, String 3가지 타입에 대해 모두 동작한다.

```swift
var someInt = 3
var anotherInt = 107
swap(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")

var someDouble = 6.2
var anotherDouble = 20.2
swap(&someDouble, &anotherDouble)
print("someDouble is now \(someDouble), and anotherDouble is now \(anotherDouble)")

var someString = "Apple"
var anotherString = "Pear"
swap(&someString, &anotherString)
print("someString is now '\(someString)', and anotherString is now '\(anotherString)'")
```

```console
someInt is now 107, and anotherInt is now 3
someDouble is now 20.2, and anotherDouble is now 6.2
someString is now 'Pear', and anotherString is now 'Apple'
```

> 위에서 정의한 Generic Function `swap(_:_:)`은 사실 `Swift stardard library`에 이미 built-in 된 함수로 
> 별도의 구현 없이 바로 사용할 수 있다.

#### 3. Type Parameters `<T>`

위 `swap(_:_:)`에서 *Placeholder Type* `T`는 `Type Parameters`의 한가지 예시를 보여준다. *Type Parameters* 는 함수의 
이름 뒤에 위치하며 `<T>`와 같이 *angle brackets* `< >`로 감싸 정의한다.

*Type Parameters* 를 정의하면, 함수의 정의에서 *Parameters* 에 이것을 *Placeholder Type* 으로 사용할 수 있게 한다. 
바로 `(_ a: inout T, _ b: inout T)` 부분이다. `Type Parameter <T> 를 정의`했기 때문에 함수 정의에서 *Parameters* 
`a`, `b`에 `Type Parameter T 를 Placeholder Type 으로 사용`할 수 있는 것이다.

#### 4. Naming Type Parameters

위에서는 Type Parameters 의 이름으로 `T`를 사용했지만 이것은 반드시 `T`를 쓰도록 정해진 것은 아니다. 다만 의도를 내치비기 위해 보통 
다음과 같이 정의한다.

- 구분되는 관계가 있는 경우 : `Dictionary<Key, Value>`, `<Key, Value>`, `<K, V>`, `Array<Element>`, `<E>`와 같이 
                        이름을 통해 관계를 유추할 수 있도록 사용한다.
- 별다른 관계가 없는 경우 : 정해진 규칙은 없지만 전통적으로 `T`, `U`, `V`와 같은 단일 대문자를 사용하는 것이 일반적이다.

> **Type Parameters** 를 정의할 때는 이것이 `Placeholder Type 으로 사용`된다는 것을 나타내기 위해 `Upper Camel Case`를 
> 사용한다. (i.e. T, U, Key, Value, MyTypeParameter)

---

### 3. Generic Types 👩‍💻

#### 1. Generic types

Swift 의 *Array* 와 *Dictionary* Types 는 `Generic Collections`라고 설명했다. 이렇듯 Swift 는 `Generic Functions` 
외에도 `Generic Types`를 정의할 수 있으며, *Array*, *Dictionary* 와 유사하게 모든 타입에서 동작할 수 있는 *Custom Classes, 
Structures, Enumerations* 다.

<br>

`Stack` 은 `Pushing`과 `Popping`을 통해 동작하며 `LIFO` 로 동작한다. 이 *Stack* 을 이용해 *Generic Types* 를 설명한다. 

> Stack 개념은  **Navigation Hierarchy** 에서 **View Controllers** 를 모델링 하는 `UINavigationController` class 에 
> 의해 사용된다. **UINavigationController** Class 에서 Navigation Stack 에 **View Controller** 를 추가하거나 제거하기 
> 위해 `pushViewController(_:animated:)` 메서드와 `popViewControllerAnimated(_:)` 메서드를 호출하며, 이것은 Stack 구조로 
> `LIFO` 접근 방식을 사용한다.

![Stack 1](/assets/images/posts/2023-02-23-generics/stackPushPop~dark@2x.png){: width="800"}

이것을 코드로 표현해보면 다음과 같다.

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

```swift
var intStack = IntStack(items: [3, 2, 5])
print(intStack) // IntStack(items: [3, 2, 5])

intStack.push(8)
print(intStack) // IntStack(items: [3, 2, 5, 8])

intStack.pop()
print(intStack) // IntStack(items: [3, 2, 5])
```

<br>

만약 String 을 저장하는 *Stack* 을 만들려면 또 다른 Stack 을 추가해야한다. 게다가 *Overloading* 이 되는 메서드와 달리 매번 
생성하는 Stack Structure 의 이름도 다르게 해줘야한다.

```swift
struct StringStack {
    var items: [String] = []
    mutating func push(_ item: String) {
        items.append(item)
    }
    mutating func pop() -> String {
        items.removeLast()
    }
}
```

우리는 이 문제를 `Generic Types 를 이용해 해결`할 수 있다.

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
print(intStack)             // Stack<Int>(items: [3, 2, 5])

intStack.push(8)
print(intStack)             // Stack<Int>(items: [3, 2, 5, 8])

intStack.pop()
print(intStack)             // Stack<Int>(items: [3, 2, 5])
```

<br>
위 Stack 을 이번엔 String 을 저장하는데 사용해보자.

![Stack 2](/assets/images/posts/2023-02-23-generics/stackPushedFourStrings~dark@2x.png){: width="800"}

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

![Stack 3](/assets/images/posts/2023-02-23-generics/stackPoppedOneString~dark@2x.png){: width="480"}

```swift
print(stringStack.pop())    // cuatro
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres"])
```

#### 2. Extending a Generic Type

*Generic Type* 을 확장할 때는 다른 Types 를 확장할 때와 마찬가지로 정의할 때 *Type* 을 정의하지 않는다. 따라서 `Extension`은 
별도의 정의 없이 `Original Type Parameters`를 그대로 사용한다.

위 Stack 을 확장해 *Element* 를 제거하지 않고 가장 마지막 *Element* 를 반환하는 *Read-Only Computed Properties* 를 
추가해보자.

```swift
extension Stack {
    var topItem: Element? {
        items.last
    }
}
```

```swift
var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.push("dos")
stringStack.push("tres")
stringStack.push("cuatro")
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])

if let topItem = stringStack.topItem {
    print(topItem)          // cuatro
}
print(stringStack)          // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
```

---

### 4. Type Constraints 👩‍💻

#### 1. Type Constraints

위에서 정의한 [`swap(_:_:)`](#h-1-generic-functions) 함수와 [Stack](#h-1-generic-types) 은 모든 타입에서 동작한다. 
하지만 때로는 Generic 으로 사용할 수 있는 Types 에 `type constraints`를 강제하는 것이 유용할 수 있다. *Type constraints* 는 
`Type Parameters 가 특정 Class 를 상속하거나 Protocol 을 준수해야함`을 지정한다.

예를 들어 *Dictionary* Type 은 `Key 의 Type 은 Hashable 을 준수`하는 것으로 제한한다. 그래야만 특정 키에 값이 이미 포함되어 있는지 확인 
후 삽입할지 대체할지 판단할 수 있기 때문이다(Swift 의 모든 기본 타입 *String, Int, Double, Bool* 은 모두 *Hashable* 을 준수한다).

따라서 사용자는 사용자 정의 Generic Types 를 정의할 때 *constraints* 를 제공하는 것은 *Generic Programming* 을 더욱 강력하게 한다. 
예를 들어 Hashable 과 같은 추상적 개념을 사용하는 것은 구체적인 유형이 아닌 개념적 특성에서 Type 의 특성을 강화한다.

#### 2. Type Constraint Syntax

```swift
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // function body goes here
}
```

위 함수는 2개의 `Type Parameters`를 갖는다. `T 는 SomeClass 의 Subclass`이어야하고, `U 는 SomeProtocol 을 준수`해야한다는 
*constraints* 를 추가한다.

#### 3. Type Constraints in Action

__1 ) Nongeneric Function__

다음은 찾아야 할 `String`과 찾아야 하는 대상 `[String]`을 받는 `findIndex(ofString:in:)`이라는 *Nongeneric Function* 이다.

```swift
func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]

if let dogIndex = findIndex(ofString: "dog", in: strings) {
    print("The index of dog is \(dogIndex).")
} else {
    print("The dog is not in the array.")
}

if let bearIndex = findIndex(ofString: "bear", in: strings) {
    print("The index of bear is \(bearIndex).")
} else {
    print("The bear is not in the array.")
}
```

```console
The index of dog is 1.
The bear is not in the array.
```

<br>

__2 ) Generic Function__

이제 이 함수를 *Generic Function* 으로 바꿔보자.

![Generic Function Define Error](/assets/images/posts/2023-02-23-generics/generic-function-define-error.png){: width="800"}

예상과 달리 *compile-error* 가 발생한다. `==` operator 를 사용하기 위해서는 [Equatable](l#h-1-synthesized-implementation-of-equatable) 
을 만족해야 하기 때문이다.

따라서 우리는 ***Type Parameter `<T>`에 Equatable Protocol 을 준수(confirm)하는 것으로 `constraints`를 추가***해 
문제를 해결할 수 있다.

```swift
func findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

```swift
if let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25]) {
    print("The index of 9.3 is \(doubleIndex).")
} else {
    print("The 9.3 is not in the array.")
}

if let stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"]) {
    print("The index of Andrea is \(stringIndex).")
} else {
    print("Andrea is not in the array.")
}
```

```console
The 9.3 is not in the array.
The index of Andrea is 2.
```

---

### 5. Associated Types 👩‍💻

#### 1. Associated Types

Protocol 을 정의할 때 때로는 `Associated Type`을 사용하는 것이 유용할 때가 있다. *Associated Type* 은 `Protocol 에서 
사용될 Type 의 이름을 제공`한다. 반면 `실제 Type 은 Protocol 이 채택될 때 정해진다`는 점에서 
[Type Parameter][Type Parameter] 를 이용해 Generic Types 를 정의하는 것과 유사하다.

> Generic Types 는 Functions 나 Classes, Structures, Enumerations 에서 Types 에 대한 판단을 보류하도록 해 
> Type Inference 가 처리하도록 미루었다. 마찬가지로 Associated Types 는 Protocols 를 정의할 때 Types 에 대한 판단을 
> 보류하도록 한다.
> 
> 만약, Generic Types 를 사용하지 않는다면 `n`개의 Types 에 대한 Structures 를 위해 
> `n 개의 서로 다른 Structures 를 정의`해아한다.  
> 마찬가지로, Associated Types 를 사용하지 않는ㄷ면 `n`개의 Types 에 대한 Protocols 를 위해 
> `n 개의 서로 다른 Protocols 를 정의`해야한다.  
> 즉, 3가지 Types 를 정의하고자 할 경우 `n + n`개가 필요하므로 `6개의 정의와 3번의 Protocols 채택과 준수`가 필요하다.
> 
> Generic Types 와 Associated Types 는 이런 문제를 해결하고 코드를 유연하게 만든다.

#### 2. Associated Type Syntax

```swift
protocol SomeProtocol {
    associatedtype Item
    // protocol body goes here
}
```

위에서 `Item`은 [Type Parameter][Type Parameter] 의 `Dictionary<Key, Value>`, `Array<Element>`, `<T>`와 같이 
Protocol 을 정의할 때 사용할 *이름을 제공*하는 반면 *Type 은 실제 채택될 때 정해지도록 판단을 미룬다*.

따라서 Associated Types 역시 Generic Types 와 마찬가지로

```swift
protocol IntContainer {
    mutating func append(_ item: Int)
    var count: Int { get }
    subscript(i: Int) -> Int { get }
}

protocol StringContainer {
    mutating func append(_ item: String)
    var count: Int { get }
    subscript(i: Int) -> String { get }
}
```

<span id="simpleContainer">와 같은 문제를 해결해 <span style="color: red;">하나의 정의로 재사용</span> 할 수 있게 한다.<span>

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

#### 3. Associated Types in Action

이번에는 위에서 정의한 [Container](#simpleContainer) Protocol 을 실제로 채택하는 것을 살펴보자.
<br>

__1 ) Nongeneric IntStack Type adopts and conforms to the Container Protocol__

```swift
struct IntStack {
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
}
```

[Generic Types](#h-1-generic-types) 에서 정의한 *Nongeneric IntStack Type* 에 
[Container](#simpleContainer) Protocol 을 채택하고 준수하도록 만들어보자.

```swift
struct IntStack: Container {
    // original IntStack implementation
    var items: [Int] = []
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    typealias Item = Int
    mutating func append(_ item: Int) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Int {
        items[i]
    }
}
```

> `typealias Item = Int`는 Swift 의 Type Inference 에 의해 유추 가능하기 때문에 생략 가능하다.

<br>

__2 ) Generic Stack Type adopts and conforms to the Container Protocol__

```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}
```

이번에는 [Container](#simpleContainer) Protocol 을 위에서 정의했던 Generic Stack 에 채택해보자.

```swift
struct Stack<Element>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }

    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
}
```

```swift
var intStack = Stack(items: [3, 2, 5])
intStack.push(8)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8])

intStack.append(7)
print(intStack)         // Stack<Int>(items: [3, 2, 5, 8, 7])

print(intStack.count)   // 5
print(intStack[3])      // 8


var stringStack = Stack<String>()
stringStack.push("uno")
stringStack.append("dos")
stringStack.push("tres")
stringStack.append("cuatro")

print(stringStack)      // Stack<String>(items: ["uno", "dos", "tres", "cuatro"])
print(stringStack[1])   // dos
```

이제 Stack 은 Int, String 두 타입 모두에서 Associated Types 를 이용한 Container Protocol 까지 준수한다.

#### 4. Extending an Existing Type to Specify an Associated Type

[Adding Protocol Conformance with an Extension][Adding Protocol Conformance with an Extension] 에서 설명한 
것처럼 Protocols 에 준수성(conformance)를 추가하기 위해 기존 Type 을 확장할 수 있는데 이때 *Associated Types* 가 있는 
Protocols 를 포함한다.

Swift 의 `Array`는 이미 `append(_:)` method, `count` property, Int index 로 Element 를 조회하는 `[i]` subscript 
를 제공한다. 이것은 위에서 [Container](#simpleContainer) protocol 을 통해 적합성을 추가한 것과 일치한다. 
즉, [Declaring Protocol Adoption with an Extension][Declaring Protocol Adoption with an Extension] 에서 
설명한 것처럼 `Array 에 이미 적합성을 만족하는 구현이 존재하기 때문에 Extension 을 이용해 Protocols 를 채택하고 비워두는 것 만으로 
Array 에 Container Protocol 적합성을 추가`할 수 있다.

```swift
var numbers = [1, 2, 5, 7, 8, 14]

numbers.append(99)
print(numbers)          // [1, 2, 5, 7, 8, 14, 99]
print(numbers.count)    // 7
print(numbers[2])       // 5
```

Array 는 이미 [Container](#simpleContainer) Protocol 의 구현을 제공하고있다.

```swift
if numbers is any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers do not conform the Container protocol.
```

하지만 [Container](#simpleContainer) Protocol 을 채택하지 않았기 때문에 [Container](#simpleContainer) Protocol 
을 준수하지는 않는다.

<br>

Array 를 확장해 [Container](#simpleContainer) Protocol 을 채택하는 것 만으로 적합성을 추가할 수 있다.

```swift
extension Array: Container {}

if let _ = numbers as? any Container {
    print("numbers conforms the Container protocol.")
} else {
    print("numbers do not conform the Container protocol.")
}
```

```console
numbers conforms the Container protocol.
```

#### 5. Adding Constraints to an Associated Type

Protocols 를 채택한 Types 에 특정 요구 조건을 준수하도록 하기 위해 *constraints* 를 추가할 수 있다.

__Syntax__

```swift
protocol SomeProtocol {
    associatedtype Item: Equatable
    // protocol body goes here
}
```

<br>

우선 Swift 의 기본 Array Type 의 동작을 살펴보자.

```swift
var arrayA = [1, 5, 6]
var arrayB = [1, 5, 6]

print(arrayA == arrayB) // true

var arrayC = ["A", "B", "C"]
var arrayD = ["A", "C", "B"]

print(arrayC == arrayD) // false
```

Array Type 은 *Equatable* 을 준수하기 때문에 위와 같은 비교가 가능하다.

그렇다면 이 Array 를 담은 Structure 는 어떨까?

```swift
struct Some<Element> {
    var items: [Element] = []
}
```

![Structure Stored Array](/assets/images/posts/2023-02-23-generics/structure-stored-array.png){: width="800"}

Structure 가 저장하고 있는 Array 는 Equatable 을 준수하더라도 Structure 는 이를 준수하지 않기 때문에 Equatable 을 준수하도록 
해야한다.

![Structure Conform Equatable](/assets/images/posts/2023-02-23-generics/structure-conform-equatable.png){: width="800"}

Structure 에 Equatable 을 추가했다. 이로써 Structure 는 Equatable 을 준수할 수 있어야하지만, Element 가 이미 Equatable 
을 준수하는 Int, Double, String 같은 Swift 의 Basic Types 가 아닌 Generic Types 이므로, 이에 대한 Equatable 준수 
또한 필요하다.

```swift
struct Some<Element: Equatable>: Equatable {
    var items: [Element] = []

    static func == (lhs: Some<Element>, rhs: Some<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

이로써 우리는 ***Generic Types Element 에 Equatable 을 준수***하도록 하고, 
***Structure 역시 Equatable 을 준수***하도록 함으로써 `==` operator 를 사용할 수 있게 된다.

```swift
var structureA = Some(items: [1, 5, 6])
var structureB = Some(items: [1, 5, 6])

print(structureA == structureB) // true

var structureC = Some(items: ["A", "B", "C"])
var structureD = Some(items: ["A", "C", "B"])

print(structureC == structureD) // false
```

<br>

이번에는 위에서 정의한 Container Protocol

```swift
protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

의 <span style="color: red;">**Associated Types** 에 *constraints* 를 추가</span>해 다음과 같이 바꿔보자.

```swift
protocol Container {
    associatedtype Item: Equatable
    mutating func append(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}
```

이제 이 Protocol 을 준수하려면 ***Item Type 은 Equatable 을 준수***해야한다. Stack 이 Container Protocol 을 
준수하도록 해보자.

```swift
struct Stack<Element: Equatable>: Container {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
    
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }
    
    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

```swift
var someStack = Stack(items: [3, 2, 5])
var anotherStack = Stack(items: [3, 2, 5])

print(someStack == anotherStack)    // true
```

이로써 Container Protocol 의 Item 에 Equatable constraints 를 추가해 채택하는 Types 가 이를 준수하도록 구현을 강제한다.

<br>

참고로 위 Container 준수는 다음과 같이 Protocols 채택을 Extensions 로 분리해 코드를 더 명확히 구분지을 수 있다.

```swift
struct Stack<Element: Equatable> {
    // original Stack<Element> implementation
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        items.removeLast()
    }
}

extension Stack: Container {
    // conformance to the Container protocol
    mutating func append(_ item: Element) {
        self.push(item)
    }
    var count: Int {
        items.count
    }
    subscript(i: Int) -> Element {
        items[i]
    }

    // conformance to the Equatable protocol
    static func == (lhs: Stack<Element>, rhs: Stack<Element>) -> Bool {
        lhs.items == rhs.items
    }
}
```

#### 6. Using a Protocol in Its Associated Type’s Constraints

Protocols 를 정의할 때 자기 자신의 일부로 존재할 수 있다.

```swift
protocol SuffixableContainer: Container {
    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item
    func suffix(_ size: Int) -> Suffix
    func last() -> Suffix.Item
}
```

`SuffixableContainer` Protocol 은 내부 정의에 자기 자신을 포함(`Suffix: SuffixableContainer`)하고있다. 이 Protocol 
에서 `Suffix`는 2개의 *constraints* 를 갖고 있다.

1. Suffix 는 `SuffixableContainer` protocol 을 준수해야한다.
2. Suffix 의 `Item` type 은 `Container's Item` type 과 동일해야한다

> 여기서 주의해야 할 것이 `Suffix.Item == Item`이 **Item 의 값이 같음을 의미하는 것이 아니라는 것**이다. 이것은 어디까지나 
> `associatedtype`을 정의하는 것이므로 `Type 의 일치`를 의미한다.

Item 에 대한 *constraints* 는 아래 [Associated Types with a Generic Where Clause](#h-4-associated-types-with-a-generic-where-clause) 
에서 설명할 *Generic where* clause 다.

<br>

SuffixableContainer 를 채택하도록 Stack 을 한 번 더 확장해보자.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> some SuffixableContainer {
        // code
    }
    func last() -> (some SuffixableContainer).Item {
        // code
    }
}
```

> `func suffix(_ size: Int) -> Suffix`의 **return type** 은 `some SuffixableContainer` 즉, 이 Protocol 의 
> 일부여야한다.  
> `func last() -> Suffix.Item`의 **return type** 은 `(some SuffixableContainer).Item` 즉, 이 Protocol 의 
> 일부의 Item 이어야한다.
> 
> 그리고 `Container Protocol 과 이것을 채택한 Stack<Element> 의 관계`를 보자.
> 
> `Container Type 은 곧 이것을 준수하는 Stack<Element>: Container Type 을 의미`하고,   
> `Item 은 Element Type 을 의미`한다.
> 
> 따라서 `SuffixableContainer 의 Type 은 곧 Stack<Element>: Container, SuffixableContainer Type 을 의미`하고,  
> `Suffix.Item 은 Element Type 을 의미`한다.

이제 확장을 이용해 Stack 이 이를 준수하도록 `Default Implementations`를 작성해 완성시켜보자.

```swift
extension Stack: SuffixableContainer {
    func suffix(_ size: Int) -> Stack<Element> {
        var result = Stack()
        for index in (count - size)..<count {
            result.append(self[index])
        }
        return result
    }
    func last() -> Element {
        self[count - 1]
    }
    // Inferred that Suffix is Stack.
}
```

```swift
var someStack = Stack<Int>()
someStack.push(3)
someStack.append(5)
someStack.push(7)
someStack.append(9)

print(someStack.suffix(2))  // Stack<Int>(items: [7, 9])
print(someStack.last())     // 9
```

---

### 6. Generic Where Clauses 👩‍💻

#### 1. Generic Where Clauses

#### 2. Extensions with a Generic Where Clause

#### 3. Contextual Where Clauses

#### 4. Associated Types with a Generic Where Clause

#### 5. Generic Subscripts



<br><br>

---
Reference

1. "Generics." The Swift Programming Language Swift 5.7. accessed Feb. 23, 2023, [Swift Docs Chapter 22 - Generics](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics)

[Type Parameter]:#h-3-type-parameters-t
[Adding Protocol Conformance with an Extension]:/swift/2023/02/20/protocols.html#h-5-adding-protocol-conformance-with-an-extension-
[Declaring Protocol Adoption with an Extension]:/swift/2023/02/20/protocols.html#h-4-declaring-protocol-adoption-with-an-extension
