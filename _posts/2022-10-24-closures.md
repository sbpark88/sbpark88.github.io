---
layout: post
title: Swift Closures
subtitle: Closures - Closure Expressions, Trailing Closures, Capturing Values, Escaping Closures, Autoclosures, Lambda
categories: swift
tags: [swift docs, closure, closure expression, trailing closure, capturing value, escaping closure, autoclosure, lambda]
---

### 1. Closure Expressions ğŸ‘©â€ğŸ’»

Swift ì˜ `Closures`ëŠ” ì •ì˜ëœ `context(or scope)`ì— ìƒìˆ˜ë‚˜ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•˜ê³  ì €ì¥í•  ìˆ˜ ìˆë‹¤. 
ì´ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ `Lambda expressions`ì™€ ë¹„ìŠ·í•˜ë‹¤.

__1 ) *Closures* ëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¥¼ ê°–ëŠ”ë‹¤__

- Global Functions : <span style="color: orange;">ì´ë¦„ì´ ìˆê³ </span>, 
                     ì–´ë–¤ ê°’ë„ <span style="color: red;">ìº¡ì²˜í•˜ì§€ ì•ŠëŠ”</span> *Closures* 
- Nested Functions : <span style="color: orange;">ì´ë¦„ì´ ìˆê³ </span>, ìì‹ ì´ ì†í•œ `function context`ì˜ ê°’ì„ 
                     <span style="color: orange;">ìº¡ì²˜í•  ìˆ˜ ìˆëŠ”</span> *Closures* 
- Closure Expressions : <span style="color: red;">ì´ë¦„ì´ ì—†ê³ </span>, ìì‹ ì´ ì†í•œ `context`ì˜ ê°’ì„ 
                        <span style="color: orange;">ìº¡ì²˜í•  ìˆ˜ ìˆëŠ”</span> ê²½ëŸ‰í™”ëœ *Closures* 

__2 ) Swift *Closures* ìµœì í™”ê°€ ê°–ëŠ” íŠ¹ì§•__

- `context`ë¡œë¶€í„° *parameter* ì™€ *return value* ë¥¼ `ì¶”ë¡ (inferring)`í•œë‹¤
- ë‹¨ì¼ í‘œí˜„ í´ë¡œì €(single-expression closures)ì—ì„œ ì•”ì‹œì  ë°˜í™˜ `implicit returns`
- ì¶•ì•½ëœ ì¸ì ì´ë¦„ `shorthand argument names`
- í›„ìœ„ í´ë¡œì € ë¬¸ë²• `trailing closure syntax`

> `Closure Expressions`ëŠ” ì´ë¦„ì´ ì—†ìœ¼ë‚˜ ê²½ëŸ‰í™”ëœ ë¬¸ë²•ìœ¼ë¡œ ì¬ì‚¬ìš© ë˜ì§€ ì•ŠëŠ” í•¨ìˆ˜, ì£¼ë¡œ `Nested Functions`ë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

#### 1. The Sorted Method

`sorted(by:)` ë©”ì„œë“œëŠ”, `Comparable` í”„ë¡œí† ì½œì„ ë”°ë¥´ëŠ” íƒ€ì…ì— ëŒ€í•´ `(Type, Type) -> Bool` íƒ€ì…ì˜ *Closures* ë¥¼ 
*arguments* ë¡œ ë°›ì•„ ì •ë ¬ì„ ìˆ˜í–‰í•œë‹¤. *true* ë©´ ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šê³ , *false* ë©´ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

ì´ë¥¼ ìœ„í•´ `sorted(by:)` ë©”ì„œë“œì— *arguments* ë¡œ ì „ë‹¬í•  *Closures* ë¥¼ ë§Œë“ ë‹¤.

```swift
// ascending order(default)
func forward(_ s1: String, _ s2: String) -> Bool {
    s1 < s2
}

// descending order
func backward(_ s1: String, _ s2: String) -> Bool {
    s1 > s2
}
```

> *arguments* ë¡œ ì „ë‹¬í•  `Global Functions` í˜•íƒœì˜ *Closures* `forware(_:_:)`, `backward(_:_:)`ë¥¼ ë§Œë“¤ì—ˆë‹¤.

```swift
print("origin          : \(names)")
print("default         : \(names.sorted())")
print("ascending order : \(names.sorted(by: forward))")
print("descending order: \(names.sorted(by: backward))")
```

```console
origin          : ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
default         : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
ascending order : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descending order: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### 2. Closure Expression Syntax

__Syntax__

```swift
{ (parameters) -> return type in
    statements
}
```

__Closure Expressions ëŠ” ë‹¤ìŒ íŠ¹ì§•ì„ ê°–ëŠ”ë‹¤__

- `Global Functions`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `In-Out Parameters`, `Variadic Parameters`, `Tuple Type Parameters`, 
  `Tuple Type Return`ì´ í—ˆìš©ëœë‹¤.
- ë‹¨, <span style="color: red;">**Default Values**ëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤</span>.

<br>

ìœ„ ì •ë ¬ì€ `Global Functions` í˜•íƒœì˜ *Closures*  ëŒ€ì‹  `Closure Expressions` í˜•íƒœì˜ *Closures* ë¥¼ ì´ìš©í•˜ë©´ ë”ìš± 
ê°„ê²°í•œ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

```swift
let ascendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 < s2 })
let descendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })

print("ascendingOrderNames : \(ascendingOrderNames)")
print("descendingOrderNames: \(descendingOrderNames)")
```

```console
ascendingOrderNames : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descendingOrderNames: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### 3. Inferring Type From Context

`Inline-Closures`ëŠ” í•­ìƒ `context`ë¡œë¶€í„° *parameter types* ì™€ *return types* ë¥¼ ì¶”ë¡ (infer)í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ `type` 
ìƒëµì´ ê°€ëŠ¥í•˜ë‹¤.  
(*Global Functions* ì™€ ë‹¬ë¦¬ `-> return types` ë§ˆì €ë„ ìƒëµ ê°€ëŠ¥í•˜ë‹¤)

```swift
// ascending order
names.sorted(by: { s1, s2 in return s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in return s1 > s2 })
```

#### 4. Implicit Return from Single-Expression Closures

í•¨ìˆ˜ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `Single-Expression Closures`ëŠ” `return` í‚¤ì›Œë“œë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤. ì‚¬ì‹¤ *Global Functions* í˜•íƒœì˜ 
*Closures* ê°€ ê°€ëŠ¥í–ˆìœ¼ë‹ˆ *Closure Expressions* í˜•íƒœì˜ *Closures* ì—­ì‹œ ê°€ëŠ¥í•œ ê²ƒì€ ë‹¹ì—°í•˜ë‹¤.

```swift
// ascending order
names.sorted(by: { s1, s2 in s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in s1 > s2 })
```

#### 5. Shorthand Argument Names

*Inline-Closures* ì— `Shorthand Argument Names`ë¥¼ ìë™ìœ¼ë¡œ ì œê³µí•˜ë¯€ë¡œ, *arguments* ë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë©°,
ì´ëŠ” `$0`, `$1`, `$2`ë¡œ í‘œí˜„ëœë‹¤. ë˜í•œ *arguments* ì„ ì–¸ ìì²´ë¥¼ ìƒëµí•˜ë¯€ë¡œ `in` í‚¤ì›Œë“œ ì—­ì‹œ í•„ìš”ê°€ ì—†ì–´ í•¨ê»˜ ìƒëµë˜ì–´ 
*Closures* ëŠ” `body`ë§Œìœ¼ë¡œ êµ¬ì„±ëœë‹¤.

```swift
// ascending order
names.sorted(by: { $0 < $1 })

// descending order
names.sorted(by: { $0 > $1 })
```

#### 6. Operator Methods

`String`ì€ <span style="color: red;">greater-than operator(`>`)</span>ë¥¼ ë©”ì„œë“œë¡œ ê°–ëŠ”ë‹¤.
ë˜í•œ ì´ ë©”ì„œë“œëŠ” ë‘ ê°œì˜ *parameters* ë¥¼ ê°–ê³ , *Bool* ì„ ë°˜í™˜í•œë‹¤. ì¦‰, ìœ„ì—ì„œ `sorted(by:)`ê°€ *Closures* ë¡œ
ë°›ëŠ” ìœ í˜•ê³¼ ì •í™•íˆ ì¼ì¹˜í•œë‹¤. ë”°ë¼ì„œ ì´ ê²½ìš° `Operator`ë§Œ ë‚¨ê¸´ ì±„ *Shorthand Argument Names* ë§ˆì €ë„ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
// ascending order
names.sorted(by: <)

// descending order
names.sorted(by: >)
```

---

### 2. Trailing Closures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ `ë§ˆì§€ë§‰ parameter`ê°€ `Closure`ì´ê³ , ì „ë‹¬ ë˜ëŠ” *argument* ê°€ ê¸´ í‘œí˜„ì‹ì¼ ê²½ìš° `Trailing Closure`ë¥¼ ì´ìš©í•´ 
ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤. *Trailing Closure* ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ê´„í˜¸(`( )`) ë‹¤ìŒì— ì‘ì„±í•˜ì§€ë§Œ ì—¬ì „íˆ í•¨ìˆ˜ì˜ *arguments* ë‹¤.

í•¨ìˆ˜ëŠ” ì—¬ëŸ¬ ê°œì˜ `Trailing Closures`ë¥¼ `arguments`ë¡œ ì…ë ¥ ë°›ì„ ìˆ˜ ìˆìœ¼ë©°, 
`ì²« ë²ˆì§¸ Trailing Closure`ì˜ `argument labels`ëŠ” ìƒëµë  ìˆ˜ ìˆë‹¤ (cf. [Multiple Trailing Closures]).

[Multiple Trailing Closures]:#h-3-a-function-takes-multiple-trailing-closures

#### 1. Trailing Closure Syntax

ì•„ë˜ `someFunctionThatTakesAClosure(closure:)` í•¨ìˆ˜ëŠ” ë§ˆì§€ë§‰ *arguments* ë¥¼ *Closures* ë¡œ ê°–ëŠ” í•¨ìˆ˜ë‹¤.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}
```

<br>

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë³´ì.

__1 ) *Trailing Closures* ì—†ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

í•¨ìˆ˜ì˜ `argument`ë¡œ `Closure`ë¥¼ ì „ë‹¬í•œë‹¤.

```swift
someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})
```

<br>

__2 ) *Trailing Closures* ë¡œ ë¶„ë¦¬í•´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

`ì²« ë²ˆì§¸ Trailing Closure`ì´ë¯€ë¡œ `argument labels`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
```

> ìœ„ `Trailing Closures`ì˜ í˜•íƒœë¥¼ ë³´ë©´ `Global Functions`ì™€ ê°™ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.  
> ì¦‰, `Global Functions`ê°€ *Closures* ì˜ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¼ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

<br>

__3 ) *Trailing Closures* ê°€ í•¨ìˆ˜ì˜ `ìœ ì¼í•œ arguments`ì¼ ë•ŒëŠ” ê´„í˜¸`( )`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤__

```swift
someFunctionThatTakesAClosure {
    // trailing closure's body goes here
}
```

#### 2. Trailing Closure Examples

__1 ) Examples 1: 'sorted(by:)'__

ìœ„ `sorted(by:)`ë¥¼ `Trailing Closures`ë¥¼ ì´ìš©í•´ í˜¸ì¶œí•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let descendingNames = names.sorted { $0 > $1 }

print(descendingNames)  // ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

<br>

*Closures* ë¥¼ ì „ë‹¬í•´ ì‚¬ìš©í•  ë•Œì™€ *Trailing Closures* ë¥¼ ì‚¬ìš©í• ì˜ ì°¨ì´ì„ ë¹„êµí•´ë³´ì.

- Without Trailing Closures

```swift
names.sorted(by: { $0 > $1 } )

// Using Operator Methods
names.sorted(by: >)
```

> **Closure Expressions** ëŠ” **Operator Methods** ë§Œ ë‚¨ê²¨ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

- With Trailing Closures

```swift
names.sorted { $0 > $1 }

// Using Operator Methods
print(names.sorted { > })   // error: unary operator cannot be separated from its operand
```

> í•˜ì§€ë§Œ **Trailing Closure** ì€ **Operator Methods** ë§Œ ë‚¨ê²¨ ìµœì í™” í•  ìˆ˜ ì—†ë‹¤.

<br>

__2 ) Examples 2: 'map(_:)'__

`map(_:)` ë©”ì„œë“œë¥¼ ì´ìš©í•´ ì•„ë˜ ì£¼ì–´ì§„ *digitNames*, *numbers* ë°°ì—´ë¡œë¶€í„° ìƒˆ ë°°ì—´ 
`["OneSix", "FiveEight", "FiveOneZero"]`ì„ ë°˜í™˜í•˜ë„ë¡ *Trailing Closures* ë¥¼ ì´ìš©í•´ `map(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë³´ì.

```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```

```swift
let strings = numbers.map { number -> String in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ìœ„ *Trailing Closures* ì˜ `Return Types`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map { number in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ë§ˆì§€ë§‰ìœ¼ë¡œ, `Shorthand Argument Names`ë¥¼ ì´ìš©í•´ `arguments`ì™€ `in` í‚¤ì›Œë“œ ì—­ì‹œ ìƒëµí•´ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map {
    var number = $0
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

#### 3. A function takes `Multiple Trailing Closures`

ë§Œì•½ í•¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°œì˜ *Trailing Closures* ë¥¼ ê°€ì§ˆ ê²½ìš°, `ì²« ë²ˆì§¸ Trailing Closure`ì˜ `argument labels`ëŠ” ìƒëµë  ìˆ˜ ìˆë‹¤. 
<span style="color: red;">ê·¸ ì™¸ ë‚˜ë¨¸ì§€ *Trailing Closures* ëŠ” *argument labels* ì„ ì§€ì •</span>í•´ì•¼í•œë‹¤.
<br>

ì•„ë˜ `loadPicture(from:completion:onFailure:)` í•¨ìˆ˜ë¥¼ ë³´ì.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```

`loadPicture(from:completion:onFailure:)`ëŠ” 3 ê°œì˜ *arguments* ë¥¼ ê°–ê³  ìˆëŠ”ë°, ì²« ë²ˆì§¸ëŠ” `Server` ê°ì²´, 
ë‘ ë²ˆì§¸ëŠ” `(Picture) -> Void` *Closure*, ì„¸ ë²ˆì¬ëŠ”`() -> Void` *Closure*ë‹¤.

ì´ì¤‘ ë‘ ë²ˆì§¸ *arguments* ì´ì ì²« ë²ˆì§¸ *Closure* ì¸ `completion: (Picture) -> Void`ëŠ” `completion handler`ë¡œ 
ë‹¤ìš´ë¡œë“œê°€ ì„±ê³µí•œ ê²½ìš° ì‚¬ì§„ì„ ë³´ì—¬ì¤„ ê²ƒì´ê³ , ì„¸ ë²ˆì§¸ *arguments* ì´ì ë‘ ë²ˆì§¸ *Closure* ì¸ 
`onFailure: () -> Void`ëŠ” `error handler`ë¡œ ì‚¬ìš©ìì—ê²Œ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŒì„ ì•Œë ¤ì¤„ ê²ƒì´ë‹¤.

ìœ„ í•¨ìˆ˜ë¥¼ ì´ë²ˆì—ëŠ” *Trailing Closures* ë¥¼ ì´ìš©í•´ í˜¸ì¶œí•´ë³´ì.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

> ì²« ë²ˆì§¸ *Trailing Closure* ì¸ `completion: (Picture) -> Void`ëŠ” *argument labels* ë¥¼ ìƒëµí–ˆë‹¤.  
> í•˜ì§€ë§Œ ë‘ ë²ˆì§¸ *Trailing Closure* ì¸ `onFailure: () -> Void`ëŠ” *argument labels* ë¥¼ ìƒëµí•  ìˆ˜ ì—†ì–´ `onFailure`ë¥¼ 
> ëª…ì‹œí–ˆë‹¤.

> `loadPicture(from:completion:onFailure:)`ì™€ ê°™ì´ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë©´, í•˜ë‚˜ì˜ *Closure* ì— `success`, `error`ë¥¼ 
> ì²˜ë¦¬í•˜ëŠ” ì½”ë“œë¥¼ í˜¼ì¬í•˜ì§€ ì•Šê³  `case` ë³„ë¡œ ì½”ë“œë¥¼ ëª…í™•í•˜ê²Œ ë¶„ë¦¬í•  ìˆ˜ ìˆë‹¤.
 
> ìœ„ ê²½ìš°ëŠ” 2ê°œì˜ *completion handlers* ë§Œ ì¡´ì¬í•˜ì§€ë§Œ, ì—¬ëŸ¬ ê°œì˜ *completion handlers* ê°€ ì¤‘ì²©ë˜ë©´ ì½”ë“œë¥¼ ì½ê¸° ì–´ë ¤ì›Œì§„ë‹¤. 
> ì´ëŸ° ê²½ìš° `Concurrency` ì— ì„¤ëª…ëœ ê²ƒì²˜ëŸ¼ [Asynchronous Functions](/swift/2023/01/05/concurrency.html#h-2-asynchronous-functions-) 
> ë¥¼ ì‚¬ìš©í•´ ì´ë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

---

### 3. Capturing Values ğŸ‘©â€ğŸ’»

*Closures* ëŠ” ì •ì˜ë  ë•Œ ì£¼ë³€ *context* ì˜ ìƒìˆ˜ë‚˜ ë³€ìˆ˜, ì¸ìˆ˜ë¥¼ `Capturing`í•´ ì €ì¥í•  ìˆ˜ ìˆë‹¤.    
`Nested Functions`ëŠ” ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœì˜ ê°’ ìº¡ì²˜ë¡œ *context* ë‚´ì˜ ì–´ë– í•œ *constant*, *variables*, *arguments* ë“  
ìº¡ì²˜í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ë³´ì.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

í•¨ìˆ˜ì˜ *body* ë¥¼ ì‚´í´ë³´ë©´, ì•ˆì— ì •ì˜ëœ *Nested Function* ì¸ `incrementer()`ëŠ” ì£¼ë³€ *context* ì—ì„œ ë³€ìˆ˜ 
`runningTotal`ê³¼ íŒŒë¼ë¯¸í„° `amount`ë¥¼ ìº¡ì²˜í•´ `() -> Int` íƒ€ì…ì˜ í•¨ìˆ˜ `incrementer()`ë¥¼ ë§Œë“¤ì–´ ë°˜í™˜í•œë‹¤.

> ì¦‰, `makeIncrementer(forIncrement:)` í•¨ìˆ˜ëŠ” `Int`ë¥¼ *arguments* ë¡œ ë°›ì•„ `() -> Int` íƒ€ì…ì˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.

ë°˜í™˜ëœ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì´ë‹¤.

```swift
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
```

ë°˜í™˜ëœ í•¨ìˆ˜ ì–´ë””ì—ë„ `runningTotal`ê³¼ `amount`ê°€ ì •ì˜ë˜ì–´ìˆì§€ ì•Šì§€ë§Œ ì´ í•¨ìˆ˜ëŠ” ì‘ë™í•œë‹¤.  
ê°’ì„ <span style="color: red;">ìº¡ì²˜</span>í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

ì¦‰, *arguments* ë¥¼ ë°›ì•„ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë‚´ëŠ” í•¨ìˆ˜ë¡œ <span style="color: red;">ì¬ì‚¬ìš©</span>ì´ ê°€ëŠ¥í•˜ë‹¤.

```swift
let incrementByThree = makeIncrementer(forIncrement: 3)
let incrementByFive = makeIncrementer(forIncrement: 5)

print(incrementByThree())   // 3
print(incrementByThree())   // 6
print(incrementByThree())   // 9

print(incrementByFive())    // 5
print(incrementByFive())    // 10

print(incrementByThree())   // 12

print(incrementByFive())    // 15
```

> `incrementByThree()`ì™€ `incrementByFive()`ê°€ ì„œë¡œì—ê²Œ ì˜í–¥ì„ ì£¼ì§€ ì•Šê³  ê°ê° ì‘ë™í•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” 
> ê°’ì„ <span style="color: red;">ìº¡ì²˜</span>í–ˆê¸° ë•Œë¬¸ì´ë‹¤.
>
> Swift ëŠ” ê°’ì„ ìº¡ì²˜í•  ë•ŒëŠ” ë¬¼ë¡ ì´ê³  ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•Šì„ ê²½ìš° ì œê±°í•˜ëŠ” ê²ƒê³¼ ê°™ì€ ëª¨ë“  ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ì•Œì•„ì„œ ì²˜ë¦¬í•œë‹¤.

ë™ì¼í•œ ë¡œì§ì„ *TypeScript* ë¡œ êµ¬í˜„í•œ ì½”ë“œê°€ ì•„ë˜ ìˆë‹¤. *Swift* ì™€ ë¹„êµí•´ë³´ì.

```typescript
const makeIncrementer: (forIncrement: number) => () => number
    = amount => {
    let runningTotal = 0
    const incrementer: () => number
        = () => {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

```typescript
const incrementByThree = makeIncrementer(3)
const incrementByFive = makeIncrementer(5)

console.log(incrementByThree())   // 3
console.log(incrementByThree())   // 6
console.log(incrementByThree())   // 9

console.log(incrementByFive())    // 5
console.log(incrementByFive())    // 10

console.log(incrementByThree())   // 12

console.log(incrementByFive())    // 15
```

<br>

> *Closure* ë¥¼ `Class instance ì˜ Property`ì— í• ë‹¹í•˜ê³ , ê·¸ *Closure* ê°€ ìì‹ ì˜ `instance` ë˜ëŠ” 
> `instance ì˜ members`ë¥¼ ì°¸ì¡°ë¡œ ìº¡ì²˜í•˜ë©´ `Strong Reference Cycle`(ê°•í•œ ìˆœí™˜ ì°¸ì¡°)ê°€ ìƒì„±ëœë‹¤.
>
> ë”°ë¼ì„œ Swift ëŠ” ì´ ìˆœí™˜ì„ ì¤‘ë‹¨ì‹œí‚¤ê¸° ìœ„í•´ `Capture Lists`ë¥¼ ì´ìš©í•œë‹¤. í•´ë‹¹ ë‚´ìš©ì€ ë‹¤ìŒì„ ì°¸ê³ í•œë‹¤. 
> [Strong Reference Cycles for Closures]

[Strong Reference Cycles for Closures]:https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56

---

### 4. Closures Are Reference Types ğŸ‘©â€ğŸ’»

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
let anotherIncrementByTen = makeIncrementer(forIncrement: 10)
let referToIncrementByTen = incrementByTen
```

ìœ„ì—ì„œ `let` í‚¤ì›Œë“œë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ 3ê°œì˜ ìƒìˆ˜ë¥¼ ì„ ì–¸í–ˆë‹¤.

- `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë°˜í™˜ëœ í•¨ìˆ˜ë¥¼ `incrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.
- `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë°˜í™˜ëœ í•¨ìˆ˜ë¥¼ `anotherIncrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.
- `incrementByTen` ìƒìˆ˜ë¥¼ `referToIncrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.

<br>

```swift
print(incrementByTen())         // 10
print(incrementByTen())         // 20
print(incrementByTen())         // 30

print(anotherIncrementByTen())  // 10

print(referToIncrementByTen())  // 40
print(incrementByTen())         // 50
```

ëª¨ë‘ `let` í‚¤ì›Œë“œë¥¼ ì´ìš©í•´ ìƒìˆ˜ë¡œ ì„ ì–¸í–ˆì§€ë§Œ ìº¡ì²˜í•œ ì—¬ì „íˆ `runningTotal` ë³€ìˆ˜ì˜ ê°’ì€ ë³€ê²½ë˜ê³ ìˆë‹¤. __*ì™œ ê·¸ëŸ´ê¹Œ?*__  
`incrementByTen()`ê³¼ `referToIncrementByTen()`ì€ __*ì™œ ê°’ì„ ê³µìœ í• ê¹Œ?*__

> *Functions* ì™€ *Closures* ëŠ” `Reference Types`ì´ë‹¤.
> `let` keyword ë¥¼ ì‚¬ìš©í•´ ìƒìˆ˜ë¡œ ì„ ì–¸ëœê±´ `incrementByTen`, `anotherIncrementByTen`, 
> `referToIncrementByTen` í•¨ìˆ˜ ìì²´ë‹¤. ê·¸ë¦¬ê³  ì´ í•¨ìˆ˜ëŠ” `var` keyword ë¡œ ì„ ì–¸ëœ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•˜ê³  ê°’ì„ ë³€ê²½í•œë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— 
> ë°˜í™˜í•˜ëŠ” ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.

---

### 5. Escaping Closures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ì— *arguments* ë¡œ ì „ë‹¬ëœ `Closures ì˜ í˜¸ì¶œ ì‹œì `ì— ë”°ë¼ ë‘ ê°€ì§€ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.

1. í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ê¸° ì „ì— í˜¸ì¶œ: í•¨ìˆ˜ì˜ `body ë‚´ì—ì„œ í˜¸ì¶œ`ëœë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì „ë‹¬ëœ *Closures* ê°€ í˜¸ì¶œë˜ëŠ” ë°©ì‹ì´ë‹¤.
2. í•¨ìˆ˜ê°€ ì¢…ë£Œëœ í›„ í˜¸ì¶œ: `asynchronous` ì²˜ë¦¬ë¥¼ ì‹œì‘í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ í•¨ìˆ˜ëŠ” *arguments* ë¡œ `completion handler`ë¥¼ ì‚¬ìš©í•œë‹¤. 
   ì´ê²ƒì€ í•¨ìˆ˜ê°€ ì¢…ë£Œëœ í›„ í˜¸ì¶œë˜ë©° `Escaping Closures`ë¼ í•œë‹¤. ì´ë¥¼ ìœ„í•´ í•¨ìˆ˜ë¥¼ ì •ì˜í•  ë•Œ *Parameter Types* ì•ì— 
   `@escaping` í‚¤ì›Œë“œë¥¼ ì‘ì„±í•´ ì „ë‹¬ëœ *Closures* ê°€ `escape` ë  ìˆ˜ ìˆìŒì„ ëª…ì‹œí•´ì•¼í•œë‹¤. 
   ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ *compile-time error* ê°€ ë°œìƒí•œë‹¤.

#### 1. Store in a variable

*Closures* ë¥¼ *escape* ì‹œí‚¤ëŠ” ë°©ë²•ì€ í•¨ìˆ˜ `context ì™¸ë¶€ ë³€ìˆ˜ì— ì €ì¥`í•˜ëŠ” ê²ƒì´ë‹¤.

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: () -> Void) {
    completionHandlers.append(completionHandler)    // error: converting non-escaping parameter 'completionHandler' to generic parameter 'Element' may allow it to escape
}
```

*parameter* ë¡œ ì „ë‹¬ëœ `() -> Void` íƒ€ì…ì˜ `completionHandler`ë¼ëŠ” ì´ë¦„ì˜ *Closures* ë¥¼ í•¨ìˆ˜ 
`context ì™¸ë¶€ ë³€ìˆ˜ì— ì €ì¥`í•˜ë ¤ í•œë‹¤. ì¦‰, í•¨ìˆ˜ì˜ *body* ì™¸ë¶€ë¡œ `escape`ì‹œí‚¤ë ¤ëŠ” í–‰ìœ„ì´ë¯€ë¡œ *Parameter Types* ì•ì— 
`@escaping` í‚¤ì›Œë“œë¥¼ ë°˜ë“œì‹œ ì‘ì„±í•´ì•¼í•œë‹¤. *ìœ„ ê²½ìš° ì´ë¥¼ ëˆ„ë½í•´ **error** ê°€ ë°œìƒ*í–ˆë‹¤.

```swift
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

`@escaping` í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•˜ì ì •ìƒì ìœ¼ë¡œ ë™ì‘í•œë‹¤.

#### 2. Escaping Closures in Classes

*Escaping Closures* ê°€ *Class Instances* ì˜ `self`ë¥¼ ì°¸ì¡°í•˜ëŠ” ê²½ìš° ì£¼ì˜í•´ì•¼í•œë‹¤. *self* ë¥¼ ìº¡ì²˜í•  ê²½ìš° ë„ˆë¬´ë„ ì‰½ê²Œ 
`Strong Reference Cycle`(ê°•í•œ ìˆœí™˜ ì°¸ì¡°)ê°€ ìƒê¸°ê¸° ì‰½ê¸° ë•Œë¬¸ì´ë‹¤. `Reference Cycles`ì— ëŒ€í•´ ì¢€ ë” ìì„¸í•œ ë‚´ìš©ì€ 
[Automatic Reference Counting]ì„ ì°¸ê³ í•œë‹¤.

ë”°ë¼ì„œ *Closures*ëŠ” ì•”ì‹œì `implicit`ìœ¼ë¡œ *Closure* ë‚´ë¶€ ë³€ìˆ˜ë¥¼ ì´ìš©í•´ `ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜`í•˜ì§€ë§Œ, 
`Escaping Closures`ëŠ” `self` í‚¤ì›Œë“œ ì´ìš©í•´ ëª…ì‹œì `explicit`ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•˜ë„ë¡í•œë‹¤. ì´ëŠ” ê°œë°œìì—ê²Œ ìˆœí™˜ ì°¸ì¡°ê°€ ì—†ìŒì„ 
í™•ì¸í•˜ë„ë¡ ìƒê¸°ì‹œí‚¨ë‹¤.

```swift
func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}
```

*Non-Escaping Closures* ë¥¼ í•˜ë‚˜ ë” ì¶”ê°€í•´ ì´ê²ƒì´ `self`ë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ ì–´ë–»ê²Œ ë‹¤ë¥¸ì§€ ì‚´í´ë³´ì.

```swift
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
```

```swift
let instance = SomeClass()
instance.doSomething()      // `someFunctionWithNonescapingClosure` is called in `doSomething` function's body

print(instance.x)   // 200

completionHandlers.first?() // `someFunctionWithEscapingClosure ` is not called in `doSomething()` function's body
print(instance.x)   // 100
```

> 1. **SomeClass** ì˜ **instance** ë¥¼ ìƒì„±í•´ `instance` ì´ë¦„ì˜ ìƒìˆ˜ì— í• ë‹¹í•œë‹¤.
> 2. - `instance`ì˜ `doSomething()`ì„ í˜¸ì¶œí•œë‹¤. ì´ë•Œ `someFunctionWithEscapingClosure(completionHandler:)`ëŠ” 
>       `@escaping () -> Void` íƒ€ì…ì˜ `completionHandler`ë¥¼ ë°›ì•„ `completionHandlers.append(completionHandler)`ë¥¼ 
>       ìˆ˜í–‰í•œë‹¤. ì¦‰, ì „ë‹¬ëœ **closure** ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ì™¸ë¶€ì— ì €ì¥í•œë‹¤.   
>       > `() -> { self.x = 100 }`ì€ ì™¸ë¶€ **completionHandlers** ì— ì €ì¥ëœë‹¤.
>    - ë°˜ë©´ `someFunctionWithNonescapingClosure(closure:))`ëŠ” `() -> Void` íƒ€ì…ì˜ `closure`ë¥¼ ë°›ì•„ `closure()`ë¥¼ 
>      ìˆ˜í–‰í•œë‹¤. ì¦‰, ì „ë‹¬ëœ **closure** ë¥¼ ì¦‰ì‹œ í˜¸ì¶œí•œë‹¤. 
>      > `() => { x = 200 }`ì€ ì¦‰ì‹œ í˜¸ì¶œë˜ì–´ `x`ì— 200ì„ ì €ì¥í•œë‹¤.
> 3. `instnace`ì˜ `x`ë¥¼ ì¶œë ¥í•œë‹¤. `200`ì´ ì¶œë ¥ëœë‹¤. ì´ë¯¸ ìœ„ 2ë²ˆì—ì„œ `someFunctionWithNonescapingClosure(closure:))`ê°€ 
>    í˜¸ì¶œë˜ì–´ **x** ì— **200** ì´ë¼ëŠ” ê°’ì„ ì €ì¥í–ˆê¸° ë•Œë¬¸ì´ë‹¤.
> 4. `completionHandlers.first?()`ë¥¼ í˜¸ì¶œí•œë‹¤. ì•„ê¹Œ `someFunctionWithEscapingClosure(completionHandler:)`ê°€ í˜¸ì¶œë˜ë©° 
>    **completionHandlers** ì— `escaping` ë˜ì–´ ì €ì¥í•œ ì²« ë²ˆì§¸ **closure** ê°€ í˜¸ì¶œë˜ë©° **x** ì— **100** ì„ ì €ì¥í•œë‹¤. 
> 5. `instnace`ì˜ `x`ë¥¼ ì¶œë ¥í•œë‹¤. `100`ì´ ì¶œë ¥ëœë‹¤. ìœ„ 4ë²ˆì—ì„œ **x** ì— ë‹¤ì‹œ **100** ì„ ì €ì¥í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

<br>

ë‹¤ë¥¸ ë²„ì „ì˜ `doSomething()` í•¨ìˆ˜ë¥¼ ë³´ì. ë‹¤ìŒì€ `Escaping Closures`ì—ì„œë„ ë§¤ë²ˆ `self` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì•”ì‹œì ìœ¼ë¡œ 
`self`ë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤.

```swift
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { [self] in x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
```

> `self`ë¥¼ ì°¸ì¡°í•  ì¼ì´ ë§ë‹¤ë©´ `[self]`ë¥¼ ì´ìš©í•´ **implicit** í•˜ë„ë¡ ë§Œë“¤ë©´ í¸ë¦¬í•˜ê² ìœ¼ë‚˜ Swift ì˜ ì˜ë„ëŒ€ë¡œ 
> `self` í‚¤ì›Œë“œë¥¼ í•„ìš”í•œ ê³³ì— ì§ì ‘ ëª…ì‹œí•´ **explicit** í•˜ë„ë¡ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì•ˆì „í•œ ê²ƒ ê°™ë‹¤.

#### 3. Escaping Closures in Structures

*Structures* ë‚˜ *Enumerations* ì˜ *instance* ëŠ” í•­ìƒ `self`ê°€ ì•”ì‹œì `implicit`ì´ë‹¤. ë”°ë¼ì„œ í•¨ìˆ˜ì˜ `parameters`ê°€ 
*Structures* ë‚´ë¶€ì˜ ë‹¤ë¥¸ *Properties* ì™€ ì´ë¦„ì´ ë™ì¼í•˜ì§€ ì•ŠëŠ” í•œ `self`ë¥¼ ëª…ì‹œí•  í•„ìš”ê°€ ì—†ë‹¤.

```swift
struct SomeStruct {
    var x = 10
    mutating func doSomething() {
        someFunctionWithNonescapingClosure { x = 200 }  // Ok
        someFunctionWithEscapingClosure { x = 100 }     // error: escaping closure captures mutating 'self' parameter
    }
}
```

í•˜ì§€ë§Œ ìœ„ì™€ ê°™ì€ ì½”ë“œëŠ” *compile-time error* ê°€ ë°œìƒëœë‹¤. `Value Types`ëŠ” ê°’ì˜ ì‹ ë¢°ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•´ ê¸°ë³¸ì ìœ¼ë¡œ `immutable` 
ì†ì„±ì„ ê°–ê¸° ë•Œë¬¸ì— ì´ë¥¼ ë³€ê²½í•˜ê¸° ìœ„í•´ì„œëŠ” `mutating` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œ `context` ë‚´ë¶€ì—ì„œ ë³€ê²½ì´ ì´ë£¨ì–´ì ¸ì•¼í•œë‹¤. í•˜ì§€ë§Œ 
`Escaping Closures`ëŠ” ì´ `mutating context`ê°€ ì¢…ë£Œëœ í›„ í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì— ì´ë¥¼ ìœ„ë°˜í•œë‹¤.

ì•„ë˜ì™€ ê°™ì´ `mutating` í‚¤ì›Œë“œê°€ í•„ìš”í•œ ì½”ë“œë¥¼ ì œì™¸í•˜ë©´ `Escaping Closures`ëŠ” `Value Types`ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.

```swift
struct SomeStruct {
    var x = 10
    mutating func doSomething() {
        someFunctionWithNonescapingClosure { x = 200 }
    }
    func anotherDoSomething() {
        someFunctionWithEscapingClosure { print("It's OK") }
    }
}

var valueTypeInstance = SomeStruct()    // It must be declared with `var` not `let`, due to `doSomething()` use mutating member.

valueTypeInstance.doSomething()
print(valueTypeInstance.x)  // 200

valueTypeInstance.anotherDoSomething()
completionHandlers[1]()     // It's OK
```

> `Value Types`ì—ì„œ `Escaping Closures`ëŠ” `mutating`ì„ í•  ìˆ˜ ì—†ë‹¤. ì´ê²ƒì´ *Value Types* ì—ì„œ *Escaping Closures* 
> ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•¨ì„ ì˜ë¯¸í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤. ì—¬ì „íˆ *mutating* ì´ í•„ìš”í•˜ì§€ ì•Šì€ *closures* ëŠ” *escaping* ë  ìˆ˜ ìˆë‹¤.

---

### 6. Autoclosures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ì˜ *arguments* ë¡œ *closures* ë¥¼ ì „ë‹¬í•  ë•Œ ì´ *closure* ê°€ `arguments ë¥¼ ê°–ì§€ ì•Šê³  expressions ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜`í•˜ëŠ” 
ê²½ìš° `{ arguments in expressions }`ì—ì„œ *arguments* ì™€ *in* ì€ ë¬¼ë¡ ì´ê³  *{ }* ë§ˆì €ë„ ìƒëµí•˜ê³  `expressions`ë§Œìœ¼ë¡œ 
ì‘ì„±í•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

ì´ëŸ¬í•œ *closure* ë¥¼ `Autoclosure`ë¼ í•˜ë©°, í•¨ìˆ˜ë¥¼ ì •ì˜í•  ë•Œ `@autoclosure` í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•¨ìœ¼ë¡œì¨ ì •ì˜í•  ìˆ˜ ìˆë‹¤. *Swift* 
ëŠ” ì´ë ‡ê²Œ ì „ë‹¬ëœ `expressions`ì„ ìë™ìœ¼ë¡œ *Closures* í˜•íƒœë¡œ *wrapping* í•œë‹¤.

`Autoclosures`ëŠ” ì½”ë“œê°€ í˜¸ì¶œë  ë•Œ ê¹Œì§€ ì‹¤í–‰ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `í‰ê°€ë¥¼ ì§€ì—°`í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ `side effects`ê°€ 
ìˆê±°ë‚˜ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ”`computationally expensive` ì½”ë“œì— ìœ ìš©í•˜ë‹¤.

#### 1. Closures evaluated when called

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

let returned = customersInLine.remove(at: 0)
print(returned) // Chris
```

*Arrays* ì˜ `remove(at:)` ë©”ì„œë“œëŠ” ì£¼ì–´ì§„ *index* ì˜ ë°°ì—´ì„ ì œê±° í›„ ê·¸ ê°’ì„ ë°˜í™˜í•œë‹¤. 

```swift
let customerProvider = { customersInLine.remove(at: 0) }
```

ë”°ë¼ì„œ ìœ„ì™€ ê°™ì´ ì •ì˜ëœ `customerProvider`ëŠ” `() -> String` íƒ€ì…ì´ë‹¤.

<br>
ë‹¤ìŒì€ *Closures* ê°€ ì½”ë“œ ì‹¤í–‰ì„ ì–´ë–»ê²Œ ì§€ì—°ì‹œí‚¤ëŠ”ì§€ë¥¼ ë³´ì—¬ì¤€ë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

let customerProvider = { customersInLine.remove(at: 0) }

print(customersInLine)          // ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 5

customerProvider()
print(customersInLine)          // ["Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 4

customerProvider()
print(customersInLine)          // ["Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 3
```

ìœ„ ì½”ë“œ ë¸”ëŸ­ì„ ë³´ë©´ `let customerProvider = { customersInLine.remove(at: 0) }`ë¼ì¸ ì´í›„ `customersInLine`ë¥¼ 
ì¶œë ¥í•´ë³´ë©´ ê·¸ëŒ€ë¡œì¸ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì´í›„ `customerProvider()`ê°€ í˜¸ì¶œë  ë•Œ ì œê±°ë˜ê³  ê·¸ ê°’ì„ ë°˜í™˜í•œë‹¤.

#### 2. Autoclosure Type Parameters

__1 ) Parameter Type is a Closure__

ì´ëŸ¬í•œ ì½”ë“œ ì§€ì—°ì€ í•¨ìˆ˜ì˜ *arguments* ë¡œ *Closures* ë¥¼ ì „ë‹¬í•  ë•Œë„ ë™ì¼í•œ ë™ì‘ì„ ê°–ëŠ”ë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}

serve(customer: { customersInLine.remove(at: 0) })  // Now serving Chris!
```

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => {
    return customersInLine.shift()!                 // Now serving Chris!
})
```

*Swift* ì™€ ë‹¬ë¦¬ *arguments* ìì²´ë¥¼ ìƒëµ í•  ìˆ˜ëŠ” ì—†ê³  ë¹„ì›Œì„œ ë³´ë‚´ì•¼í•œë‹¤.

<br>

__2 ) Parameter Type is an Autoclosure__

ì´ë•Œ *Parameter Types* ì•ì— `@autoclosure` í‚¤ì›Œë“œë¥¼ ë¶™ì—¬ì£¼ë©´ *arguments* ë¡œ ì „ë‹¬ëœ `expressions`ë¥¼ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ 
*Closures* í˜•íƒœë¡œ *wrapping* í•œë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}

// `{ }` can be omitted
serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```

> `Autoclosures`ë¥¼ ì‚¬ìš©í•´ *parameters* ë¡œ *closures* ê°€ ì•„ë‹Œ *String* ì„ ë°›ëŠ” ê²ƒì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => customersInLine.shift()!)               // Now serving Chris!
```

<br>

__3 ) Parameter Type is a String__

ìœ„ 2ë²ˆì€ *parameter* ë¡œ *String* ì„ ë°›ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì—¬ì „íˆ *closure* ë¥¼ ë°›ê³  ìˆë‹¤. ë‹¤ìŒ ì½”ë“œëŠ” `Autoclosures` ì—†ì´ 
ì •ë§ë¡œ *String* ì„ *parameter* ë¡œ ë°›ëŠ” í•¨ìˆ˜ë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: String) {
    print("Now serving \(customerProvider)!")
}

serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: string) {
    console.log(`Now serving ${customerProvider}!`)
}

serve(customersInLine.shift()!)
```

> ìœ„ 1 ~ 3ì€ ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ë‹¨, ì´ë“¤ì˜ ì°¨ì´ì ì„ ì˜ ì´í•´í•˜ê³  ì‚¬ìš©í•´ì•¼í•œë‹¤.
> 
> 1. *parameters* ë¡œ `Closure` ë¥¼ ë°›ëŠ”ë‹¤.
> 2. *parameters* ë¡œ `Autoclosures` ë¥¼ ë°›ëŠ”ë‹¤. ê²‰ë³´ê¸°ì—ëŠ” `expressions`ì˜ ê²°ê³¼ë¡œ ë‹¨ìˆœ `Type`ì„ ë°›ëŠ” ê²ƒì²˜ëŸ¼ 
>    ë³´ì¼ ìˆ˜ ìˆì§€ë§Œ ì—¬ì „íˆ `Closure` ë¥¼ *parameters* ë¡œ ë°›ëŠ”ë‹¤.
> 3. *parameters* ë¡œ `expressions`ì„ ìˆ˜í–‰ í›„ ê·¸ ê²°ê³¼ë¥¼ ë°›ëŠ”ë‹¤. ìœ„ 2ë²ˆê³¼ ë‹¬ë¦¬ ì •ë§ë¡œ ê²°ê³¼ì˜ `Type`ì„ *parameters* 
>    ë¡œ ë°›ëŠ”ë‹¤.
> 
> `Autoclosures`ë¥¼ ì‚¬ìš©í•¨ìœ¼ë¡œì¨ ë‹¨ìˆœíˆ ê·¸ `Types`ì„ *parameters* ë¡œ ë°›ëŠ” ê²ƒì²˜ëŸ¼ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìœ¼ë‚˜ ë‚¨ìš©í•  ê²½ìš° ì˜¤íˆë ¤ 
> ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ì–´ë µê²Œ ë§Œë“ ë‹¤. ì–´ë””ê¹Œì§€ë‚˜ ì´ê²ƒì€ 3ë²ˆ ì²˜ëŸ¼ ê²°ê³¼ì˜ `Type` ì´ ì•„ë‹Œ 1ë²ˆ ì²˜ëŸ¼ `Closure`ë¥¼ ë°›ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì´ë‹¤. 
> ë”°ë¼ì„œ `Autoclosures`ë¥¼ ì‚¬ìš©í•  ë•Œ *context* ì™€ *í•¨ìˆ˜ì˜ ì´ë¦„*ì€ ì½”ë“œì˜ ì‹¤í–‰ì´ ì§€ì—°ë¨ì„ ë¶„ëª…íˆ í•´ì•¼í•œë‹¤.

#### 3. Autoclosures with Escaping Closures

`@autoclosure`ê³¼ `@escaping`ì„ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
var customerProviders: [() -> String] = []

func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
    customerProviders.append(customerProvider)
}

collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")

print("customerProviders: \(customerProviders)")

for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
```

```console
Collected 2 closures.
[(Function), (Function)]
Now serving Chris!
Now serving Alex!
```

> ìœ„ì—ì„œë„ ì„¤ëª…í–ˆì§€ë§Œ, `Autoclosures`ì˜ ë‚¨ìš©ì€ ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ì–´ë µê²Œ ë§Œë“ ë‹¤.

### 7. Compare with TypeScript ğŸ‘©â€ğŸ’»

ì´ ê¸€ì˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ Swift ì˜ *Closures* ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ `Lambda expressions`ì™€ ë¹„ìŠ·í•˜ë‹¤ê³  í–ˆë‹¤. 
ë‹¤ì‹œ í•œ ë²ˆ ì •ë¦¬í•˜ë©´ì„œ ë§ˆë¬´ë¦¬í•´ë³´ì.

#### 1. `Function Declarations` with `function` / `func` keyword

```typescript
function sum(a: number, b: number): number {
    return a + b
}
console.log(sum(5, 7))  // 12
```

```swift
func sum(_ a: Int, _ b: Int) -> Int {
    a + b
}
print(sum(5, 7))    // 12
```

#### 2. `Function Expressions` with `Lambda expressions` / `Closures`

- Implicit Type Inference

```typescript
// Function Expressions with lambda expressions
const product = (a: number, b: number) => a * b
console.log(product(5, 7))  // 35
```

```swift
// Function Expressions with closures
let product = { (a: Int, b: Int) in
    a * b
}
print(product(5, 7))        // 35
```

> *Return Type* ì´ ìƒëµë˜ì—ˆë‹¤.

<br>

- Explicit Type Declaration

```typescript
const product = (a: number, b: number): number => a * b
console.log(product(5, 7))  // 35
```

```swift
let product = { (a: Int, b: Int) -> Int in
    a * b
}
print(product(5, 7))        // 35
```

ë˜ëŠ”

```typescript
const product: (num1: number, num2: number) => number = (a, b) => a * b
console.log(product(5, 7))  // 35
```

```swift
let product: (Int, Int) -> Int = { $0 * $1 }
print(product(5, 7))        // 35
```

#### 3. `Lambda expressions` / `Closures`

```typescript
// Function Expressions omit { }
const greetingMessage = () => "Hello~ TypeScript"
console.log(greetingMessage())  // Hello~ TypeScript
```

```swift
let greetingMessage = { "Hello~ Swift" }
print(greetingMessage())    // Hello~ Swift
```

#### 4. `Autoclosures`

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => customersInLine.shift()!)               // Now serving Chris!
```

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}

// `{ }` can be omitted
serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```
<br>

> *TypeScript* ì—­ì‹œ
> 
> ```typescript
> serve(() => {
>     return customersInLine.shift()!                 // Now serving Chris!
> })
> ```
>
> ë¥¼
>  
> ```typescript
> serve(() => customersInLine.shift()!)
> ```
> 
> ë¡œ `{ }`ì™€ `return` í‚¤ì›Œë“œë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë‚˜ *Swift* ì™€ ë‹¬ë¦¬ `arguments` ìì²´ë¥¼ ìƒëµí•  ìˆ˜ëŠ” ì—†ì–´ 
> `Autoclosures`ì²˜ëŸ¼ ì™„ì „íˆ í‰ë¬¸ì„ ì ë“¯ì´ ì‘ì„±í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì¦‰ *Swift* ì˜ `Autoclosures` ê°œë…ì— ì™„ì „íˆ ì¼ì¹˜í•˜ëŠ” 
> ë¬¸ë²•ì€ ì—†ë‹¤.
> 
> ë‹¨, ì´ ê²½ìš°ëŠ” `Closure`ê°€ í•¨ìˆ˜ì˜ `arguments`ë¡œ ì „ë‹¬ë  ë•Œ `Autoclosures`ì— ì˜í•´ `{ }`ê°€ ìƒëµë˜ëŠ” ê²ƒì¼ ë¿ì´ë‹¤.  
> í•¨ìˆ˜ì˜ `arguments`ê°€ ì•„ë‹Œ ì¼ë°˜ì ì¸ `Closures`ë¥¼ ì„ ì–¸í•  ë•Œë¥¼ ë¹„êµí•´ë³´ë©´
> 
> ```typescript
> const product = (a: number, b: number) => a * b
> ```
> 
> ```swift
> let product = { (a: Int, b: Int) in a * b }
> ```
> 
> *TypeScript* ëŠ” íŠ¹ì • ì¡°ê±´ì´ ë§Œì¡±í•  ê²½ìš° `Closures`ì˜ `Body`ë¥¼ ê°ì‹¸ëŠ” `{ }`ë¥¼ ìƒëµí•  ìˆ˜ ìˆëŠ” ê²ƒê³¼ ë‹¬ë¦¬ 
> *Swift* ëŠ” `arguments`ë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë‚˜ ìœ„ì™€ ê°™ì´ `Autoclosures`ê°€ ì•„ë‹Œ ê²½ìš°ëŠ” `{ }`ë¥¼ ìƒëµí•  ìˆ˜ ì—†ë‹¤.
> 
> ì¦‰, ì´ê²ƒì€ ì–´ë–¤ ì–¸ì–´ê°€ ë” ìš°ìˆ˜í•˜ë‹¤ëŠ” ê²ƒì´ ì•„ë‹Œ ì–¸ì–´ì— ë”°ë¥¸ íŠ¹ì„±ì´ë‹ˆ ì´ë¥¼ ì˜ ì´í•´í•˜ê³  ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í•„ìš”í•˜ë‹¤.

#### 5. Capturing Values with `Closures`

`Functions`ëŠ” `Closures`ì˜ íŠ¹ë³„í•œ í˜•íƒœë¡œ ìœ„ 1~3ë²ˆ ëª¨ë‘ `Closures`ë‹¤. ë˜í•œ Swift ì˜ `Closures`ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ 
`Lambda expressions`ì™€ ìœ ì‚¬í•˜ë‹¤. *Swift* ë¿ ì•„ë‹ˆë¼ í•¨ìˆ˜ë¥¼ `First-Class Citizens`ë¡œ ì·¨ê¸‰í•˜ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì–¸ì–´ëŠ” 
ì´ì™€ ìœ ì‚¬í•œ íŠ¹ì„±ì„ ê°–ëŠ”ë‹¤ê³  ë³´ë©´ ëœë‹¤.

*TypeScript* ì˜ ê²½ìš° ì¼ë°˜ì ìœ¼ë¡œ *Closures* ë¥¼ ì„¤ëª…í•  ë•Œ `ê°’ì„ ìº¡ì²˜`í•˜ê³ , `return type`ì´ í•¨ìˆ˜ì¸ ê²½ìš°. ì¦‰, í•¨ìˆ˜ë¥¼ 
ì´ìš©í•´ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¡œì¨ *Closures* ë¥¼ ì„¤ëª…í•˜ëŠ” ê²½ìš°ê°€ ë§ì€ë° ì´ê²ƒ ì—­ì‹œ `First-Class Citizens`ì˜ íŠ¹ì„±ì´ë¯€ë¡œ 
ë‘ ì–¸ì–´ ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```typescript
const makeIncrementer: (forIncrement: number) => () => number
    = amount => {
    let runningTotal = 0
    const incrementer: () => number
        = () => {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}

const increaseByThree = makeIncrementer(3)

console.log(increaseByThree())   // 3
console.log(increaseByThree())   // 6
console.log(increaseByThree())   // 9
```

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}

let increaseByThree = makeIncrementer(forIncrement: 3)

print(increaseByThree())    // 3
print(increaseByThree())    // 6
print(increaseByThree())    // 9
```

<br><br>

---
Reference

1. "Closures." The Swift Programming Language Swift 5.7. accessed Oct. 24, 2022, [Swift Docs Chapter 5 - Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html).

[Automatic Reference Counting]:/swift/2023/03/08/automatic-reference-counting.html
