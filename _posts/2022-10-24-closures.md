---
layout: post
title: Swift Closures
subtitle: Closures
categories: swift
tags: [swift docs, swift closures]
---

### <span style="color: orange">1. Closure Expressions 👩‍💻</span>

`Swift`의 `Closures`는 정의된 `context(or scope)`에 상수(constants)나 변수(variables)를 캡처(capture)하고 저장(store)할 수 있다.
이는 다른 언어의 `lambda`와 비슷하다.

__1 ) `Closures`는 다음 세 가지 형태 중 하나를 갖는다__
- Global Functions : 이름이 있고, 어떤 값도 캡처하지 않는 `Closures`
- Nested Functions : 이름이 있고, 자신이 속한 `function context`의 값을 캡처할 수 있는 `Closures`
- Closure Expressions : 이름이 없고, 자신이 속한 `context`의 값을 캡처할 수 있는 경량화된 `Closures`

__2 ) `Swift` `Closures`의 최적화가 갖는 특징__
- `context`로부터 `parameter`와 `return value`를 추론(inferring)한다
- 단일 표현 클로저(single-expression closures)에서 암시적 반환(implicit returns)
- 축약된 인자 이름(shorthand arguemnt names)
- 후위 클로저 문법(trailing closure syntax)

<br>

`Closure Expressions`는 이름이 없으나 경량화된 문법으로 재사용 되지 않는 함수, 
주로 `Nested Functions`를 대체할 수 있다.

#### <span style="color: rgba(166, 42, 254, 1)">1. The Sorted Method</span>

`sorted(by:)` 메서드는, `Comparable` 프로토콜을 따르는 타입에 대해
`(Type, Type) -> Bool` 타입의 `Closures`를 `arguments`로 받아 정렬을 수행한다.  
`true`면 순서를 바꾸지 않고, `false`면 순서를 바꾼다.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`(String, String) -> Bool` 타입의 `Closures`를 `arguments`로 받아 정렬을 수행해보도록 하자.  
이를 위해 `Global Functions` 형태의 `Closures`로 `forware(_:_:)`, `backward(_:_:)`를 생성한다.

- ascending order(default)

```swift
func forward(_ s1: String, _ s2: String) -> Bool {
    s1 < s2
}

func backward(_ s1: String, _ s2: String) -> Bool {
    s1 > s2
}
```

- descending order

```swift
print("origin          : \(names)")
print("default         : \(names.sorted())")
print("ascending order : \(names.sorted(by: forward))")
print("descending order: \(names.sorted(by: backward))")
```

```console
origin          : ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
default         : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
ascending order : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descending order: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```


#### <span style="color: rgba(166, 42, 254, 1)">2. Closure Expression Syntax</span>

__Syntax__

```swift
{ (parameters) -> return type in
    statements
}
```

__Closure Expressions는 다음 특징을 갖는다__

- `Global Functions`와 마찬가지로 `In-Out Parameters`, `Variadic Parameters`, `Tuple Type Parameters`, `Tuple Type Return`이 허용된다.
- 단, <span style="color: red;">**Default Values**는 허용되지 않는다</span>.

<br>

위 정렬은 `Global Functions` 형태의 `Closures` 대신 `Closure Expressions` 
형태의 `Closures`를 이용하면 더욱 간결한 표현이 가능하다.

```swift
let ascendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 < s2 })
let descendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })

print("ascendingOrderNames : \(ascendingOrderNames)")
print("descendingOrderNames: \(descendingOrderNames)")
```

```console
ascendingOrderNames : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descendingOrderNames: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### <span style="color: rgba(166, 42, 254, 1)">3. Inferring Type From Context</span>

`Inline-Closures`는 항상 `context`로부터 `parameter types`와  `return types`를 
추론(infer)할 수 있으므로 `type`을 적을 필요가 없다. 마찬가지로 arrow(`->`) 역시 필수가 아니다.  
단, 위 2번 처럼 명시적으로 적는 것은 가능하다.

```swift
// ascending order
names.sorted(by: { s1, s2 in return s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in return s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">4. Implicit Return from Single-Expression Closures</span>

함수와 마찬가지로 `Single-Expression Closures`는 `return` 키워드를 생략할 수 있다.  
사실 `Global Functions` 형태의 `Closures`가 가능했으니 `Closure Expressions` 형태의 
`Closures` 역시 가능한 것은 당연하다.

```swift
// ascending order
names.sorted(by: { s1, s2 in s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">5. Shorthand Argument Names</span>

`Inline-Closures`에 `Shorthand Argument Names`를 사용하는 경우, `arguments`를 생략할 수 있으며, 
이는 `$0`, `$1`, `$2`로 표현된다. `arguments`의 갯수는 가장 높은 번호(이 경우 `$2`)로부터 추론된다.  
또한 `Shorthand Argument Names`를 사용하면, `arguments`를 생략하므로 `in` 키워드 역시 생략하며, 
`body`만으로 `Closures`를 구성한다.

```swift
// ascending order
names.sorted(by: { $0 < $1 })

// descending order
names.sorted(by: { $0 > $1 })
```

#### <span style="color: rgba(166, 42, 254, 1)">6. Operator Methods</span>

`String`은 <span style="color: red;">greater-than operator(`>`)</span>를 메서드로 갖는다. 
또한 이 메서드는 두 개의 `parameters`를 갖고, `Bool`을 반환한다. 즉, 위에서 `sorted(by:)`가 `Closures`로 
받는 유형과 정확히 일치한다. 따라서 이 경우 `Shorthand Argument Names` 마저도 생략할 수 있다.

```swift
// ascending order
names.sorted(by: <)

// descending order
names.sorted(by: >)
```

---

### <span style="color: orange">2. Trailing Closures 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">3. Capturing Values 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">4. Closures Are Reference Types 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">5. Autoclosures 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---







<br><br>

---
Reference

1. "Closures", The Swift Programming Language Swift 5.7, last modified latest(Unknown), accessed Oct. 24, 2022, [Swift Docs Chapter 5 - Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)
