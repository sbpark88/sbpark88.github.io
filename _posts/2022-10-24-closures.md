---
layout: post
title: Swift Closures
subtitle: Closures
categories: swift
tags: [swift docs, swift closures]
---

### <span style="color: orange">1. Closure Expressions ğŸ‘©â€ğŸ’»</span>

`Swift`ì˜ `Closures`ëŠ” ì •ì˜ëœ `context(or scope)`ì— ìƒìˆ˜(constants)ë‚˜ ë³€ìˆ˜(variables)ë¥¼ ìº¡ì²˜(capture)í•˜ê³  ì €ì¥(store)í•  ìˆ˜ ìˆë‹¤.
ì´ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ `lambda`ì™€ ë¹„ìŠ·í•˜ë‹¤.

__1 ) `Closures`ëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¥¼ ê°–ëŠ”ë‹¤__
- Global Functions : ì´ë¦„ì´ ìˆê³ , ì–´ë–¤ ê°’ë„ ìº¡ì²˜í•˜ì§€ ì•ŠëŠ” `Closures`
- Nested Functions : ì´ë¦„ì´ ìˆê³ , ìì‹ ì´ ì†í•œ `function context`ì˜ ê°’ì„ ìº¡ì²˜í•  ìˆ˜ ìˆëŠ” `Closures`
- Closure Expressions : ì´ë¦„ì´ ì—†ê³ , ìì‹ ì´ ì†í•œ `context`ì˜ ê°’ì„ ìº¡ì²˜í•  ìˆ˜ ìˆëŠ” ê²½ëŸ‰í™”ëœ `Closures`

__2 ) `Swift` `Closures`ì˜ ìµœì í™”ê°€ ê°–ëŠ” íŠ¹ì§•__
- `context`ë¡œë¶€í„° `parameter`ì™€ `return value`ë¥¼ ì¶”ë¡ (inferring)í•œë‹¤
- ë‹¨ì¼ í‘œí˜„ í´ë¡œì €(single-expression closures)ì—ì„œ ì•”ì‹œì  ë°˜í™˜(implicit returns)
- ì¶•ì•½ëœ ì¸ì ì´ë¦„(shorthand arguemnt names)
- í›„ìœ„ í´ë¡œì € ë¬¸ë²•(trailing closure syntax)

<br>

`Closure Expressions`ëŠ” ì´ë¦„ì´ ì—†ìœ¼ë‚˜ ê²½ëŸ‰í™”ëœ ë¬¸ë²•ìœ¼ë¡œ ì¬ì‚¬ìš© ë˜ì§€ ì•ŠëŠ” í•¨ìˆ˜, 
ì£¼ë¡œ `Nested Functions`ë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

#### <span style="color: rgba(166, 42, 254, 1)">1. The Sorted Method</span>

`sorted(by:)` ë©”ì„œë“œëŠ”, `Comparable` í”„ë¡œí† ì½œì„ ë”°ë¥´ëŠ” íƒ€ì…ì— ëŒ€í•´
`(Type, Type) -> Bool` íƒ€ì…ì˜ `Closures`ë¥¼ `arguments`ë¡œ ë°›ì•„ ì •ë ¬ì„ ìˆ˜í–‰í•œë‹¤.  
`true`ë©´ ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šê³ , `false`ë©´ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`(String, String) -> Bool` íƒ€ì…ì˜ `Closures`ë¥¼ `arguments`ë¡œ ë°›ì•„ ì •ë ¬ì„ ìˆ˜í–‰í•´ë³´ë„ë¡ í•˜ì.  
ì´ë¥¼ ìœ„í•´ `Global Functions` í˜•íƒœì˜ `Closures`ë¡œ `forware(_:_:)`, `backward(_:_:)`ë¥¼ ìƒì„±í•œë‹¤.

- ascending order(default)

```swift
func forward(_ s1: String, _ s2: String) -> Bool {
    s1 < s2
}

func backward(_ s1: String, _ s2: String) -> Bool {
    s1 > s2
}
```

- descending order

```swift
print("origin          : \(names)")
print("default         : \(names.sorted())")
print("ascending order : \(names.sorted(by: forward))")
print("descending order: \(names.sorted(by: backward))")
```

```console
origin          : ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
default         : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
ascending order : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descending order: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```


#### <span style="color: rgba(166, 42, 254, 1)">2. Closure Expression Syntax</span>

__Syntax__

```swift
{ (parameters) -> return type in
    statements
}
```

__Closure ExpressionsëŠ” ë‹¤ìŒ íŠ¹ì§•ì„ ê°–ëŠ”ë‹¤__

- `Global Functions`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `In-Out Parameters`, `Variadic Parameters`, `Tuple Type Parameters`, `Tuple Type Return`ì´ í—ˆìš©ëœë‹¤.
- ë‹¨, <span style="color: red;">**Default Values**ëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤</span>.

<br>

ìœ„ ì •ë ¬ì€ `Global Functions` í˜•íƒœì˜ `Closures` ëŒ€ì‹  `Closure Expressions` 
í˜•íƒœì˜ `Closures`ë¥¼ ì´ìš©í•˜ë©´ ë”ìš± ê°„ê²°í•œ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

```swift
let ascendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 < s2 })
let descendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })

print("ascendingOrderNames : \(ascendingOrderNames)")
print("descendingOrderNames: \(descendingOrderNames)")
```

```console
ascendingOrderNames : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descendingOrderNames: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### <span style="color: rgba(166, 42, 254, 1)">3. Inferring Type From Context</span>

`Inline-Closures`ëŠ” í•­ìƒ `context`ë¡œë¶€í„° `parameter types`ì™€  `return types`ë¥¼ 
ì¶”ë¡ (infer)í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ `type`ì„ ì ì„ í•„ìš”ê°€ ì—†ë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ arrow(`->`) ì—­ì‹œ í•„ìˆ˜ê°€ ì•„ë‹ˆë‹¤.  
ë‹¨, ìœ„ 2ë²ˆ ì²˜ëŸ¼ ëª…ì‹œì ìœ¼ë¡œ ì ëŠ” ê²ƒì€ ê°€ëŠ¥í•˜ë‹¤.

```swift
// ascending order
names.sorted(by: { s1, s2 in return s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in return s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">4. Implicit Return from Single-Expression Closures</span>

í•¨ìˆ˜ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `Single-Expression Closures`ëŠ” `return` í‚¤ì›Œë“œë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.  
ì‚¬ì‹¤ `Global Functions` í˜•íƒœì˜ `Closures`ê°€ ê°€ëŠ¥í–ˆìœ¼ë‹ˆ `Closure Expressions` í˜•íƒœì˜ 
`Closures` ì—­ì‹œ ê°€ëŠ¥í•œ ê²ƒì€ ë‹¹ì—°í•˜ë‹¤.

```swift
// ascending order
names.sorted(by: { s1, s2 in s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">5. Shorthand Argument Names</span>

`Inline-Closures`ì— `Shorthand Argument Names`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, `arguments`ë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë©°, 
ì´ëŠ” `$0`, `$1`, `$2`ë¡œ í‘œí˜„ëœë‹¤. `arguments`ì˜ ê°¯ìˆ˜ëŠ” ê°€ì¥ ë†’ì€ ë²ˆí˜¸(ì´ ê²½ìš° `$2`)ë¡œë¶€í„° ì¶”ë¡ ëœë‹¤.  
ë˜í•œ `Shorthand Argument Names`ë¥¼ ì‚¬ìš©í•˜ë©´, `arguments`ë¥¼ ìƒëµí•˜ë¯€ë¡œ `in` í‚¤ì›Œë“œ ì—­ì‹œ ìƒëµí•˜ë©°, 
`body`ë§Œìœ¼ë¡œ `Closures`ë¥¼ êµ¬ì„±í•œë‹¤.

```swift
// ascending order
names.sorted(by: { $0 < $1 })

// descending order
names.sorted(by: { $0 > $1 })
```

#### <span style="color: rgba(166, 42, 254, 1)">6. Operator Methods</span>

`String`ì€ <span style="color: red;">greater-than operator(`>`)</span>ë¥¼ ë©”ì„œë“œë¡œ ê°–ëŠ”ë‹¤. 
ë˜í•œ ì´ ë©”ì„œë“œëŠ” ë‘ ê°œì˜ `parameters`ë¥¼ ê°–ê³ , `Bool`ì„ ë°˜í™˜í•œë‹¤. ì¦‰, ìœ„ì—ì„œ `sorted(by:)`ê°€ `Closures`ë¡œ 
ë°›ëŠ” ìœ í˜•ê³¼ ì •í™•íˆ ì¼ì¹˜í•œë‹¤. ë”°ë¼ì„œ ì´ ê²½ìš° `Shorthand Argument Names` ë§ˆì €ë„ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
// ascending order
names.sorted(by: <)

// descending order
names.sorted(by: >)
```

---

### <span style="color: orange">2. Trailing Closures ğŸ‘©â€ğŸ’»</span>

í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ë§ˆì§€ë§‰ `parameter`ê°€ `Closure`ì´ê³ , ì „ë‹¬ ë˜ëŠ” `argument`ê°€ ê¸´ í‘œí˜„ì‹ì¼ ê²½ìš° 
`Trailing Closure`ë¥¼ ì´ìš©í•´ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤. `Trailing Closure`ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ 
ê´„í˜¸(`( )`) ë‹¤ìŒì— ì‘ì„±í•˜ì§€ë§Œ ì—¬ì „íˆ í•¨ìˆ˜ì˜ `arguments`ë‹¤.

í•¨ìˆ˜ëŠ” ì—¬ëŸ¬ ê°œì˜ `Trailing Closure`ë¥¼ `arguments`ë¡œ ì…ë ¥ ë°›ì„ ìˆ˜ ìˆìœ¼ë©°, 
ì²« ë²ˆì§¸ `Closure`ì˜ `arguments`ëŠ” ìƒëµë  ìˆ˜ ìˆë‹¤.

#### <span style="color: rgba(166, 42, 254, 1)">1. Trailing Closure Syntax</span>

ì•„ë˜ `someFunctionThatTakesAClosure(closure:)` í•¨ìˆ˜ëŠ” ë§ˆì§€ë§‰ `arguments`ë¥¼ `Closures`ë¡œ ê°–ëŠ” í•¨ìˆ˜ë‹¤.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}
```

<br>

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë³´ì.

__1 ) `Trailing Closure` ì—†ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

```swift
someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})
```

<br>

__2 ) `Trailing Closures`ë¡œ ë¶„ë¦¬í•´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

ì²« ë²ˆì§¸ `Closures`ì´ë¯€ë¡œ `arguments`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
```

> `Trailing Closures`ì˜ í˜•íƒœë¥¼ ë³´ë©´ `Global Functions`ì™€ ê°™ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.
> ì¦‰, `Global Functions`ê°€ `Closures`ì˜ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¼ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

<br>

__3 ) `Trailing Closures`ê°€ í•¨ìˆ˜ì˜ ìœ ì¼í•œ `arguments`ì¼ ë•ŒëŠ” ê´„í˜¸`( )`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤__

```swift
someFunctionThatTakesAClosure {
    // trailing closure's body goes here
}
```

#### <span style="color: rgba(166, 42, 254, 1)">2. Trailing Closure Examples</span>

ìœ„ `sorted(by:)`ë¥¼ `Trailing Closures`ë¥¼ ì´ìš©í•´ í˜¸ì¶œí•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let descendingNames = names.sorted { $0 > $1 }

print(descendingNames)  // ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

<br>

__1 ) Without Trailing Closures__

`Closure Expressions`ëŠ” `Operator Methods`ë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

```swift
names.sorted(by: { $0 > $1 } )

// Using Operator Methods
names.sorted(by: >)
```

<br>

__2 ) With Trailing Closures__

í•˜ì§€ë§Œ `Trailing Closure`ì€ `Operator Methods`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
 
```swift
names.sorted { $0 > $1 }

// Using Operator Methods
print(names.sorted { > })   // error: unary operator cannot be separated from its operand
```

<br>

`map(_:)` ë©”ì„œë“œë¥¼ ì´ìš©í•´ ì•„ë˜ ì£¼ì–´ì§„ `digitNames`, `numbers` ë°°ì—´ë¡œë¶€í„° 
`["OneSix", "FiveEight", "FiveOneZero"]` ìƒˆ ë°°ì—´ì„ ë°˜í™˜í•˜ë„ë¡ `Trailing Closures`ë¥¼ ì´ìš©í•´ 
`map(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë³´ì. 

```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```

```swift
let strings = numbers.map { number -> String in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ìœ„ `Trailing Closures`ì˜ `Return Types`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map { number in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ë§ˆì§€ë§‰ìœ¼ë¡œ, `Trailing Closures` ì—­ì‹œ `Shorthand Argument Names`ë¥¼ ì´ìš©í•´ 
`arguments`ì™€ `in` í‚¤ì›Œë“œ ì—­ì‹œ ìƒëµí•´ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map {
    var number = $0
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

#### <span style="color: rgba(166, 42, 254, 1)">3. A function takes "_Multiple Closures_"</span>

ë§Œì•½ í•¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°œì˜ `Closures`ë¥¼ ê°€ì§ˆ ê²½ìš°, ì²« ë²ˆì§¸ `Trailing Closures`ì˜ `argument labels`ì€
ìƒëµí•  ìˆ˜ ìˆë‹¤. ê·¸ ì™¸ ë‚˜ë¨¸ì§€ `Trailing Closures`ëŠ” `label`ì„ ì§€ì •í•´ì•¼í•œë‹¤. 

<br>

ì•„ë˜ `loadPicture(from:completion:onFailure:)` í•¨ìˆ˜ë¥¼ ë³´ì.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```

`loadPicture(from:completion:onFailure:)`ëŠ” 3 ê°œì˜ `arguments`ë¥¼ ê°–ê³  ìˆëŠ”ë°, ì²« ë²ˆì§¸ `argument`ëŠ” 
`Server` ê°ì²´ê³ , ë‘ ë²ˆì§¸ `argument`ëŠ” `(Picture) -> Void` `Closure`, ì„¸ ë²ˆì¬ `argument`ëŠ” 
`() -> Void` `Closure`ë‹¤.

ì¦‰, ì²« ë²ˆì§¸ `Clousre` `(Picture) -> Void`ëŠ” `completion handler`ë¡œ `Server`ë¡œë¶€í„° ìš”ì²­ 
ê²°ê³¼ê°€ ì„±ê³µì¼ ê²½ìš° `Function Body`ì˜ `if`ì ˆì„ í†µí•´ ì‚¬ìš©ìì—ê²Œ ì‚¬ì§„ì„ ë³´ì—¬ì¤„ ê²ƒì´ë‹¤. 
ë‘ ë²ˆì§¸ `Closure` `() -> Void`ëŠ” `error handler`ë¡œ ì‹¤íŒ¨ í–ˆì„ ê²½ìš° `else`ì ˆì„ í†µí•´ 
ì‚¬ìš©ìì—ê²Œ ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŒì„ ì•Œë ¤ì¤„ ê²ƒì´ë‹¤.

ì´ë¥¼ `Trailing Closures`ë¡œ ë°”ê¾¸ë©´ ë‹¤ìŒê³¼ ê°™ì€ í˜•íƒœê°€ ëœë‹¤.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```




---

### <span style="color: orange">3. Capturing Values ğŸ‘©â€ğŸ’»</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">4. Closures Are Reference Types ğŸ‘©â€ğŸ’»</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">5. Autoclosures ğŸ‘©â€ğŸ’»</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---







<br><br>

---
Reference

1. "Closures", The Swift Programming Language Swift 5.7, last modified latest(Unknown), accessed Oct. 24, 2022, [Swift Docs Chapter 5 - Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)
