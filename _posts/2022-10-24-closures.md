---
layout: post
title: Swift Closures
subtitle: Closures
categories: swift
tags: [swift docs, swift closures]
---

### <span style="color: orange">1. Closure Expressions 👩‍💻</span>

`Swift`의 `Closures`는 정의된 `context(or scope)`에 상수(constants)나 변수(variables)를 캡처(capture)하고 저장(store)할 수 있다.
이는 다른 언어의 `lambda`와 비슷하다.

__1 ) `Closures`는 다음 세 가지 형태 중 하나를 갖는다__

- Global Functions : 이름이 있고, 어떤 값도 캡처하지 않는 `Closures`
- Nested Functions : 이름이 있고, 자신이 속한 `function context`의 값을 캡처할 수 있는 `Closures`
- Closure Expressions : 이름이 없고, 자신이 속한 `context`의 값을 캡처할 수 있는 경량화된 `Closures`

__2 ) `Swift` `Closures`의 최적화가 갖는 특징__

- `context`로부터 `parameter`와 `return value`를 추론(inferring)한다
- 단일 표현 클로저(single-expression closures)에서 암시적 반환(implicit returns)
- 축약된 인자 이름(shorthand arguemnt names)
- 후위 클로저 문법(trailing closure syntax)

<br>

`Closure Expressions`는 이름이 없으나 경량화된 문법으로 재사용 되지 않는 함수,
주로 `Nested Functions`를 대체할 수 있다.

#### <span style="color: rgba(166, 42, 254, 1)">1. The Sorted Method</span>

`sorted(by:)` 메서드는, `Comparable` 프로토콜을 따르는 타입에 대해
`(Type, Type) -> Bool` 타입의 `Closures`를 `arguments`로 받아 정렬을 수행한다.  
`true`면 순서를 바꾸지 않고, `false`면 순서를 바꾼다.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`(String, String) -> Bool` 타입의 `Closures`를 `arguments`로 받아 정렬을 수행해보도록 하자.  
이를 위해 `Global Functions` 형태의 `Closures`로 `forware(_:_:)`, `backward(_:_:)`를 생성한다.

- ascending order(default)

```swift
func forward(_ s1: String, _ s2: String) -> Bool {
    s1 < s2
}

func backward(_ s1: String, _ s2: String) -> Bool {
    s1 > s2
}
```

- descending order

```swift
print("origin          : \(names)")
print("default         : \(names.sorted())")
print("ascending order : \(names.sorted(by: forward))")
print("descending order: \(names.sorted(by: backward))")
```

```console
origin          : ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
default         : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
ascending order : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descending order: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### <span style="color: rgba(166, 42, 254, 1)">2. Closure Expression Syntax</span>

__Syntax__

```swift
{ (parameters) -> return type in
    statements
}
```

__Closure Expressions는 다음 특징을 갖는다__

- `Global Functions`와 마찬가지로 `In-Out Parameters`, `Variadic Parameters`, `Tuple Type Parameters`, `Tuple Type Return`이
  허용된다.
- 단, <span style="color: red;">**Default Values**는 허용되지 않는다</span>.

<br>

위 정렬은 `Global Functions` 형태의 `Closures` 대신 `Closure Expressions`
형태의 `Closures`를 이용하면 더욱 간결한 표현이 가능하다.

```swift
let ascendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 < s2 })
let descendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })

print("ascendingOrderNames : \(ascendingOrderNames)")
print("descendingOrderNames: \(descendingOrderNames)")
```

```console
ascendingOrderNames : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descendingOrderNames: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### <span style="color: rgba(166, 42, 254, 1)">3. Inferring Type From Context</span>

`Inline-Closures`는 항상 `context`로부터 `parameter types`와  `return types`를
추론(infer)할 수 있으므로 `type`을 적을 필요가 없다. 마찬가지로 arrow(`->`) 역시 필수가 아니다.  
단, 위 2번 처럼 명시적으로 적는 것은 가능하다.

```swift
// ascending order
names.sorted(by: { s1, s2 in return s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in return s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">4. Implicit Return from Single-Expression Closures</span>

함수와 마찬가지로 `Single-Expression Closures`는 `return` 키워드를 생략할 수 있다.  
사실 `Global Functions` 형태의 `Closures`가 가능했으니 `Closure Expressions` 형태의
`Closures` 역시 가능한 것은 당연하다.

```swift
// ascending order
names.sorted(by: { s1, s2 in s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in s1 > s2 })
```

#### <span style="color: rgba(166, 42, 254, 1)">5. Shorthand Argument Names</span>

`Inline-Closures`에 `Shorthand Argument Names`를 사용하는 경우, `arguments`를 생략할 수 있으며,
이는 `$0`, `$1`, `$2`로 표현된다. `arguments`의 갯수는 가장 높은 번호(이 경우 `$2`)로부터 추론된다.  
또한 `Shorthand Argument Names`를 사용하면, `arguments`를 생략하므로 `in` 키워드 역시 생략하며,
`body`만으로 `Closures`를 구성한다.

```swift
// ascending order
names.sorted(by: { $0 < $1 })

// descending order
names.sorted(by: { $0 > $1 })
```

#### <span style="color: rgba(166, 42, 254, 1)">6. Operator Methods</span>

`String`은 <span style="color: red;">greater-than operator(`>`)</span>를 메서드로 갖는다.
또한 이 메서드는 두 개의 `parameters`를 갖고, `Bool`을 반환한다. 즉, 위에서 `sorted(by:)`가 `Closures`로
받는 유형과 정확히 일치한다. 따라서 이 경우 `Shorthand Argument Names` 마저도 생략할 수 있다.

```swift
// ascending order
names.sorted(by: <)

// descending order
names.sorted(by: >)
```

---

### <span style="color: orange">2. Trailing Closures 👩‍💻</span>

함수를 호출할 때 마지막 `parameter`가 `Closure`이고, 전달 되는 `argument`가 긴 표현식일 경우 
`Trailing Closure`를 이용해 코드의 가독성을 높일 수 있다. `Trailing Closure`는 함수를 호출할 때 
괄호(`( )`) 다음에 작성하지만 여전히 함수의 `arguments`다.

함수는 여러 개의 `Trailing Closures`를 `arguments`로 입력 받을 수 있으며, 
첫 번째 `Trailing Closure`의 `argument labels`는 생략될 수 있다.

#### <span style="color: rgba(166, 42, 254, 1)">1. Trailing Closure Syntax</span>

아래 `someFunctionThatTakesAClosure(closure:)` 함수는 마지막 `arguments`를 `Closures`로 갖는 함수다.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}
```

<br>

이제 이 함수를 호출해보자.

__1 ) `Trailing Closures` 없이 함수를 호출__

함수의 `argument`로 `Closure`를 전달한다. 이 때 함수의 `arguments`, `return types`, `arrow(->)`은 생략했다.

```swift
someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})
```

<br>

__2 ) `Trailing Closures`로 분리해 함수를 호출__

첫 번째 `Trailing Closure`이므로 `argument labels`를 생략할 수 있다.

```swift
someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
```

> `Trailing Closures`의 형태를 보면 `Global Functions`와 같다는 것을 알 수 있다.  
> 즉, `Global Functions`가 `Closures`의 형태 중 하나라는 것을 확인할 수 있다.

<br>

__3 ) `Trailing Closures`가 함수의 유일한 `arguments`일 때는 괄호`( )`를 생략할 수 있다__

```swift
someFunctionThatTakesAClosure {
    // trailing closure's body goes here
}
```

#### <span style="color: rgba(166, 42, 254, 1)">2. Trailing Closure Examples</span>

__1 ) Examples 1: 'sorted(by:)'__

위 `sorted(by:)`를 `Trailing Closures`를 이용해 호출하면 다음과 같다.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let descendingNames = names.sorted { $0 > $1 }

print(descendingNames)  // ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

<br>

`Closures`를 전달해 사용할 때와 `Trailing Closures`를 사용할의 차이을 비교해보자.

- Without Trailing Closures

`Closure Expressions`는 `Operator Methods`를 이용해 다음과 같이 최적화 할 수 있다.

```swift
names.sorted(by: { $0 > $1 } )

// Using Operator Methods
names.sorted(by: >)
```

<br>

- With Trailing Closures

하지만 `Trailing Closure`은 `Operator Methods`를 사용할 수 없다.

```swift
names.sorted { $0 > $1 }

// Using Operator Methods
print(names.sorted { > })   // error: unary operator cannot be separated from its operand
```

<br>

__2 ) Examples 2: 'map(_:)'__

`map(_:)` 메서드를 이용해 아래 주어진 `digitNames`, `numbers` 배열로부터
새 배열 `["OneSix", "FiveEight", "FiveOneZero"]`을 반환하도록 `Trailing Closures`를 이용해
`map(_:)` 메서드를 호출해보자.

```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```

```swift
let strings = numbers.map { number -> String in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

위 `Trailing Closures`의 `Return Types`를 생략할 수 있다.

```swift
let strings = numbers.map { number in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

마지막으로, `Trailing Closures` 역시 `Shorthand Argument Names`를 이용해 
`arguments`와 `in` 키워드 역시 생략해 최적화 할 수 있다.

```swift
let strings = numbers.map {
    var number = $0
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

#### <span style="color: rgba(166, 42, 254, 1)">3. A function takes "_Multiple Closures_"</span>

만약 함수가 여러 개의 `Closures`를 가질 경우, 첫 번째 `Trailing Closure`의 `argument labels`은 
생략할 수 있다. 그 외 나머지 `Trailing Closures`는 `labels`을 지정해야한다.

<br>

아래 `loadPicture(from:completion:onFailure:)` 함수를 보자.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```

`loadPicture(from:completion:onFailure:)`는 3 개의 `arguments`를 갖고 있는데, 첫 번째 `argument`는 
`Server` 객체고, 두 번째 `argument`는 `(Picture) -> Void` `Closure`, 세 번재 `argument`는 
`() -> Void` `Closure`다.

즉, 첫 번째 `Clousre` `(Picture) -> Void`는 `completion handler`로 `Server`로부터 요청 
결과가 성공일 경우 `Function Body`의 `if`절을 통해 사용자에게 사진을 보여줄 것이다. 
두 번째 `Closure` `() -> Void`는 `error handler`로 실패 했을 경우 `else`절을 통해 
사용자에게 요청에 실패했음을 알려줄 것이다.

이 두 `completion handler`를 `Trailing Closures`를 이용해 호출해보자.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

> `loadPicture(from:completion:onFailure:)` 함수는 2 개의 `completion handler`를 가지고 있다.  
> 하나는 요청이 성공했을 경우 호출하는 `success handler`, 다른 하나는 실패했을 경우 호출하는 `error handler`다.
>
> 검색을 하다 보면 글에 따라 다음과 같은 두 가지 설명이 혼재할 수 있다.  
> 두 개의 `completion handler`를 가지고 있고, 하나는 `completion handler`, 다른 하나는 `error handler`다.  
> 두 개의 `completion handler`를 가지고 있고, 하나는 `success handler`, 다른 하나는 `error handler`다.
>
> `loadPicture(from:completion:onFailure:)`와 같이 함수를 작성하면, 하나의 `Closure`에 `success`, `error`를 
> 처리하는 코드를 혼재하지 않고 `case` 별로 코드를 명확하게 분리할 수 있다.

---

### <span style="color: orange">3. Capturing Values 👩‍💻</span>

`Closures`는 정의될 때 주변 `context`의 상수나 변수, 인수를 캡처해 저장할 수 있다.    
`Nested Functions`는 가장 간단한 형태의 값 캡처로 `context`내의 어떠한 `constant`, 
`variables`, `arguments`든 캡처할 수 있다.

아래에 `makeIncrementer(forIncrement:)` 함수를 보자.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

- `makeIncrementer(forIncrement:)` 함수는 (Int)를 `arguments`로 받아 
  `() -> Int` 타입의 함수를 반환한다.

- 함수의 `body`를 살펴보면, 안에 정의된 `Nested Funcgtion`인 `incrementer()`는
  주변 `context`에서 변수 `runningTotal`와 'forIncrement' 인수로 전달된 파라미터 `amount`를
  저장하는 것을 볼 수 있다.

- 마지막으로 `() -> Int` 타입의 함수 `incrementer()`를 반환한다.

반환된 함수는 다음과 같을 것이다.

```swift
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
```

반환된 함수 어디에도 `runningTotal`과 `amount`가 정의되어있지 않지만 이 함수는 작동한다.  
<span style="color: red;">값을 캡처</span>했기 때문이다.

<br>

`makeIncrementer(forIncrement:)` 함수는 `(Int)`를 인수로 받아 값을 캡처해 함수를 반환하는  
즉, 인수를 받아 함수를 만들어내는 함수다. <span style="color: red;">재사용</span>이 가능하다는 말이다.

```swift
let incrementByThree = makeIncrementer(forIncrement: 3)
let incrementByFive = makeIncrementer(forIncrement: 5)

print(incrementByThree())   // 3
print(incrementByThree())   // 6
print(incrementByThree())   // 9

print(incrementByFive())    // 5
print(incrementByFive())    // 10

print(incrementByThree())   // 12

print(incrementByFive())    // 15
```

> `incrementByThree()`와 `incrementByFive()`가 서로에게 영향을 주지 않고
> 각각 작동할 수 있는 이유는 <span style="color: red;">값을 캡처</span>했기 때문이다.
>
> `Swift`는 값을 캡처할 때는 물론이고 더 이상 필요하지 않을 경우 제거하는 것과 같은
> 모든 메모리 관리를 알아서 처리한다.

동일한 로직을 `TypeScript`로 구현한 코드가 아래 있다. `Swift`와 비교해보자.

```typescript
const makeIncrementer: (forIncrement: number) => () => number
    = amount => {
    let runningTotal = 0
    const incrementer: () => number
        = () => {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

```typescript
const incrementByThree = makeIncrementer(3)
const incrementByFive = makeIncrementer(5)

console.log(incrementByThree())   // 3
console.log(incrementByThree())   // 6
console.log(incrementByThree())   // 9

console.log(incrementByFive())    // 5
console.log(incrementByFive())    // 10

console.log(incrementByThree())   // 12

console.log(incrementByFive())    // 15
```

<br>

> `Closure`를 `Class instance`의 `Property`에 할당하고,
> 그 `Closure`가 해당 `instance` 또는 해당 `instance`의 `memebrs`를 참조로 캡처하면
> `Strong Reference Cycle`(강한 순환 참조)가 생성된다.
>
> 따라서 `Swift`는 이 순환을 중단시키기 위해 `Capture Lists`를 이용한다. 해당 내용은 다음을 참고한다. 
> [Strong Reference Cycles for Closures][Strong Reference Cycles for Closures]

[Strong Reference Cycles for Closures]:https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56

---

### <span style="color: orange">4. Closures Are Reference Types 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---

### <span style="color: orange">5. Autoclosures 👩‍💻</span>

__Syntax__

#### <span style="color: rgba(166, 42, 254, 1)">1. </span>
#### <span style="color: rgba(166, 42, 254, 1)">2. </span>

---







<br><br>

---
Reference

1. "Closures", The Swift Programming Language Swift 5.7, last modified latest(Unknown), accessed Oct. 24,
   2022, [Swift Docs Chapter 5 - Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)
