---
layout: post
title: Swift Closures
subtitle: Closures - Closure Expressions, Trailing Closures, Capturing Values, Escaping Closures, Autoclosures, Lambda
categories: swift
tags: [swift docs, closure, closure expression, trailing closure, capturing value, escaping closure, autoclosure, lambda]
---

### 1. Closure Expressions ğŸ‘©â€ğŸ’»

Swift ì˜ `Closures`ëŠ” ì •ì˜ëœ `context(or scope)`ì— ìƒìˆ˜(constants)ë‚˜ ë³€ìˆ˜(variables)ë¥¼ ìº¡ì²˜(capture)í•˜ê³  ì €ì¥(store)í•  ìˆ˜ ìˆë‹¤.
ì´ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ `Lambda expressions`ì™€ ë¹„ìŠ·í•˜ë‹¤.

__1 ) `Closures`ëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¥¼ ê°–ëŠ”ë‹¤__

- Global Functions : ì´ë¦„ì´ ìˆê³ , ì–´ë–¤ ê°’ë„ ìº¡ì²˜í•˜ì§€ ì•ŠëŠ” `Closures`
- Nested Functions : ì´ë¦„ì´ ìˆê³ , ìì‹ ì´ ì†í•œ `function context`ì˜ ê°’ì„ ìº¡ì²˜í•  ìˆ˜ ìˆëŠ” `Closures`
- Closure Expressions : ì´ë¦„ì´ ì—†ê³ , ìì‹ ì´ ì†í•œ `context`ì˜ ê°’ì„ ìº¡ì²˜í•  ìˆ˜ ìˆëŠ” ê²½ëŸ‰í™”ëœ `Closures`

__2 ) Swift `Closures`ì˜ ìµœì í™”ê°€ ê°–ëŠ” íŠ¹ì§•__

- `context`ë¡œë¶€í„° `parameter`ì™€ `return value`ë¥¼ ì¶”ë¡ (inferring)í•œë‹¤
- ë‹¨ì¼ í‘œí˜„ í´ë¡œì €(single-expression closures)ì—ì„œ ì•”ì‹œì  ë°˜í™˜(implicit returns)
- ì¶•ì•½ëœ ì¸ì ì´ë¦„(shorthand argument names)
- í›„ìœ„ í´ë¡œì € ë¬¸ë²•(trailing closure syntax)

<br>

`Closure Expressions`ëŠ” ì´ë¦„ì´ ì—†ìœ¼ë‚˜ ê²½ëŸ‰í™”ëœ ë¬¸ë²•ìœ¼ë¡œ ì¬ì‚¬ìš© ë˜ì§€ ì•ŠëŠ” í•¨ìˆ˜,
ì£¼ë¡œ `Nested Functions`ë¥¼ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.

#### 1. The Sorted Method

`sorted(by:)` ë©”ì„œë“œëŠ”, `Comparable` í”„ë¡œí† ì½œì„ ë”°ë¥´ëŠ” íƒ€ì…ì— ëŒ€í•´
`(Type, Type) -> Bool` íƒ€ì…ì˜ `Closures`ë¥¼ `arguments`ë¡œ ë°›ì•„ ì •ë ¬ì„ ìˆ˜í–‰í•œë‹¤.  
`true`ë©´ ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šê³ , `false`ë©´ ìˆœì„œë¥¼ ë°”ê¾¼ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
```

`(String, String) -> Bool` íƒ€ì…ì˜ `Closures`ë¥¼ `arguments`ë¡œ ë°›ì•„ ì •ë ¬ì„ ìˆ˜í–‰í•´ë³´ë„ë¡ í•˜ì.  
ì´ë¥¼ ìœ„í•´ `Global Functions` í˜•íƒœì˜ `Closures`ë¡œ `forware(_:_:)`, `backward(_:_:)`ë¥¼ ìƒì„±í•œë‹¤.

- ascending order(default)

```swift
func forward(_ s1: String, _ s2: String) -> Bool {
    s1 < s2
}

func backward(_ s1: String, _ s2: String) -> Bool {
    s1 > s2
}
```

- descending order

```swift
print("origin          : \(names)")
print("default         : \(names.sorted())")
print("ascending order : \(names.sorted(by: forward))")
print("descending order: \(names.sorted(by: backward))")
```

```console
origin          : ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
default         : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
ascending order : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descending order: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### 2. Closure Expression Syntax

__Syntax__

```swift
{ (parameters) -> return type in
    statements
}
```

__Closure Expressions ëŠ” ë‹¤ìŒ íŠ¹ì§•ì„ ê°–ëŠ”ë‹¤__

- `Global Functions`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `In-Out Parameters`, `Variadic Parameters`, `Tuple Type Parameters`, `Tuple Type Return`ì´
  í—ˆìš©ëœë‹¤.
- ë‹¨, <span style="color: red;">**Default Values**ëŠ” í—ˆìš©ë˜ì§€ ì•ŠëŠ”ë‹¤</span>.

<br>

ìœ„ ì •ë ¬ì€ `Global Functions` í˜•íƒœì˜ `Closures` ëŒ€ì‹  `Closure Expressions`
í˜•íƒœì˜ `Closures`ë¥¼ ì´ìš©í•˜ë©´ ë”ìš± ê°„ê²°í•œ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

```swift
let ascendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 < s2 })
let descendingOrderNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })

print("ascendingOrderNames : \(ascendingOrderNames)")
print("descendingOrderNames: \(descendingOrderNames)")
```

```console
ascendingOrderNames : ["Alex", "Barry", "Chris", "Daniella", "Ewa"]
descendingOrderNames: ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

#### 3. Inferring Type From Context

`Inline-Closures`ëŠ” í•­ìƒ `context`ë¡œë¶€í„° `parameter types`ì™€  `return types`ë¥¼
ì¶”ë¡ (infer)í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ `type`ì„ ì ì„ í•„ìš”ê°€ ì—†ë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ arrow(`->`) ì—­ì‹œ í•„ìˆ˜ê°€ ì•„ë‹ˆë‹¤.  
ë‹¨, ìœ„ 2ë²ˆ ì²˜ëŸ¼ ëª…ì‹œì ìœ¼ë¡œ ì ëŠ” ê²ƒì€ ê°€ëŠ¥í•˜ë‹¤.

```swift
// ascending order
names.sorted(by: { s1, s2 in return s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in return s1 > s2 })
```

#### 4. Implicit Return from Single-Expression Closures

í•¨ìˆ˜ì™€ ë§ˆì°¬ê°€ì§€ë¡œ `Single-Expression Closures`ëŠ” `return` í‚¤ì›Œë“œë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.  
ì‚¬ì‹¤ `Global Functions` í˜•íƒœì˜ `Closures`ê°€ ê°€ëŠ¥í–ˆìœ¼ë‹ˆ `Closure Expressions` í˜•íƒœì˜
`Closures` ì—­ì‹œ ê°€ëŠ¥í•œ ê²ƒì€ ë‹¹ì—°í•˜ë‹¤.

```swift
// ascending order
names.sorted(by: { s1, s2 in s1 < s2 })

// descending order
names.sorted(by: { s1, s2 in s1 > s2 })
```

#### 5. Shorthand Argument Names

`Inline-Closures`ì— `Shorthand Argument Names`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°, `arguments`ë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë©°,
ì´ëŠ” `$0`, `$1`, `$2`ë¡œ í‘œí˜„ëœë‹¤. `arguments`ì˜ ê°¯ìˆ˜ëŠ” ê°€ì¥ ë†’ì€ ë²ˆí˜¸(ì´ ê²½ìš° `$2`)ë¡œë¶€í„° ì¶”ë¡ ëœë‹¤.  
ë˜í•œ `Shorthand Argument Names`ë¥¼ ì‚¬ìš©í•˜ë©´, `arguments`ë¥¼ ìƒëµí•˜ë¯€ë¡œ `in` í‚¤ì›Œë“œ ì—­ì‹œ ìƒëµí•˜ë©°,
`body`ë§Œìœ¼ë¡œ `Closures`ë¥¼ êµ¬ì„±í•œë‹¤.

```swift
// ascending order
names.sorted(by: { $0 < $1 })

// descending order
names.sorted(by: { $0 > $1 })
```

#### 6. Operator Methods

`String`ì€ <span style="color: red;">greater-than operator(`>`)</span>ë¥¼ ë©”ì„œë“œë¡œ ê°–ëŠ”ë‹¤.
ë˜í•œ ì´ ë©”ì„œë“œëŠ” ë‘ ê°œì˜ `parameters`ë¥¼ ê°–ê³ , `Bool`ì„ ë°˜í™˜í•œë‹¤. ì¦‰, ìœ„ì—ì„œ `sorted(by:)`ê°€ `Closures`ë¡œ
ë°›ëŠ” ìœ í˜•ê³¼ ì •í™•íˆ ì¼ì¹˜í•œë‹¤. ë”°ë¼ì„œ ì´ ê²½ìš° `Shorthand Argument Names` ë§ˆì €ë„ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
// ascending order
names.sorted(by: <)

// descending order
names.sorted(by: >)
```

---

### 2. Trailing Closures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ë§ˆì§€ë§‰ `parameter`ê°€ `Closure`ì´ê³ , ì „ë‹¬ ë˜ëŠ” `argument`ê°€ ê¸´ í‘œí˜„ì‹ì¼ ê²½ìš° 
`Trailing Closure`ë¥¼ ì´ìš©í•´ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤. `Trailing Closure`ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ 
ê´„í˜¸(`( )`) ë‹¤ìŒì— ì‘ì„±í•˜ì§€ë§Œ ì—¬ì „íˆ í•¨ìˆ˜ì˜ `arguments`ë‹¤.

í•¨ìˆ˜ëŠ” ì—¬ëŸ¬ ê°œì˜ `Trailing Closures`ë¥¼ `arguments`ë¡œ ì…ë ¥ ë°›ì„ ìˆ˜ ìˆìœ¼ë©°, 
ì²« ë²ˆì§¸ `Trailing Closure`ì˜ `argument labels`ëŠ” ìƒëµë  ìˆ˜ ìˆë‹¤.

#### 1. Trailing Closure Syntax

ì•„ë˜ `someFunctionThatTakesAClosure(closure:)` í•¨ìˆ˜ëŠ” ë§ˆì§€ë§‰ `arguments`ë¥¼ `Closures`ë¡œ ê°–ëŠ” í•¨ìˆ˜ë‹¤.

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}
```

<br>

ì´ì œ ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ë³´ì.

__1 ) `Trailing Closures` ì—†ì´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

í•¨ìˆ˜ì˜ `argument`ë¡œ `Closure`ë¥¼ ì „ë‹¬í•œë‹¤. ì´ë•Œ í•¨ìˆ˜ì˜ `arguments`, `return types`, `arrow(->)`ì€ ìƒëµí–ˆë‹¤.

```swift
someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})
```

<br>

__2 ) `Trailing Closures`ë¡œ ë¶„ë¦¬í•´ í•¨ìˆ˜ë¥¼ í˜¸ì¶œ__

ì²« ë²ˆì§¸ `Trailing Closure`ì´ë¯€ë¡œ `argument labels`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}
```

> `Trailing Closures`ì˜ í˜•íƒœë¥¼ ë³´ë©´ `Global Functions`ì™€ ê°™ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.  
> ì¦‰, `Global Functions`ê°€ `Closures`ì˜ í˜•íƒœ ì¤‘ í•˜ë‚˜ë¼ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

<br>

__3 ) `Trailing Closures`ê°€ í•¨ìˆ˜ì˜ ìœ ì¼í•œ `arguments`ì¼ ë•ŒëŠ” ê´„í˜¸`( )`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤__

```swift
someFunctionThatTakesAClosure {
    // trailing closure's body goes here
}
```

#### 2. Trailing Closure Examples

__1 ) Examples 1: 'sorted(by:)'__

ìœ„ `sorted(by:)`ë¥¼ `Trailing Closures`ë¥¼ ì´ìš©í•´ í˜¸ì¶œí•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let descendingNames = names.sorted { $0 > $1 }

print(descendingNames)  // ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
```

<br>

`Closures`ë¥¼ ì „ë‹¬í•´ ì‚¬ìš©í•  ë•Œì™€ `Trailing Closures`ë¥¼ ì‚¬ìš©í• ì˜ ì°¨ì´ì„ ë¹„êµí•´ë³´ì.

- Without Trailing Closures

`Closure Expressions`ëŠ” `Operator Methods`ë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

```swift
names.sorted(by: { $0 > $1 } )

// Using Operator Methods
names.sorted(by: >)
```

<br>

- With Trailing Closures

í•˜ì§€ë§Œ `Trailing Closure`ì€ `Operator Methods`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

```swift
names.sorted { $0 > $1 }

// Using Operator Methods
print(names.sorted { > })   // error: unary operator cannot be separated from its operand
```

<br>

__2 ) Examples 2: 'map(_:)'__

`map(_:)` ë©”ì„œë“œë¥¼ ì´ìš©í•´ ì•„ë˜ ì£¼ì–´ì§„ `digitNames`, `numbers` ë°°ì—´ë¡œë¶€í„°
ìƒˆ ë°°ì—´ `["OneSix", "FiveEight", "FiveOneZero"]`ì„ ë°˜í™˜í•˜ë„ë¡ `Trailing Closures`ë¥¼ ì´ìš©í•´
`map(_:)` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ë³´ì.

```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
```

```swift
let strings = numbers.map { number -> String in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ìœ„ `Trailing Closures`ì˜ `Return Types`ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map { number in
    var number = number
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

<br>

ë§ˆì§€ë§‰ìœ¼ë¡œ, `Trailing Closures` ì—­ì‹œ `Shorthand Argument Names`ë¥¼ ì´ìš©í•´ 
`arguments`ì™€ `in` í‚¤ì›Œë“œ ì—­ì‹œ ìƒëµí•´ ìµœì í™” í•  ìˆ˜ ìˆë‹¤.

```swift
let strings = numbers.map {
    var number = $0
    var output = ""

    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0

    return output
}

print(strings)  // ["OneSix", "FiveEight", "FiveOneZero"]
```

#### 3. A function takes "_Multiple Closures_"

ë§Œì•½ í•¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°œì˜ `Closures`ë¥¼ ê°€ì§ˆ ê²½ìš°, ì²« ë²ˆì§¸ `Trailing Closure`ì˜ `argument labels`ì€ 
ìƒëµí•  ìˆ˜ ìˆë‹¤. ê·¸ ì™¸ ë‚˜ë¨¸ì§€ `Trailing Closures`ëŠ” `labels`ì„ ì§€ì •í•´ì•¼í•œë‹¤.

<br>

ì•„ë˜ `loadPicture(from:completion:onFailure:)` í•¨ìˆ˜ë¥¼ ë³´ì.

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
```

`loadPicture(from:completion:onFailure:)`ëŠ” 3 ê°œì˜ `arguments`ë¥¼ ê°–ê³  ìˆëŠ”ë°, ì²« ë²ˆì§¸ `argument`ëŠ” 
`Server` ê°ì²´ê³ , ë‘ ë²ˆì§¸ `argument`ëŠ” `(Picture) -> Void` `Closure`, ì„¸ ë²ˆì¬ `argument`ëŠ” 
`() -> Void` `Closure`ë‹¤.

ì¦‰, ì²« ë²ˆì§¸ `Clousre` `(Picture) -> Void`ëŠ” `completion handler`ë¡œ `Server`ë¡œë¶€í„° ìš”ì²­ 
ê²°ê³¼ê°€ ì„±ê³µì¼ ê²½ìš° `Function Body`ì˜ `if` statement ë¥¼ í†µí•´ ì‚¬ìš©ìì—ê²Œ ì‚¬ì§„ì„ ë³´ì—¬ì¤„ ê²ƒì´ë‹¤. 
ë‘ ë²ˆì§¸ `Closure` `() -> Void`ëŠ” `error handler`ë¡œ ì‹¤íŒ¨ í–ˆì„ ê²½ìš° `else` clause ë¥¼ í†µí•´ 
ì‚¬ìš©ìì—ê²Œ ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŒì„ ì•Œë ¤ì¤„ ê²ƒì´ë‹¤.

ì´ ë‘ `completion handler`ë¥¼ `Trailing Closures`ë¥¼ ì´ìš©í•´ í˜¸ì¶œí•´ë³´ì.

```swift
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

> `loadPicture(from:completion:onFailure:)` í•¨ìˆ˜ëŠ” 2 ê°œì˜ `completion handler`ë¥¼ ê°€ì§€ê³  ìˆë‹¤.  
> í•˜ë‚˜ëŠ” ìš”ì²­ì´ ì„±ê³µí–ˆì„ ê²½ìš° í˜¸ì¶œí•˜ëŠ” `success handler`, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ì‹¤íŒ¨í–ˆì„ ê²½ìš° í˜¸ì¶œí•˜ëŠ” `error handler`ë‹¤.
>
> ê²€ìƒ‰ì„ í•˜ë‹¤ ë³´ë©´ ê¸€ì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì€ ë‘ ê°€ì§€ ì„¤ëª…ì´ í˜¼ì¬í•  ìˆ˜ ìˆë‹¤.  
> ë‘ ê°œì˜ `completion handler`ë¥¼ ê°€ì§€ê³  ìˆê³ , í•˜ë‚˜ëŠ” `completion handler`, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” `error handler`ë‹¤.  
> ë‘ ê°œì˜ `completion handler`ë¥¼ ê°€ì§€ê³  ìˆê³ , í•˜ë‚˜ëŠ” `success handler`, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” `error handler`ë‹¤.
>
> `loadPicture(from:completion:onFailure:)`ì™€ ê°™ì´ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë©´, í•˜ë‚˜ì˜ `Closure`ì— `success`, `error`ë¥¼ 
> ì²˜ë¦¬í•˜ëŠ” ì½”ë“œë¥¼ í˜¼ì¬í•˜ì§€ ì•Šê³  `case` ë³„ë¡œ ì½”ë“œë¥¼ ëª…í™•í•˜ê²Œ ë¶„ë¦¬í•  ìˆ˜ ìˆë‹¤.

---

### 3. Capturing Values ğŸ‘©â€ğŸ’»

`Closures`ëŠ” ì •ì˜ë  ë•Œ ì£¼ë³€ `context`ì˜ ìƒìˆ˜ë‚˜ ë³€ìˆ˜, ì¸ìˆ˜ë¥¼ ìº¡ì²˜í•´ ì €ì¥í•  ìˆ˜ ìˆë‹¤.    
`Nested Functions`ëŠ” ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœì˜ ê°’ ìº¡ì²˜ë¡œ `context`ë‚´ì˜ ì–´ë– í•œ `constant`, 
`variables`, `arguments`ë“  ìº¡ì²˜í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ì— `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ë³´ì.

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

- `makeIncrementer(forIncrement:)` í•¨ìˆ˜ëŠ” (Int)ë¥¼ `arguments`ë¡œ ë°›ì•„ 
  `() -> Int` íƒ€ì…ì˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.

- í•¨ìˆ˜ì˜ `body`ë¥¼ ì‚´í´ë³´ë©´, ì•ˆì— ì •ì˜ëœ `Nested Funcgtion`ì¸ `incrementer()`ëŠ”
  ì£¼ë³€ `context`ì—ì„œ ë³€ìˆ˜ `runningTotal`ì™€ 'forIncrement' ì¸ìˆ˜ë¡œ ì „ë‹¬ëœ íŒŒë¼ë¯¸í„° `amount`ë¥¼
  ì €ì¥í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.

- ë§ˆì§€ë§‰ìœ¼ë¡œ `() -> Int` íƒ€ì…ì˜ í•¨ìˆ˜ `incrementer()`ë¥¼ ë°˜í™˜í•œë‹¤.

ë°˜í™˜ëœ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì„ ê²ƒì´ë‹¤.

```swift
func incrementer() -> Int {
    runningTotal += amount
    return runningTotal
}
```

ë°˜í™˜ëœ í•¨ìˆ˜ ì–´ë””ì—ë„ `runningTotal`ê³¼ `amount`ê°€ ì •ì˜ë˜ì–´ìˆì§€ ì•Šì§€ë§Œ ì´ í•¨ìˆ˜ëŠ” ì‘ë™í•œë‹¤.  
<span style="color: red;">ê°’ì„ ìº¡ì²˜</span>í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

<br>

`makeIncrementer(forIncrement:)` í•¨ìˆ˜ëŠ” `(Int)`ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ ê°’ì„ ìº¡ì²˜í•´ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ”  
ì¦‰, ì¸ìˆ˜ë¥¼ ë°›ì•„ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë‚´ëŠ” í•¨ìˆ˜ë‹¤. <span style="color: red;">ì¬ì‚¬ìš©</span>ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ë§ì´ë‹¤.

```swift
let incrementByThree = makeIncrementer(forIncrement: 3)
let incrementByFive = makeIncrementer(forIncrement: 5)

print(incrementByThree())   // 3
print(incrementByThree())   // 6
print(incrementByThree())   // 9

print(incrementByFive())    // 5
print(incrementByFive())    // 10

print(incrementByThree())   // 12

print(incrementByFive())    // 15
```

> `incrementByThree()`ì™€ `incrementByFive()`ê°€ ì„œë¡œì—ê²Œ ì˜í–¥ì„ ì£¼ì§€ ì•Šê³ 
> ê°ê° ì‘ë™í•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” <span style="color: red;">ê°’ì„ ìº¡ì²˜</span>í–ˆê¸° ë•Œë¬¸ì´ë‹¤.
>
> Swift ëŠ” ê°’ì„ ìº¡ì²˜í•  ë•ŒëŠ” ë¬¼ë¡ ì´ê³  ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•Šì„ ê²½ìš° ì œê±°í•˜ëŠ” ê²ƒê³¼ ê°™ì€
> ëª¨ë“  ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ì•Œì•„ì„œ ì²˜ë¦¬í•œë‹¤.

ë™ì¼í•œ ë¡œì§ì„ `TypeScript`ë¡œ êµ¬í˜„í•œ ì½”ë“œê°€ ì•„ë˜ ìˆë‹¤. `Swift`ì™€ ë¹„êµí•´ë³´ì.

```typescript
const makeIncrementer: (forIncrement: number) => () => number
    = amount => {
    let runningTotal = 0
    const incrementer: () => number
        = () => {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

```typescript
const incrementByThree = makeIncrementer(3)
const incrementByFive = makeIncrementer(5)

console.log(incrementByThree())   // 3
console.log(incrementByThree())   // 6
console.log(incrementByThree())   // 9

console.log(incrementByFive())    // 5
console.log(incrementByFive())    // 10

console.log(incrementByThree())   // 12

console.log(incrementByFive())    // 15
```

<br>

> `Closure`ë¥¼ `Class instance`ì˜ `Property`ì— í• ë‹¹í•˜ê³ ,
> ê·¸ `Closure`ê°€ í•´ë‹¹ `instance` ë˜ëŠ” í•´ë‹¹ `instance`ì˜ `memebrs`ë¥¼ ì°¸ì¡°ë¡œ ìº¡ì²˜í•˜ë©´
> `Strong Reference Cycle`(ê°•í•œ ìˆœí™˜ ì°¸ì¡°)ê°€ ìƒì„±ëœë‹¤.
>
> ë”°ë¼ì„œ Swift ëŠ” ì´ ìˆœí™˜ì„ ì¤‘ë‹¨ì‹œí‚¤ê¸° ìœ„í•´ `Capture Lists`ë¥¼ ì´ìš©í•œë‹¤. í•´ë‹¹ ë‚´ìš©ì€ ë‹¤ìŒì„ ì°¸ê³ í•œë‹¤. 
> [Strong Reference Cycles for Closures][Strong Reference Cycles for Closures]

[Strong Reference Cycles for Closures]:https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56

---

### 4. Closures Are Reference Types ğŸ‘©â€ğŸ’»

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```

```swift
let incrementByTen = makeIncrementer(forIncrement: 10)
let anotherIncrementByTen = makeIncrementer(forIncrement: 10)
let referToIncrementByTen = incrementByTen
```

ìœ„ì—ì„œ `let` í‚¤ì›Œë“œë¥¼ ì´ìš©í•´ ë‹¤ìŒê³¼ ê°™ì´ 3ê°œì˜ ìƒìˆ˜ë¥¼ ì„ ì–¸í–ˆë‹¤.

- `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë°˜í™˜ëœ í•¨ìˆ˜ë¥¼ `incrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.
- `makeIncrementer(forIncrement:)` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë°˜í™˜ëœ í•¨ìˆ˜ë¥¼ `anotherIncrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.
- `incrementByTen` ìƒìˆ˜ë¥¼ `referToIncrementByTen` ìƒìˆ˜ì— í• ë‹¹í–ˆë‹¤.

<br>

```swift
print(incrementByTen())         // 10
print(incrementByTen())         // 20
print(incrementByTen())         // 30

print(anotherIncrementByTen())  // 10

print(referToIncrementByTen())  // 40
print(incrementByTen())         // 50
```

ëª¨ë‘ `let` í‚¤ì›Œë“œë¥¼ ì´ìš©í•´ ìƒìˆ˜ë¡œ ì„ ì–¸í–ˆì§€ë§Œ ìº¡ì²˜í•œ ì—¬ì „íˆ `runningTotal` ë³€ìˆ˜ì˜ ê°’ì€ ë³€ê²½ë˜ê³ ìˆë‹¤. __*ì™œ ê·¸ëŸ´ê¹Œ?*__  
`incrementByTen()`ê³¼ `referToIncrementByTen()`ì€ __*ì™œ ê°™ì€ ê°’ì„ ë°˜í™˜í• ê¹Œ?*__

> `Functions`ì™€ `Closures`ëŠ” `Reference Types`(ì°¸ì¡° íƒ€ì…)ì´ë‹¤.
> `let` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ ìƒìˆ˜ë¡œ ì„ ì–¸ëœê±´ `incrementByTen`, `anotherIncrementByTen`, 
> `referToIncrementByTen`ë‹¤. ê·¸ëŸ°ë° `makeIncrementer(forIncrement:)` í•¨ìˆ˜ê°€ ë°˜í™˜í•œ 
> ê°’ì´ `Value Types`ê°€ ì•„ë‹Œ `Reference Types`ì´ë¯€ë¡œ ê° ìƒìˆ˜ëŠ” í•´ë‹¹ `instance`ë¥¼ ì°¸ì¡°í•œë‹¤.
> 
> ì¦‰, ìƒìˆ˜ `incrementByTen`ëŠ” `makeIncrementer(forIncrement: 10)`ê°€ ë°˜í™˜í•œ í•¨ìˆ˜ì˜ 
> `instance`ë¥¼ ì°¸ì¡°í•˜ê³  ìˆëŠ” ê²ƒì´ë‹¤.
> 
> ê·¸ë ‡ê¸° ë•Œë¬¸ì— ìº¡ì²˜ëœ ë³€ìˆ˜ `runningTotal`ê°€ ë³€ê²½ë  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤. ì´ ê²ƒì´ ì²« ë²ˆì§¸ ì§ˆë¬¸ì˜ ë‹µì´ë‹¤.
> 
> ë‘ ë²ˆì§¸ ì§ˆë¬¸ì˜ ë‹µì€ ë‹¤ìŒê³¼ ê°™ë‹¤. `incrementByTen`ì™€ `anotherIncrementByTen`ì€ ì‹¤ì œë¡œ ì™„ì „íˆ 
> ë™ì¼í•œ ë‚´ìš©ì˜ í•¨ìˆ˜ë¥¼ ê°€ì§€ê³  ìˆì§€ë§Œ `makeIncrementer(forIncrement: 10)`ê°€ ë°˜í™˜í•œ ì„œë¡œ ë‹¤ë¥¸ 
> ë‘ ê°œì˜ `instance`ë¥¼ ì°¸ì¡°í•˜ê³ ìˆë‹¤. ë”°ë¼ì„œ ìº¡ì²˜ëœ ë³€ìˆ˜ ë˜í•œ ë‹¤ë¥´ë‹¤. ë°˜ë©´, `referToIncrementByTen`ëŠ” 
> `incrementByTen`ì„ ë³µì‚¬í–ˆë‹¤. í•˜ì§€ë§Œ `Value Types`ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ë™ì¼í•œ `instance`ë¥¼ ì°¸ì¡°í•œë‹¤. 
> ì¦‰, ë‘˜ì€ í•˜ë‚˜ì˜ `instance`ë¥¼ ê³µìœ í•˜ëŠ” ê²ƒì´ë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— ìº¡ì²˜ëœ ë³€ìˆ˜ `runningTotal`ë„ ë™ì¼í•œ 
> ê°’ì„ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ë‹¤.

---

### 5. Escaping Closures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ì— `arguments`ë¡œ ì „ë‹¬ëœ `Closures`ì˜ í˜¸ì¶œ ì‹œì ì— ë”°ë¼ ë‘ ê°€ì§€ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.

1. í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ê¸° ì „ì— í˜¸ì¶œ: í•¨ìˆ˜ì˜ `body` ë‚´ì—ì„œ í˜¸ì¶œëœë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì „ë‹¬ëœ `Closures`ê°€ í˜¸ì¶œë˜ëŠ” ë°©ì‹ì´ë‹¤.
2. í•¨ìˆ˜ê°€ ì¢…ë£Œëœ í›„ í˜¸ì¶œ: `asynchronous`(ë¹„ë™ê¸°) ì²˜ë¦¬ë¥¼ ì‹œì‘í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ í•¨ìˆ˜ëŠ” `arguments`ë¡œ 
   `completion handler`ë¥¼ ì‚¬ìš©í•œë‹¤. ì´ë¥¼ `Escaping Closures`ë¼ í•˜ë©°, 
   <span style="color: red;">ë°˜ë“œì‹œ `Parameter Types` ì•ì— `@escaping` í‚¤ì›Œë“œë¥¼ ë¶™ì—¬ í•´ë‹¹ 
   `Closures`ê°€ `escape` ë  ìˆ˜ ìˆìŒì„ ëª…ì‹œ</span>í•´ì•¼í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ `compile-time error`ê°€ ë°œìƒí•œë‹¤.

#### 1. Store in a variable

`Closures`ë¥¼ `escape` ì‹œí‚¤ëŠ” ë°©ë²•ì€ `parameters`ë¥¼ í•¨ìˆ˜ `context` ì™¸ë¶€ ë³€ìˆ˜ì— ì €ì¥í•˜ëŠ” ê²ƒì´ë‹¤.

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: () -> Void) {
    completionHandlers.append(completionHandler)    // error: converting non-escaping parameter 'completionHandler' to generic parameter 'Element' may allow it to escape
}
```

`parameter`ë¡œ ì „ë‹¬ëœ `() -> Void` íƒ€ì…ì˜ `completionHandler`ë¼ëŠ” ì´ë¦„ì˜ `Closures`ë¥¼ 
í•¨ìˆ˜ `context` ì™¸ë¶€ ë³€ìˆ˜ì— ì €ì¥í•˜ë ¤ í•œë‹¤. ì¦‰, í•¨ìˆ˜ì˜ `body` ì™¸ë¶€ë¡œ `escape`ì‹œí‚¤ë ¤ëŠ” í–‰ìœ„ì´ë¯€ë¡œ
`Parameter Types` ì•ì— `@escaping` í‚¤ì›Œë“œë¥¼ ë°˜ë“œì‹œ ëª…ì‹œí•´ì•¼í•œë‹¤.

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

`Escaping Closures`ê°€ `Class`ì˜ `instance`ì˜ `self`ë¥¼ ì°¸ì¡°í•˜ëŠ” ê²½ìš° ì£¼ì˜í•´ì•¼í•œë‹¤. 
`self`ë¥¼ ìº¡ì²˜í•  ê²½ìš° ë„ˆë¬´ë„ ì‰½ê²Œ `Strong Reference Cycle`(ê°•í•œ ìˆœí™˜ ì°¸ì¡°) 
ë¥¼ ìƒì„±í•˜ëŠ” ì‹¤ìˆ˜ë¥¼ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤. `Reference Cycles`ì— ëŒ€í•´ ì¢€ ë” ìì„¸í•œ ë‚´ìš©ì€ 
[Automatic Reference Counting][Automatic Reference Counting]ì„ ì°¸ê³ í•œë‹¤.

[Automatic Reference Counting]:https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html

ë”°ë¼ì„œ ì¼ë°˜ì ìœ¼ë¡œ `Closures`ëŠ” ì•”ì‹œì (`implicit`)ìœ¼ë¡œ `Closure` ë‚´ë¶€ ë³€ìˆ˜ë¥¼ ì´ìš©í•´ ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•˜ì§€ë§Œ, 
`Escaping Closures`ëŠ” `self` í‚¤ì›Œë“œë¥¼ ê°•ì œí•´ ì½”ë“œë¥¼ ëª…ì‹œì (`explicit`)ìœ¼ë¡œ ì‘ì„±í•˜ë„ë¡ ë§Œë“¤ì–´ 
ê°œë°œìì—ê²Œ ìˆœí™˜ ì°¸ì¡°ê°€ ì—†ìŒì„ í™•ì¸í•˜ë„ë¡ ìƒê¸°ì‹œí‚¨ë‹¤.

```swift
var completionHandlers: [() -> Void] = []

func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}

func someFunctionWithNonescapingClosure(closure: () -> Void) {
    closure()
}

class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure {
            self.x = 100
        }
        someFunctionWithNonescapingClosure {
            x = 200
        }
    }
}
```

```swift
let instance = SomeClass()
instance.doSomething()      // `someFunctionWithNonescapingClosure` is called in `doSomething` function's body

print(instance.x)   // 200

completionHandlers.first?() // `someFunctionWithEscapingClosure ` is not called in `doSomething()` function's body
print(instance.x)   // 100
```

> 1. `SomeClass`ì˜ `instance`ë¥¼ ìƒì„±í•´ `instance` ì´ë¦„ì˜ ìƒìˆ˜ì— í• ë‹¹í•œë‹¤.
> 2. `instance`ì˜ `doSomething()`ì„ í˜¸ì¶œí•œë‹¤. ì´ë•Œ `someFunctionWithEscapingClosure(completionHandler:)`ëŠ” 
>    `doSomething()`ì˜ ì™¸ë¶€ì— ì €ì¥í•˜ëŠ” `Escaping Closure`ì´ë¯€ë¡œ í˜¸ì¶œë˜ì§€ ì•Šê³ , `someFunctionWithNonescapingClosure(closure:))`ë§Œ
>    í˜¸ì¶œëœë‹¤.
> 3. `instnace`ì˜ `x`ë¥¼ ì¶œë ¥í•œë‹¤. `200`ì´ ì¶œë ¥ëœë‹¤. `someFunctionWithNonescapingClosure(closure:))`ë§Œ
>    í˜¸ì¶œë˜ì—ˆê¸° ë•Œë¬¸ì´ë‹¤.
> 4. `completionHandlers.first?()`ë¥¼ í˜¸ì¶œí•œë‹¤. ì´ì œì„œì•¼ `Escaping Closure`ê°€ í˜¸ì¶œëœë‹¤.
> 5. `instnace`ì˜ `x`ë¥¼ ì¶œë ¥í•œë‹¤. `100`ì´ ì¶œë ¥ëœë‹¤.

<br>

ë‹¤ë¥¸ ë²„ì „ì˜ `doSomething()` í•¨ìˆ˜ë¥¼ ë³´ì. ë‹¤ìŒì€ `Escaping Closures`ì—ì„œë„ `self` í‚¤ì›Œë“œ ì‚¬ìš© ì—†ì´ 
ì•”ì‹œì (`implicit`)ìœ¼ë¡œ `Closure` ë‚´ë¶€ ë³€ìˆ˜ë¥¼ ì´ìš©í•´ ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

```swift
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { [self] in
            x = 100
        }
        someFunctionWithNonescapingClosure {
            x = 200
        }
    }
}
```

`self`ë¥¼ ìº¡ì²˜í•  ì¼ì´ ë§ë‹¤ë©´ `[self]`ë¥¼ ì´ìš©í•´ `implicit` í•˜ë„ë¡ ë§Œë“¤ë©´ í¸ë¦¬í•˜ê² ìœ¼ë‚˜ Swift ì˜ ì˜ë„ëŒ€ë¡œ 
`self` í‚¤ì›Œë“œë¥¼ í•„ìš”í•œ ê³³ì— ì§ì ‘ ëª…ì‹œí•´ `explicit` í•˜ë„ë¡ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ì•ˆì „í•œ ê²ƒ ê°™ë‹¤.

#### 2. Escaping Closures in Structures

`Structures`ë‚˜ `Enumerations`ì˜ `instance`ëŠ” í•­ìƒ `self`ê°€ ì•”ì‹œì (`implicit`)ì´ë‹¤. ë”°ë¼ì„œ 
`Functions`ì˜ `parameters`ì™€ `self`ì˜ ì´ë¦„ì´ ë™ì¼í•˜ì§€ ì•ŠëŠ” í•œ `self`ë¥¼ ëª…ì‹œí•  í•„ìš”ê°€ ì—†ë‹¤.

```swift
struct SomeStruct {
    var x = 10
    mutating func doSomething() {
        someFunctionWithNonescapingClosure { x = 200 }  // Ok
        someFunctionWithEscapingClosure { x = 100 }     // error: escaping closure captures mutating 'self' parameter
    }
}
```

í•˜ì§€ë§Œ ìœ„ì™€ ê°™ì€ ì½”ë“œëŠ” `compile-time error`ê°€ ë°œìƒëœë‹¤. `Value Types`ëŠ” ê°’ì˜ ì‹ ë¢°ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•´ 
ê¸°ë³¸ì ìœ¼ë¡œ `immutable` ì†ì„±ì„ ê°–ê¸° ë•Œë¬¸ì— ì´ë¥¼ ë³€ê²½í•˜ê¸° ìœ„í•´ì„œëŠ” `mutating` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•œ `context` 
ë‚´ë¶€ì˜ ì ‘ê·¼ì— ì˜í•´ì„œë§Œ ë³€ê²½ì´ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ `Escaping Closures`ëŠ” ì´ `context`ë¥¼ ë²—ì–´ë‚˜ ì¢…ë£Œëœ í›„ 
í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì´ë‹¤.

`mutating` í‚¤ì›Œë“œê°€ í•„ìš”í•œ ì½”ë“œë¥¼ ì œì™¸í•˜ë©´ `Escaping Closures`ëŠ” `Value Types`ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.

```swift
struct SomeStruct {
    var x = 10
    mutating func doSomething() {
        someFunctionWithNonescapingClosure { x = 200 }  // Ok
        someFunctionWithEscapingClosure { print("It's OK") }     // error: escaping closure captures mutating 'self' parameter
    }
}

var valueTypeInstance = SomeStruct()    // It must be declared with `var` not `let`, due to `doSomething()` use mutating member.
valueTypeInstance.doSomething()

print(valueTypeInstance.x)  // 200

completionHandlers[1]()     // It's OK
```

---

### 6. Autoclosures ğŸ‘©â€ğŸ’»

í•¨ìˆ˜ì— `arguments`ë¡œ ì „ë‹¬ë˜ëŠ” `expression`(í‘œí˜„ì‹)ì„ ë˜í•‘í•˜ê¸° ìœ„í•´ ìë™ìœ¼ë¡œ ìƒì„±ë˜ëŠ” í´ë¡œì €ë¡œ `arguments`ë¥¼ 
ê°–ì§€ ì•Šê³  í˜¸ì¶œë  ë•Œ ë‚´ë¶€ í‘œí˜„ì‹ì˜ ê°’ì„ ë°˜í™˜í•œë‹¤. ì´ëŸ¬í•œ í‘œí˜„ì€ í•¨ìˆ˜ë¥¼ ì •ì˜í•  ë•Œ `Explicit Closures`ë¥¼ í•¨ìˆ˜ì˜ 
`parameters`ë¥¼ ê°ì‚¬ëŠ” ê´„í˜¸`( )`ë¥¼ ìƒëµí•˜ê³  ë‹¨ìˆœí•œ `expression`(í‘œí˜„ì‹)ìœ¼ë¡œ ì‘ì„±í•  ìˆ˜ ìˆëŠ” í¸ì˜ë¥¼ ê°–ê²Œ í•œë‹¤.

`Autoclosures`ëŠ” ì½”ë“œë¥¼ í˜¸ì¶œí•  ë•Œ ê¹Œì§€ ì‹¤í–‰ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— í‰ê°€ë¥¼ ì§€ì—°í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ `side effects`ê°€ 
ìˆê±°ë‚˜ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ”(`computationally expensive`) ì½”ë“œì— ìœ ìš©í•˜ë‹¤.

#### 1. Closures evaluated when called

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

let returned = customersInLine.remove(at: 0)
print(returned) // Chris
```

`Arrays`ì˜ `remove(at:)` ë©”ì„œë“œëŠ” ì£¼ì–´ì§„ `index`ì˜ ë°°ì—´ì„ ì œê±° í›„ ê·¸ ê°’ì„ ë°˜í™˜í•œë‹¤. 

```swift
let customerProvider = { customersInLine.remove(at: 0) }
```

ë”°ë¼ì„œ ìœ„ì™€ ê°™ì´ ì •ì˜ëœ `customerProvider`ëŠ” `() -> String` íƒ€ì…ì´ë‹¤.

<br>
ë‹¤ìŒì€ `Closures`ê°€ ì½”ë“œ ì‹¤í–‰ì„ ì–´ë–»ê²Œ ì§€ì—°ì‹œí‚¤ëŠ”ì§€ë¥¼ ë³´ì—¬ì¤€ë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

let customerProvider = { customersInLine.remove(at: 0) }

print(customersInLine)          // ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 5

customerProvider()
print(customersInLine)          // ["Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 4

customerProvider()
print(customersInLine)          // ["Ewa", "Barry", "Daniella"]
print(customersInLine.count)    // 3
```

ìœ„ ì½”ë“œ ë¸”ëŸ­ì„ ë³´ë©´ `let customerProvider = { customersInLine.remove(at: 0) }`ë¼ì¸ ì´í›„ 
`customersInLine`ë¥¼ ì¶œë ¥í•´ë³´ë©´ ê·¸ëŒ€ë¡œì¸ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì´í›„ `customerProvider()`ê°€ í˜¸ì¶œë  ë•Œ 
ì œê±°ë˜ê³  ê·¸ ê°’ì„ ë°˜í™˜í•œë‹¤.

#### 2. Autoclosure Type Parameters

__1 ) Parameter Type is a Closure__

ì´ëŸ¬í•œ ì½”ë“œ ì§€ì—°ì€ í•¨ìˆ˜ì˜ `arguments`ë¡œ `Closures`ë¥¼ ì „ë‹¬í•  ë•Œë„ ë™ì¼í•œ ë™ì‘ì„ ê°–ëŠ”ë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}

serve(customer: { customersInLine.remove(at: 0) })  // Now serving Chris!
```

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => {
    return customersInLine.shift()!                 // Now serving Chris!
})
```

Swift ì™€ ë‹¬ë¦¬ `arguments` ìì²´ë¥¼ ìƒëµ í•  ìˆ˜ëŠ” ì—†ê³  ë¹„ì›Œì„œ ë³´ë‚´ì•¼í•œë‹¤.

<br>

__2 ) Parameter Type is an Autoclosure__

ì´ë•Œ `Parameter Types` ì•ì— `@autoclosure` í‚¤ì›Œë“œë¥¼ ë¶™ì—¬ì£¼ë©´ `arguments`ë¥¼ ë°›ì„ ë•Œ 
`Closure Bracket``{ }`ë¥¼ ìƒëµ ê°€ëŠ¥í•˜ê²Œ í•´ì£¼ê³ , ì´ë¥¼ ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ `Closures`ë¡œ ë˜í•‘í•œë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}

// `{ }` can be omitted
serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => customersInLine.shift()!)               // Now serving Chris!
```

> `Swift`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ í•¨ìˆ˜ì˜ `arguments`ë¡œ ì „ë‹¬ëœ `Closures`ì˜ `{ }`ëŠ” ìƒëµ ê°€ëŠ¥í•˜ë‹¤. í•˜ì§€ë§Œ 
> `TypeScript`ì—ì„œëŠ” `argumnets`ë¡œ ì „ë‹¬ëœ `Closures`ì˜ `arguments` ìì²´ë¥¼ ìƒëµí•˜ì§€ëŠ” ëª» í•œë‹¤.

<br>

__3 ) Parameter Type is a String__

í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ì½”ë“œë¥¼ ë³´ë©´ ìœ„ 2ë²ˆê³¼ ë™ì¼í•œ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì¦‰, `Autoclosures`ë¥¼ ì´ìš©í•˜ë©´ í˜¸ì¶œí•  ë•Œ 
`parameters`ê°€ ê·¸ëƒ¥ `String` íƒ€ì…ì¸ ê²ƒì²˜ëŸ¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: String) {
    print("Now serving \(customerProvider)!")
}

serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: string) {
    console.log(`Now serving ${customerProvider}!`)
}

serve(customersInLine.shift()!)
```

> ìœ„ 1 ~ 3ì€ ëª¨ë‘ ë™ì¼í•œ ë¡œì§ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ë¬¼ë¡ , í•¨ìˆ˜í˜• ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ì„œ `parameters`ë¥¼ 
> `Primitive Types`ë¥¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë“¯ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆì§€ë§Œ `Autoclosures`ì˜ ë‚¨ìš©ì€ 
> ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ì–´ë µê²Œ ë§Œë“ ë‹¤. ë”°ë¼ì„œ `Autoclosures`ë¥¼ ì‚¬ìš©í•  ê²½ìš° `context`ì™€ `function name`ì€ 
> í•¨ìˆ˜ì˜ `parameters`ê°€ `Closures`ì´ë©°, ì½”ë“œì˜ ì‹¤í–‰ì´ ì§€ì—°ë¨ì„ ë¶„ëª…íˆ í•´ì•¼í•œë‹¤. 

#### 3. Autoclosures with Escaping Closures

`@autoclosure`ê³¼ `@escaping`ì„ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
var customerProviders: [() -> String] = []

func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
    customerProviders.append(customerProvider)
}

collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")

print("customerProviders: \(customerProviders)")

for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
```

```console
Collected 2 closures.
[(Function), (Function)]
Now serving Chris!
Now serving Alex!
```

> ìœ„ì—ì„œë„ ì„¤ëª…í–ˆì§€ë§Œ, `Autoclosures`ì˜ ë‚¨ìš©ì€ ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ì–´ë µê²Œ ë§Œë“ ë‹¤.

### 7. Compare with TypeScript ğŸ‘©â€ğŸ’»

ì´ ê¸€ì˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ Swift ì˜ `Closures`ëŠ” ë‹¤ë¥¸ ì–¸ì–´ì˜ `Lambda expressions`ì™€ ë¹„ìŠ·í•˜ë‹¤ê³  í–ˆë‹¤. 
ë‹¤ì‹œ í•œ ë²ˆ ì •ë¦¬í•˜ë©´ì„œ ë§ˆë¬´ë¦¬í•´ë³´ì.

#### 1. `Function Declarations` with `function` / `func` keyword

```typescript
function sum(a: number, b: number): number {
    return a + b
}
console.log(sum(5, 7))  // 12
```

```swift
func sum(_ a: Int, _ b: Int) -> Int {
    a + b
}
print(sum(5, 7))    // 12
```

#### 2. `Function Expressions` with `Lambda expressions` / `Closures`

- Implicit Type Inference

```typescript
// Function Expressions with lambda expressions
const product = (a: number, b: number) => a * b
console.log(product(5, 7))  // 35
```

```swift
// Function Expressions with closures
let product = { (a: Int, b: Int) in
    a * b
}
print(product(5, 7))        // 35
```

> `Return Type`ì´ ìƒëµë˜ì—ˆë‹¤.

<br>

- Explicit Type Declaration

```typescript
const product = (a: number, b: number): number => a * b
console.log(product(5, 7))  // 35
```

```swift
let product = { (a: Int, b: Int) -> Int in
    a * b
}
print(product(5, 7))        // 35
```

ë˜ëŠ”

```typescript
const product: (num1: number, num2: number) => number = (a, b) => a * b
console.log(product(5, 7))  // 35
```

```swift
let product: (Int, Int) -> Int = { $0 * $1 }
print(product(5, 7))        // 35
```

#### 3. `Lambda expressions` / `Closures`

```typescript
// Function Expressions omit { }
const greetingMessage = () => "Hello~ TypeScript"
console.log(greetingMessage())  // Hello~ TypeScript
```

```swift
let greetingMessage = { "Hello~ Swift" }
print(greetingMessage())    // Hello~ Swift
```

#### 4. `Autoclosures`

```typescript
let customersInLine: string[] = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

function serve(customerProvider: () => string) {
    console.log(`Now serving ${customerProvider()}!`)
}

serve(() => customersInLine.shift()!)               // Now serving Chris!
```

```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}

// `{ }` can be omitted
serve(customer: customersInLine.remove(at: 0))      // Now serving Chris!
```

> `TypeScript` ì—­ì‹œ
> ```typescript
> serve(() => {
>     return customersInLine.shift()!                 // Now serving Chris!
> })
> ```
> ë¥¼ 
> ```typescript
> serve(() => customersInLine.shift()!)
> ```
> ë¡œ `{ }`ì™€ `return` í‚¤ì›Œë“œë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë‚˜ `Swift`ì™€ ë‹¬ë¦¬ `arguments` ìì²´ë¥¼ ìƒëµí•  ìˆ˜ëŠ” ì—†ì–´ 
> `Autoclosures`ì²˜ëŸ¼ ì™„ì „íˆ í‰ë¬¸ì„ ì ë“¯ì´ ì‘ì„±í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì¦‰ Swift ì™€ ê°™ì€ ì™„ì „í•œ `Autoclosures` 
> ê°œë…ì— ì¼ì¹˜í•˜ëŠ” ë¬¸ë²•ì€ ì—†ë‹¤.
> 
> ë‹¨, ì´ ê²½ìš°ëŠ” `Closure`ê°€ í•¨ìˆ˜ì˜ `arguments`ë¡œ ì „ë‹¬ë  ë•Œ `Autoclosures`ì— ì˜í•´ `{ }`ê°€ ìƒëµë˜ëŠ” ê²ƒì¼ ë¿ì´ë‹¤.  
> í•¨ìˆ˜ì˜ `arguments`ê°€ ì•„ë‹Œ ì¼ë°˜ì ì¸ `Closures`ë¥¼ ì„ ì–¸í•  ë•Œë¥¼ ë¹„êµí•´ë³´ë©´
> ```typescript
> const product = (a: number, b: number) => a * b
> ```
> 
> ```swift
> let product = { (a: Int, b: Int) in a * b }
> ```
> 
> `Closures`ì˜ `Body`ë¥¼ ê°ì‹¸ëŠ” `{ }`ë¥¼ `Single Line`ì¼ ê²½ìš° ìƒëµí•  ìˆ˜ ìˆëŠ” `TypeScript`ì™€ ë‹¬ë¦¬ 
> `Swift`ì—ì„œëŠ” ìƒëµí•  ìˆ˜ ì—†ë‹¤.  
> `Swift`ì—ì„œ `arguments`ë¥¼ ìƒëµí•  ìˆ˜ ìˆìœ¼ë‚˜ `TypeScript`ì—ì„œëŠ” ë°˜ë“œì‹œ í•„ìš”í–ˆë˜ ê²ƒê³¼ëŠ” ìƒë°˜ë˜ëŠ” ê²°ê³¼ë‹¤.
> 
> ì¦‰, ì´ê²ƒì€ ì–´ë–¤ ì–¸ì–´ê°€ ë” ìš°ìˆ˜í•˜ë‹¤ëŠ” ê²ƒì´ ì•„ë‹Œ ì–¸ì–´ì— ë”°ë¥¸ íŠ¹ì„±ì´ë‹ˆ ì´ë¥¼ ì˜ ì´í•´í•˜ê³  ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í•„ìš”í•˜ë‹¤.

#### 5. Capturing Values with `Closures`

`Functions`ëŠ” `Closures`ì˜ íŠ¹ë³„í•œ í˜•íƒœë¡œ ìœ„ 1~3ë²ˆ ëª¨ë‘ `Closures`ë‹¤. ë˜í•œ Swift ì˜ `Closures`ëŠ” ë‹¤ë¥¸ 
ì–¸ì–´ì˜ `Lambda expressions`ì™€ ë¹„ìŠ·í•˜ê¸° ë•Œë¬¸ì— ë‹¨ìˆœíˆ `Functions`ë¡œ ë³´ì¼ ìˆ˜ ìˆì§€ë§Œ Swift ë¿ ì•„ë‹ˆë¼ í•¨ìˆ˜ë¥¼ 
ì¼ê¸‰ ê°ì²´ë¡œ ì·¨ê¸‰í•˜ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ íŠ¹ì„±ì„ ë§í•˜ëŠ” ê²ƒìœ¼ë¡œ ë‹¤ë¥¸ ì–¸ì–´ì™€ ë¹„êµí•  ë•Œ ë‹¨ìˆœíˆ í•¨ìˆ˜ë¡œ ë³´ì´ëŠ” ìœ„ 1~3ë²ˆ 
ëª¨ë‘ `Clousres`ì˜ ë²”ì£¼ì— í¬í•¨ëœë‹¤.

í•˜ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ `Closures`ë¥¼ ì„¤ëª…í•  ë•Œ ì‚¬ìš©ë˜ëŠ” ê°œë…ì€ ë‹¤ìŒê³¼ ê°™ë‹¤. `ê°’ì„ ìº¡ì³`í•˜ê³ , í•¨ìˆ˜ê°€ `return value`ë¡œ 
ë˜ ë‹¤ë¥¸ `í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ë‚´ëŠ” ê²ƒ`.  
ìœ„ 1~3ë²ˆê³¼ ë‹¬ë¦¬ `Closures`ì˜ íŠ¹ì§•ì´ ìƒëµë˜ì§€ ì•Šì€ ì¼€ì´ìŠ¤ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

```typescript
const makeIncrementer: (forIncrement: number) => () => number
    = amount => {
    let runningTotal = 0
    const incrementer: () => number
        = () => {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}

const increaseByThree = makeIncrementer(3)

console.log(increaseByThree())   // 3
console.log(increaseByThree())   // 6
console.log(increaseByThree())   // 9
```

```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}

let increaseByThree = makeIncrementer(forIncrement: 3)

print(increaseByThree())    // 3
print(increaseByThree())    // 6
print(increaseByThree())    // 9
```

<br><br>

---
Reference

1. "Closures", The Swift Programming Language Swift 5.7. accessed Oct. 24, 2022, [Swift Docs Chapter 5 - Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)
